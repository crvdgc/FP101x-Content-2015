[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: None

[Aegisub Project Garbage]

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,Arial,20,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,2,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:01.03,0:00:04.99,Default,,0,0,0,,Welcome back to our lecture on list\Ncomprehensions.
Dialogue: 0,0:00:04.99,0:00:08.32,Default,,0,0,0,,What we're going to do
Dialogue: 0,0:00:08.32,0:00:11.75,Default,,0,0,0,,in the second part is talk about
Dialogue: 0,0:00:11.75,0:00:15.65,Default,,0,0,0,,a function called zip that we can\Nuse
Dialogue: 0,0:00:15.65,0:00:18.91,Default,,0,0,0,,to combine two lists into
Dialogue: 0,0:00:18.91,0:00:23.64,Default,,0,0,0,,a single list. Here's the\Nsignature for zip.
Dialogue: 0,0:00:23.64,0:00:26.84,Default,,0,0,0,,Zip has type list of a to
Dialogue: 0,0:00:26.84,0:00:29.97,Default,,0,0,0,,list of b, to list of pairs
Dialogue: 0,0:00:29.97,0:00:34.73,Default,,0,0,0,,of a comma b. Here's an example\Nof zipping two lists together.
Dialogue: 0,0:00:34.73,0:00:37.89,Default,,0,0,0,,There you can see why this
Dialogue: 0,0:00:37.89,0:00:41.21,Default,,0,0,0,,function is called zip.\NIt takes two lists and it takes
Dialogue: 0,0:00:41.21,0:00:44.98,Default,,0,0,0,,each value and combines them in a pair.
Dialogue: 0,0:00:44.98,0:00:48.57,Default,,0,0,0,,Zip of a b c, and 1, 2, 3, 4
Dialogue: 0,0:00:48.57,0:00:51.57,Default,,0,0,0,,is a 1, b 2, c 3.
Dialogue: 0,0:00:51.57,0:00:55.69,Default,,0,0,0,,And the zip stops as soon as one of the\Nlists
Dialogue: 0,0:00:55.69,0:01:00.89,Default,,0,0,0,,is exhausted so in this case you see\Nthere's four elements on the right list
Dialogue: 0,0:01:00.89,0:01:05.85,Default,,0,0,0,,but only three elements on the left list\Nand the resulting list
Dialogue: 0,0:01:05.85,0:01:10.67,Default,,0,0,0,,has three elements. As I mentioned in\None of the earlier lectures
Dialogue: 0,0:01:10.67,0:01:13.86,Default,,0,0,0,,I think the signature of zip
Dialogue: 0,0:01:13.86,0:01:17.99,Default,,0,0,0,,would be a little bit nicer if it was\Nnot curried. If you would write
Dialogue: 0,0:01:17.99,0:01:21.14,Default,,0,0,0,,pair of list of a, list of b,
Dialogue: 0,0:01:21.14,0:01:24.24,Default,,0,0,0,,to list of pair of a comma b.
Dialogue: 0,0:01:24.24,0:01:27.29,Default,,0,0,0,,But this is just the way
Dialogue: 0,0:01:27.29,0:01:30.49,Default,,0,0,0,,zip is defined in the Haskell standard\Nlibrary.
Dialogue: 0,0:01:30.49,0:01:33.65,Default,,0,0,0,,Using zip
Dialogue: 0,0:01:33.65,0:01:37.88,Default,,0,0,0,,we can define the following\Nfunction
Dialogue: 0,0:01:37.88,0:01:41.52,Default,,0,0,0,,that takes a list and creates pairs of
Dialogue: 0,0:01:41.52,0:01:46.22,Default,,0,0,0,,every adjacent value. Let's\Nfirst look at the
Dialogue: 0,0:01:46.22,0:01:50.25,Default,,0,0,0,,example down here, before we look at\Nthe implementation because I think when
Dialogue: 0,0:01:50.25,0:01:52.46,Default,,0,0,0,,you see the example the implementation
Dialogue: 0,0:01:52.46,0:01:57.89,Default,,0,0,0,,is fairly obvious. What we want to do\Nis given 1 2 3 4 we want to create a
Dialogue: 0,0:01:57.89,0:01:58.57,Default,,0,0,0,,chain
Dialogue: 0,0:01:58.57,0:02:02.15,Default,,0,0,0,,like a sliding window of pairs
Dialogue: 0,0:02:02.15,0:02:05.78,Default,,0,0,0,,1 2, 2 3, 3 4. You see that
Dialogue: 0,0:02:05.78,0:02:09.28,Default,,0,0,0,,the two is chained there.\NIt's 1 2,
Dialogue: 0,0:02:09.28,0:02:14.01,Default,,0,0,0,,2 3, and then 2 3, 3 4.\NHow can we do that
Dialogue: 0,0:02:14.01,0:02:17.01,Default,,0,0,0,,and this function here is
Dialogue: 0,0:02:17.01,0:02:20.51,Default,,0,0,0,,I think a beautiful
Dialogue: 0,0:02:20.51,0:02:24.01,Default,,0,0,0,,example of using zip
Dialogue: 0,0:02:24.01,0:02:27.26,Default,,0,0,0,,to do this. What you do
Dialogue: 0,0:02:27.26,0:02:30.68,Default,,0,0,0,,is: I take that list 1 2 3 4
Dialogue: 0,0:02:30.68,0:02:34.62,Default,,0,0,0,,then I take the tail of this list
Dialogue: 0,0:02:34.62,0:02:38.65,Default,,0,0,0,,2 3 4 and then I zip those two together.
Dialogue: 0,0:02:38.65,0:02:43.34,Default,,0,0,0,,Now what we get is since we start\Nthe first list is 1 2 3 4
Dialogue: 0,0:02:43.34,0:02:47.65,Default,,0,0,0,,and the second list is 2 3 4.\NNow when we zip it we get 2 3.
Dialogue: 0,0:02:47.65,0:02:52.10,Default,,0,0,0,,Then when we zip the next one we\Nget.. Sorry we zip that we get 1 2,
Dialogue: 0,0:02:52.10,0:02:55.73,Default,,0,0,0,,the next is 2 3 and the next is 3 4.
Dialogue: 0,0:02:55.73,0:02:59.06,Default,,0,0,0,,If you would draw
Dialogue: 0,0:02:59.06,0:03:02.98,Default,,0,0,0,,the picture, you get the list, you drop\Nthe first element
Dialogue: 0,0:03:02.98,0:03:06.56,Default,,0,0,0,,shift that one up and then you zip the\Ntwo and this
Dialogue: 0,0:03:06.56,0:03:11.04,Default,,0,0,0,,is exactly what you get.
Dialogue: 0,0:03:11.04,0:03:14.37,Default,,0,0,0,,Here's another function that
Dialogue: 0,0:03:14.37,0:03:18.22,Default,,0,0,0,,uses the function pairs
Dialogue: 0,0:03:18.22,0:03:22.29,Default,,0,0,0,,to check whether a list is sorted\Nso what we do is we
Dialogue: 0,0:03:22.29,0:03:25.97,Default,,0,0,0,,take all the adjacent pairs in\Nthe list.
Dialogue: 0,0:03:25.97,0:03:29.43,Default,,0,0,0,,That will give us x comma ys.
Dialogue: 0,0:03:29.43,0:03:34.00,Default,,0,0,0,,And then we check that the first value is\Nsmaller than the second.
Dialogue: 0,0:03:34.00,0:03:39.20,Default,,0,0,0,,A list is sorted if, if we look at\Nevery adjacent pair of elements
Dialogue: 0,0:03:39.20,0:03:43.81,Default,,0,0,0,,the first one is less than the second.\NThis is a super concise
Dialogue: 0,0:03:43.81,0:03:49.35,Default,,0,0,0,,way to check whether a list is sorted.\NLet's just look at some examples.
Dialogue: 0,0:03:49.35,0:03:53.12,Default,,0,0,0,,Is 1 2 3 4 sorted? Yes it is, because
Dialogue: 0,0:03:53.12,0:03:58.00,Default,,0,0,0,,one comma two, one is less that two.\NThen the next pair is two comma three.
Dialogue: 0,0:03:58.00,0:04:02.66,Default,,0,0,0,,Two is smaller than three. And the final pair\Nis three comma four.
Dialogue: 0,0:04:02.66,0:04:05.90,Default,,0,0,0,,Where three is less than four so that list\Nis sorted.
Dialogue: 0,0:04:05.90,0:04:10.18,Default,,0,0,0,,Is 1 3 2 4 sorted?
Dialogue: 0,0:04:10.18,0:04:13.31,Default,,0,0,0,,No, because the second pair in
Dialogue: 0,0:04:13.31,0:04:16.43,Default,,0,0,0,,pairs of this list is the pair
Dialogue: 0,0:04:16.43,0:04:19.45,Default,,0,0,0,,3 2 and there 3 is
Dialogue: 0,0:04:19.45,0:04:22.90,Default,,0,0,0,,greater than 2 so that will return false.
Dialogue: 0,0:04:22.90,0:04:27.24,Default,,0,0,0,,Using zip
Dialogue: 0,0:04:27.24,0:04:29.46,Default,,0,0,0,,we can also define
Dialogue: 0,0:04:29.46,0:04:33.45,Default,,0,0,0,,the positions of an element in a list.
Dialogue: 0,0:04:33.45,0:04:37.80,Default,,0,0,0,,As I mentioned before lists don't have
Dialogue: 0,0:04:37.80,0:04:41.14,Default,,0,0,0,,any position, unlike array's.\NIn an array you can
Dialogue: 0,0:04:41.14,0:04:46.81,Default,,0,0,0,,index into the array, but lists you\Ncannot. With lists you can only access the
Dialogue: 0,0:04:46.81,0:04:47.58,Default,,0,0,0,,elements
Dialogue: 0,0:04:47.58,0:04:51.24,Default,,0,0,0,,from left to right so I can take the\Nhead
Dialogue: 0,0:04:51.24,0:04:54.64,Default,,0,0,0,,and then the head of the tail and the head
Dialogue: 0,0:04:54.64,0:04:58.01,Default,,0,0,0,,of the tail of the tail et cetera.
Dialogue: 0,0:04:58.01,0:05:01.86,Default,,0,0,0,,But sometimes it's convenient to also\Nhave the position
Dialogue: 0,0:05:01.86,0:05:05.65,Default,,0,0,0,,of each element in a list.\NThis is a fairly common
Dialogue: 0,0:05:05.65,0:05:09.68,Default,,0,0,0,,operation, and the way we do that is\Nusing zip.
Dialogue: 0,0:05:09.68,0:05:13.29,Default,,0,0,0,,What we do is, we take the list xs.
Dialogue: 0,0:05:13.29,0:05:17.50,Default,,0,0,0,,We take the list from zero to n
Dialogue: 0,0:05:17.50,0:05:20.57,Default,,0,0,0,,where n is the length of this list.\NBut this
Dialogue: 0,0:05:20.57,0:05:24.67,Default,,0,0,0,,really can be the infinite less starting\Nat zero.
Dialogue: 0,0:05:24.67,0:05:27.99,Default,,0,0,0,,And then we just zip the
Dialogue: 0,0:05:27.99,0:05:31.11,Default,,0,0,0,,the list
Dialogue: 0,0:05:31.11,0:05:34.79,Default,,0,0,0,,with the positions to get
Dialogue: 0,0:05:34.79,0:05:37.95,Default,,0,0,0,,every element here.
Dialogue: 0,0:05:37.95,0:05:41.49,Default,,0,0,0,,If we look at the
Dialogue: 0,0:05:41.49,0:05:44.52,Default,,0,0,0,,positions here,
Dialogue: 0,0:05:44.52,0:05:47.93,Default,,0,0,0,,we get the positions of 0, well
Dialogue: 0,0:05:47.93,0:05:53.27,Default,,0,0,0,,those are these these these and these.\NSo what we did is we first zipped
Dialogue: 0,0:05:53.27,0:05:59.08,Default,,0,0,0,,every element with its position and then\Nwe filter out only the values
Dialogue: 0,0:05:59.08,0:06:02.33,Default,,0,0,0,,that we were looking for because here\Nwere only
Dialogue: 0,0:06:02.33,0:06:05.57,Default,,0,0,0,,interested in the positions of zero.
Dialogue: 0,0:06:05.57,0:06:12.13,Default,,0,0,0,,This thing goes in two steps, we first
Dialogue: 0,0:06:12.13,0:06:15.31,Default,,0,0,0,,pair every element with its position
Dialogue: 0,0:06:15.31,0:06:19.84,Default,,0,0,0,,and then we filter out only the\Nvalues that we were looking for
Dialogue: 0,0:06:19.84,0:06:26.84,Default,,0,0,0,,up there. In Haskell strings are\Nnothing more than syntactic sugar for
Dialogue: 0,0:06:28.03,0:06:29.31,Default,,0,0,0,,list of characters
Dialogue: 0,0:06:29.31,0:06:33.68,Default,,0,0,0,,which means that you can use\Ncomprehensions
Dialogue: 0,0:06:33.68,0:06:36.89,Default,,0,0,0,,over lists as well. For example here's\Nthe string
Dialogue: 0,0:06:36.89,0:06:39.60,Default,,0,0,0,,abc which
Dialogue: 0,0:06:39.60,0:06:42.60,Default,,0,0,0,,is really nothing more than the list of\Ncharacters
Dialogue: 0,0:06:42.60,0:06:47.02,Default,,0,0,0,,a b and c, and hence all operations on\Nlists
Dialogue: 0,0:06:47.02,0:06:50.04,Default,,0,0,0,,including comprehensions but also map,\Nfilter
Dialogue: 0,0:06:50.04,0:06:54.06,Default,,0,0,0,,foldr, all the list operations that\Nwe'll see
Dialogue: 0,0:06:54.06,0:06:58.56,Default,,0,0,0,,will work over strings.
Dialogue: 0,0:06:58.56,0:07:02.18,Default,,0,0,0,,For example the length of abcd is five.
Dialogue: 0,0:07:02.18,0:07:05.64,Default,,0,0,0,,And why is that? Because that string is\Njust a list
Dialogue: 0,0:07:05.64,0:07:09.36,Default,,0,0,0,,of five characters, so this uses
Dialogue: 0,0:07:09.36,0:07:13.29,Default,,0,0,0,,the length function over list. We can take\Nthe first three
Dialogue: 0,0:07:13.29,0:07:18.78,Default,,0,0,0,,characters of a list by using\Ntake 3. We get abc.
Dialogue: 0,0:07:18.78,0:07:22.93,Default,,0,0,0,,And we can zip a list, sorry a String,
Dialogue: 0,0:07:22.93,0:07:27.05,Default,,0,0,0,,with a list in this way. For\Nexample if we zip
Dialogue: 0,0:07:27.05,0:07:30.89,Default,,0,0,0,,abc with 1234 we get the list of pairs
Dialogue: 0,0:07:30.89,0:07:34.24,Default,,0,0,0,,with the character a one, character b\Ntwo
Dialogue: 0,0:07:34.24,0:07:39.16,Default,,0,0,0,,character c with three. Many\Nother languages
Dialogue: 0,0:07:39.16,0:07:42.34,Default,,0,0,0,,also have Strings implement
Dialogue: 0,0:07:42.34,0:07:45.84,Default,,0,0,0,,Iterable or Enumerator so you can do
Dialogue: 0,0:07:45.84,0:07:49.18,Default,,0,0,0,,the same thing. But in Haskell really
Dialogue: 0,0:07:49.18,0:07:52.26,Default,,0,0,0,,there is no special type for list, it's
Dialogue: 0,0:07:52.26,0:07:56.65,Default,,0,0,0,,defined as a list of characters and the\Nonly thing is that
Dialogue: 0,0:07:56.65,0:08:00.24,Default,,0,0,0,,there's a special literal syntax just\Nlike
Dialogue: 0,0:08:00.24,0:08:04.52,Default,,0,0,0,,the syntax for lists really, as we have\Nseen, means one
Dialogue: 0,0:08:04.52,0:08:08.61,Default,,0,0,0,,cons two cons three cons four cons on the\Nempty list.
Dialogue: 0,0:08:08.61,0:08:12.75,Default,,0,0,0,,Here's an example
Dialogue: 0,0:08:12.75,0:08:16.49,Default,,0,0,0,,where we can count
Dialogue: 0,0:08:16.49,0:08:20.92,Default,,0,0,0,,the number of lower case characters
Dialogue: 0,0:08:20.92,0:08:24.39,Default,,0,0,0,,in a string. What we do is we say:
Dialogue: 0,0:08:24.39,0:08:28.32,Default,,0,0,0,,give me all the characters x in a\Nstring xs,
Dialogue: 0,0:08:28.32,0:08:31.43,Default,,0,0,0,,filter out all the ones that are lower\Ncase
Dialogue: 0,0:08:31.43,0:08:34.68,Default,,0,0,0,,and then compute the length.
Dialogue: 0,0:08:34.68,0:08:39.11,Default,,0,0,0,,For example if we count the number\Nof lower case characters
Dialogue: 0,0:08:39.11,0:08:42.50,Default,,0,0,0,,in the string Haskell we see that there\Nare six.
Dialogue: 0,0:08:42.50,0:08:46.11,Default,,0,0,0,,Two four six, and then
Dialogue: 0,0:08:46.11,0:08:49.68,Default,,0,0,0,,the first character is an uppercase\Nsymbol
Dialogue: 0,0:08:49.68,0:08:52.30,Default,,0,0,0,,Alright, hopefully
Dialogue: 0,0:08:52.30,0:08:55.89,Default,,0,0,0,,you've got a little bit of a feeling of
Dialogue: 0,0:08:55.89,0:08:59.16,Default,,0,0,0,,list comprehensions, zip
Dialogue: 0,0:08:59.16,0:09:02.23,Default,,0,0,0,,and the fact that strings are lists
Dialogue: 0,0:09:02.23,0:09:05.69,Default,,0,0,0,,and in the exercises there will be plenty\Nof opportunity
Dialogue: 0,0:09:05.69,0:09:09.65,Default,,0,0,0,,to practice with that. See you next week.
Dialogue: 0,0:09:09.65,0:09:10.96,Default,,0,0,0,,Bye bye. Happy hacking.
