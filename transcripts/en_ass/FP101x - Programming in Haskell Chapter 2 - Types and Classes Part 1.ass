[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: None

[Aegisub Project Garbage]

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,Arial,20,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,2,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:01.81,0:00:03.39,Default,,0,0,0,,Welcome back everybody to
Dialogue: 0,0:00:03.39,0:00:06.62,Default,,0,0,0,,FP 101: Functional programming
Dialogue: 0,0:00:06.62,0:00:10.42,Default,,0,0,0,,and today we're going to talk about\Ntypes and classes.
Dialogue: 0,0:00:10.42,0:00:15.05,Default,,0,0,0,,As developers we often work
Dialogue: 0,0:00:15.05,0:00:20.43,Default,,0,0,0,,all-nighters. We sit and hack, we get into\Na flow and we
Dialogue: 0,0:00:20.43,0:00:24.18,Default,,0,0,0,,lose track of time and so for developers
Dialogue: 0,0:00:24.18,0:00:27.99,Default,,0,0,0,,it's extremely important to watch our diet
Dialogue: 0,0:00:27.99,0:00:31.58,Default,,0,0,0,,to make sure that we eat well.
Dialogue: 0,0:00:31.58,0:00:34.95,Default,,0,0,0,,If you see the food pyramid here that
Dialogue: 0,0:00:34.95,0:00:38.23,Default,,0,0,0,,is shown in there, food
Dialogue: 0,0:00:38.23,0:00:44.29,Default,,0,0,0,,is grouped into categories. For example\Nyou see bread, rice and pasta
Dialogue: 0,0:00:44.29,0:00:48.19,Default,,0,0,0,,which are carbohydrates and then you see
Dialogue: 0,0:00:48.19,0:00:53.32,Default,,0,0,0,,other things like proteins, fruits\Nand vegetables
Dialogue: 0,0:00:53.32,0:00:56.78,Default,,0,0,0,,etcetera. So all food
Dialogue: 0,0:00:56.78,0:01:00.34,Default,,0,0,0,,is put into groups
Dialogue: 0,0:01:00.34,0:01:04.72,Default,,0,0,0,,that have a common property and in some\Nsense
Dialogue: 0,0:01:04.72,0:01:07.82,Default,,0,0,0,,these groups what we can say is that
Dialogue: 0,0:01:07.82,0:01:11.76,Default,,0,0,0,,the food here is typed
Dialogue: 0,0:01:11.76,0:01:15.78,Default,,0,0,0,,and that's what this lecture will be\Nabout: the lecture will be about
Dialogue: 0,0:01:15.78,0:01:19.53,Default,,0,0,0,,taking values (not food) but the values\Nthat we code with
Dialogue: 0,0:01:19.53,0:01:23.39,Default,,0,0,0,,and how to group these into categories
Dialogue: 0,0:01:23.39,0:01:27.86,Default,,0,0,0,,that have similar properties. So what is\Na type?
Dialogue: 0,0:01:27.86,0:01:31.56,Default,,0,0,0,,Well, a type is simply a name
Dialogue: 0,0:01:31.56,0:01:35.86,Default,,0,0,0,,for a collection of related values
Dialogue: 0,0:01:35.86,0:01:39.14,Default,,0,0,0,,just like a food group
Dialogue: 0,0:01:39.14,0:01:42.92,Default,,0,0,0,,is a name for a collection of
Dialogue: 0,0:01:42.92,0:01:46.00,Default,,0,0,0,,foods with related properties
Dialogue: 0,0:01:46.00,0:01:50.43,Default,,0,0,0,,and a type is a name for a collection of\Nvalues that we code with
Dialogue: 0,0:01:50.43,0:01:55.64,Default,,0,0,0,,that have similar properties. For example,\Nin Haskell the type Bool
Dialogue: 0,0:01:55.64,0:01:59.25,Default,,0,0,0,,is a name for a collection
Dialogue: 0,0:01:59.25,0:02:04.09,Default,,0,0,0,,that has two values: False and True. If we\Nwould be
Dialogue: 0,0:02:04.09,0:02:08.31,Default,,0,0,0,,really really pedantic in Haskell\Nthere would be a third
Dialogue: 0,0:02:08.31,0:02:11.45,Default,,0,0,0,,value Bottom and represents
Dialogue: 0,0:02:11.45,0:02:11.90,Default,,0,0,0,,
Dialogue: 0,0:02:11.90,0:02:15.73,Default,,0,0,0,,non terminating computation of type Bool
Dialogue: 0,0:02:15.73,0:02:19.70,Default,,0,0,0,,but in this course as since we're going\Nto stick to the basics
Dialogue: 0,0:02:19.70,0:02:23.65,Default,,0,0,0,,we will ignore the more complicated\Nfeatures
Dialogue: 0,0:02:23.65,0:02:27.70,Default,,0,0,0,,like Bottom, so and for now
Dialogue: 0,0:02:27.70,0:02:30.95,Default,,0,0,0,,we'll just say Bool is a type
Dialogue: 0,0:02:30.95,0:02:34.76,Default,,0,0,0,,that names the set of values
Dialogue: 0,0:02:34.76,0:02:40.34,Default,,0,0,0,,True and False, the boolean\Nvalues.
Dialogue: 0,0:02:40.34,0:02:46.22,Default,,0,0,0,,A type error is something where we are\Nusing a function
Dialogue: 0,0:02:46.22,0:02:49.23,Default,,0,0,0,,with a type that
Dialogue: 0,0:02:49.23,0:02:54.09,Default,,0,0,0,,the function does not expect. Let's look\Nat the example here:
Dialogue: 0,0:02:54.09,0:02:58.75,Default,,0,0,0,,if we want to add 1 to False obviously
Dialogue: 0,0:02:58.75,0:03:02.00,Default,,0,0,0,,that's not going to work, because on the\Nleft
Dialogue: 0,0:03:02.00,0:03:05.62,Default,,0,0,0,,we have a number and on the right we\Nhave a boolean
Dialogue: 0,0:03:05.62,0:03:09.29,Default,,0,0,0,,and there's no way to add a number
Dialogue: 0,0:03:09.29,0:03:12.90,Default,,0,0,0,,to a boolean.
Dialogue: 0,0:03:12.90,0:03:17.00,Default,,0,0,0,,To go back to the example of diet
Dialogue: 0,0:03:17.00,0:03:20.04,Default,,0,0,0,,if you have a certain diet maybe
Dialogue: 0,0:03:20.04,0:03:23.26,Default,,0,0,0,,you're not allowed to mix meat
Dialogue: 0,0:03:23.26,0:03:26.47,Default,,0,0,0,,and dairy products, so that would be a\Ntype error
Dialogue: 0,0:03:26.47,0:03:29.73,Default,,0,0,0,,in the food world. In the\Nprogramming world
Dialogue: 0,0:03:29.73,0:03:33.26,Default,,0,0,0,,we have the same kind of type errors.
Dialogue: 0,0:03:33.26,0:03:38.79,Default,,0,0,0,,The goal of static typing is that the\Ncompiler will catch these type errors
Dialogue: 0,0:03:38.79,0:03:41.95,Default,,0,0,0,,early on, before we run the program
Dialogue: 0,0:03:41.95,0:03:45.57,Default,,0,0,0,,but there's also dynamically typed\Nlanguages where these type
Dialogue: 0,0:03:45.57,0:03:50.69,Default,,0,0,0,,errors are caught at runtime, so when\Nyou're actually trying to
Dialogue: 0,0:03:50.69,0:03:53.70,Default,,0,0,0,,add up the boolean
Dialogue: 0,0:03:53.70,0:03:56.85,Default,,0,0,0,,with the number and then there's
Dialogue: 0,0:03:56.85,0:04:00.69,Default,,0,0,0,,non typed languages where this will just\Ntake
Dialogue: 0,0:04:00.69,0:04:03.90,Default,,0,0,0,,however these two values are\Nrepresented
Dialogue: 0,0:04:03.90,0:04:10.41,Default,,0,0,0,,and it will try to add them up. The notation,\Nthe syntax,
Dialogue: 0,0:04:10.41,0:04:14.15,Default,,0,0,0,,for writing down types in Haskell is
Dialogue: 0,0:04:14.15,0:04:18.07,Default,,0,0,0,,expression double colon type so if
Dialogue: 0,0:04:18.07,0:04:22.03,Default,,0,0,0,,evaluating the expression e will produce
Dialogue: 0,0:04:22.03,0:04:25.15,Default,,0,0,0,,a value of type t we write this
Dialogue: 0,0:04:25.15,0:04:29.69,Default,,0,0,0,,as e double colon t. Other languages
Dialogue: 0,0:04:29.69,0:04:33.93,Default,,0,0,0,,have different syntax, for example in Visual\NBasic you will write
Dialogue: 0,0:04:33.93,0:04:37.18,Default,,0,0,0,,e as t and in Java
Dialogue: 0,0:04:37.18,0:04:40.31,Default,,0,0,0,,you would write t e
Dialogue: 0,0:04:40.31,0:04:44.62,Default,,0,0,0,,but that's all syntax. The real\Nthing is that we're
Dialogue: 0,0:04:44.62,0:04:47.84,Default,,0,0,0,,interested in the semantics of this\Nwhich says that
Dialogue: 0,0:04:47.84,0:04:51.09,Default,,0,0,0,,the type of expression e is t.
Dialogue: 0,0:04:51.09,0:04:55.36,Default,,0,0,0,,Now every well-formed expression, every
Dialogue: 0,0:04:55.36,0:04:59.29,Default,,0,0,0,,syntactically well-formed expression\Nhas a type
Dialogue: 0,0:04:59.29,0:05:02.33,Default,,0,0,0,,and that type is calculated
Dialogue: 0,0:05:02.33,0:05:06.26,Default,,0,0,0,,by the compiler at compile-time
Dialogue: 0,0:05:06.26,0:05:09.58,Default,,0,0,0,,using a process called type inference.
Dialogue: 0,0:05:09.58,0:05:13.13,Default,,0,0,0,,Remember from the first lecture that
Dialogue: 0,0:05:13.13,0:05:17.45,Default,,0,0,0,,ML, the programming language ML\Nwas one of the first programming languages
Dialogue: 0,0:05:17.45,0:05:18.18,Default,,0,0,0,,
Dialogue: 0,0:05:18.18,0:05:23.61,Default,,0,0,0,,that had type inference. Type errors
Dialogue: 0,0:05:23.61,0:05:27.52,Default,,0,0,0,,are also in Haskell found at\Ncompile-time and
Dialogue: 0,0:05:27.52,0:05:31.19,Default,,0,0,0,,in most programming languages are found\Nat compile-time and
Dialogue: 0,0:05:31.19,0:05:34.39,Default,,0,0,0,,
Dialogue: 0,0:05:34.39,0:05:39.24,Default,,0,0,0,,the opinions differ about whether\Nyou have to have static typing
Dialogue: 0,0:05:39.24,0:05:42.33,Default,,0,0,0,,or dynamic typing or optional typing
Dialogue: 0,0:05:42.33,0:05:46.17,Default,,0,0,0,,but for me, personally, I like it.
Dialogue: 0,0:05:46.17,0:05:50.00,Default,,0,0,0,,I'm lazy so I like it if the compiler\Ncatches the
Dialogue: 0,0:05:50.00,0:05:55.25,Default,,0,0,0,,type errors for me early. In the previous\Nlecture we have played
Dialogue: 0,0:05:55.25,0:06:00.43,Default,,0,0,0,,around with GHC and GHC has a special command\Ncolon type
Dialogue: 0,0:06:00.43,0:06:04.72,Default,,0,0,0,,that allows you to ask the type of\Nan expression so you can
Dialogue: 0,0:06:04.72,0:06:09.53,Default,,0,0,0,,ask GHC to calculate the type of an\Nexpression for you.
Dialogue: 0,0:06:09.53,0:06:15.25,Default,,0,0,0,,For example, if we type in not False\NGHC will calculate the value of that
Dialogue: 0,0:06:15.25,0:06:17.31,Default,,0,0,0,,not False equals True
Dialogue: 0,0:06:17.31,0:06:20.97,Default,,0,0,0,,but we can also ask for that type of not\NFalse
Dialogue: 0,0:06:20.97,0:06:25.10,Default,,0,0,0,,and in which case it will not evaluate\Nthat expression
Dialogue: 0,0:06:25.10,0:06:29.72,Default,,0,0,0,,but it will just calculate its type\NThe type of not False
Dialogue: 0,0:06:29.72,0:06:31.09,Default,,0,0,0,,is Bool.
Dialogue: 0,0:06:31.09,0:06:34.48,Default,,0,0,0,,Now we see that the value of not\NFalse is True,
Dialogue: 0,0:06:34.48,0:06:37.69,Default,,0,0,0,,the type is Bool, so that's consistent.
Dialogue: 0,0:06:37.69,0:06:41.26,Default,,0,0,0,,GHC did a good job! It would be weird
Dialogue: 0,0:06:41.26,0:06:45.86,Default,,0,0,0,,and wrong if the type of not False would\Nbe Integer,
Dialogue: 0,0:06:45.86,0:06:50.38,Default,,0,0,0,,but the value would be True. That is\Ncalled type soundness
Dialogue: 0,0:06:50.38,0:06:54.56,Default,,0,0,0,,which means that the type that the\Ncompiler calculates
Dialogue: 0,0:06:54.56,0:06:58.85,Default,,0,0,0,,corresponds with the value that this\Nexpression has
Dialogue: 0,0:06:58.85,0:07:03.85,Default,,0,0,0,,when you execute it at runtime. In Haskell
Dialogue: 0,0:07:03.85,0:07:07.96,Default,,0,0,0,,and most programming languages there are\Na number of base types.
Dialogue: 0,0:07:07.96,0:07:11.01,Default,,0,0,0,,These are types that are built into\Nthe language
Dialogue: 0,0:07:11.01,0:07:14.21,Default,,0,0,0,,and in Haskell there's a handful:
Dialogue: 0,0:07:14.21,0:07:17.34,Default,,0,0,0,,we have already seen Bool, the type
Dialogue: 0,0:07:17.34,0:07:23.33,Default,,0,0,0,,of a boolean value, True and False. Then\Nthere's the type of character.
Dialogue: 0,0:07:23.33,0:07:28.48,Default,,0,0,0,,Char is the name of a set of values that\Ndenote characters.
Dialogue: 0,0:07:28.48,0:07:32.84,Default,,0,0,0,,Char contains characters like\Na b c
Dialogue: 0,0:07:32.84,0:07:38.04,Default,,0,0,0,,etcetera, all Unicode characters.\NThen there's the type of String
Dialogue: 0,0:07:38.04,0:07:42.19,Default,,0,0,0,,which are strings of characters and we\Nwill see later that in Haskell
Dialogue: 0,0:07:42.19,0:07:45.81,Default,,0,0,0,,strings are really nothing more than\Nlists of characters.
Dialogue: 0,0:07:45.81,0:07:51.17,Default,,0,0,0,,String, you could say is not\Nreally a base type
Dialogue: 0,0:07:51.17,0:07:55.69,Default,,0,0,0,,because it's defined in terms of two\Nother base types: strings and characters.
Dialogue: 0,0:07:55.69,0:07:59.26,Default,,0,0,0,,Haskell is unique
Dialogue: 0,0:07:59.26,0:08:03.65,Default,,0,0,0,,or unique, Python has\Nsimilar properties
Dialogue: 0,0:08:03.65,0:08:07.13,Default,,0,0,0,,in that it has both Int and Integers.
Dialogue: 0,0:08:07.13,0:08:12.99,Default,,0,0,0,,Ints are fixed precision integers:\N32-bit or 64-bit integers
Dialogue: 0,0:08:12.99,0:08:16.53,Default,,0,0,0,,and then Integer are arbitrary precision
Dialogue: 0,0:08:16.53,0:08:21.28,Default,,0,0,0,,integers. You can compute the factorial\Nof 500.
Dialogue: 0,0:08:21.28,0:08:25.79,Default,,0,0,0,,If you use type Integer that will\Ntake a long time
Dialogue: 0,0:08:25.79,0:08:29.08,Default,,0,0,0,,but it will not overflow like
Dialogue: 0,0:08:29.08,0:08:32.44,Default,,0,0,0,,when you use Int. Then of course\Nthere's Float,
Dialogue: 0,0:08:32.44,0:08:36.39,Default,,0,0,0,,the floating point numbers.
Dialogue: 0,0:08:36.39,0:08:39.74,Default,,0,0,0,,I mentioned when we talked about\Ncharacters I mentioned
Dialogue: 0,0:08:39.74,0:08:44.87,Default,,0,0,0,,that Strings really are lists of\Ncharacters and the type of lists
Dialogue: 0,0:08:44.87,0:08:49.92,Default,,0,0,0,,is the first generic type or polymorphic\Ntype
Dialogue: 0,0:08:49.92,0:08:52.99,Default,,0,0,0,,that we will see in Haskell.
Dialogue: 0,0:08:52.99,0:08:58.18,Default,,0,0,0,,A List is a sequence of values where\Nall the elements have the same type.
Dialogue: 0,0:08:58.18,0:09:01.95,Default,,0,0,0,,The first example here
Dialogue: 0,0:09:01.95,0:09:05.49,Default,,0,0,0,,is a list of three booleans: False True\Nand False.
Dialogue: 0,0:09:05.49,0:09:10.99,Default,,0,0,0,,You see here that we denote to type\Nwith colon colon and then the type
Dialogue: 0,0:09:10.99,0:09:16.26,Default,,0,0,0,,is list of Bool. One of the nice\Nfeatures of Haskell
Dialogue: 0,0:09:16.26,0:09:19.81,Default,,0,0,0,,that the syntax of types, you see here\Nthe syntax
Dialogue: 0,0:09:19.81,0:09:23.00,Default,,0,0,0,,of types, sorry the syntax of values here
Dialogue: 0,0:09:23.00,0:09:27.89,Default,,0,0,0,,on the left, looks very similar to the\Nsyntax of types on the right.
Dialogue: 0,0:09:27.89,0:09:31.45,Default,,0,0,0,,We use the same square brackets to
Dialogue: 0,0:09:31.45,0:09:35.70,Default,,0,0,0,,indicate a list of values and we\Nused the same
Dialogue: 0,0:09:35.70,0:09:38.75,Default,,0,0,0,,square brackets to indicate the type so
Dialogue: 0,0:09:38.75,0:09:42.36,Default,,0,0,0,,False True False has type Bool
Dialogue: 0,0:09:42.36,0:09:46.24,Default,,0,0,0,,The second example there has a type, has a\Nlist
Dialogue: 0,0:09:46.24,0:09:50.98,Default,,0,0,0,,of characters a b c d and its type is a\Nlist of character
Dialogue: 0,0:09:50.98,0:09:55.76,Default,,0,0,0,,and that's just the same as String.\NIn general
Dialogue: 0,0:09:55.76,0:09:59.42,Default,,0,0,0,,the rule is that [t]
Dialogue: 0,0:09:59.42,0:10:02.70,Default,,0,0,0,,list of t denotes the type of lists
Dialogue: 0,0:10:02.70,0:10:07.36,Default,,0,0,0,,with elements of type t.
Dialogue: 0,0:10:07.36,0:10:12.04,Default,,0,0,0,,Note that the type of the list\Ndoesn't say anything about its length.
Dialogue: 0,0:10:12.04,0:10:16.62,Default,,0,0,0,,If we have the list False True it has type\Nlist of Bool
Dialogue: 0,0:10:16.62,0:10:20.69,Default,,0,0,0,,and if we have the value False\NTrue False
Dialogue: 0,0:10:20.69,0:10:23.98,Default,,0,0,0,,it also has type Bool
Dialogue: 0,0:10:23.98,0:10:27.42,Default,,0,0,0,,and also the types of these
Dialogue: 0,0:10:27.42,0:10:31.74,Default,,0,0,0,,elements can be arbitrary as long as they're\Nall the same.
Dialogue: 0,0:10:31.74,0:10:34.76,Default,,0,0,0,,The last example down here
Dialogue: 0,0:10:34.76,0:10:38.60,Default,,0,0,0,,has a slightly more complicated type:\NIt's a list
Dialogue: 0,0:10:38.60,0:10:42.24,Default,,0,0,0,,of lists of characters. That's what\Nyou see here:
Dialogue: 0,0:10:42.24,0:10:45.37,Default,,0,0,0,,list of list of characters and if you\Nlook at the value
Dialogue: 0,0:10:45.37,0:10:48.22,Default,,0,0,0,,you see that it contains two lists
Dialogue: 0,0:10:48.22,0:10:51.14,Default,,0,0,0,,of characters. The thing with the list is\Nthat
Dialogue: 0,0:10:51.14,0:10:54.94,Default,,0,0,0,,all the elements must have the same type\Nbut the length is
Dialogue: 0,0:10:54.94,0:10:58.57,Default,,0,0,0,,unrestricted. Compare and contrast that\Nwith tuples.
Dialogue: 0,0:10:58.57,0:11:02.27,Default,,0,0,0,,A tuple there
Dialogue: 0,0:11:02.27,0:11:07.61,Default,,0,0,0,,the type contains the length but the\Nvalues the types of values can be
Dialogue: 0,0:11:07.61,0:11:08.30,Default,,0,0,0,,different
Dialogue: 0,0:11:08.30,0:11:11.73,Default,,0,0,0,,so the first example here that's a
Dialogue: 0,0:11:11.73,0:11:15.45,Default,,0,0,0,,tuple of two booleans, True and False.
Dialogue: 0,0:11:15.45,0:11:18.50,Default,,0,0,0,,There you see that the type is Bool, Bool.
Dialogue: 0,0:11:18.50,0:11:22.69,Default,,0,0,0,,It's not the list, if it would be a list, the type\Nwould be list of Bool,
Dialogue: 0,0:11:22.69,0:11:25.97,Default,,0,0,0,,but in this case it's a tuple of\Ntwo booleans
Dialogue: 0,0:11:25.97,0:11:29.22,Default,,0,0,0,,True and False and the type is Bool, Bool.
Dialogue: 0,0:11:29.22,0:11:33.88,Default,,0,0,0,,Now the second example has type\NBool, Char, Bool
Dialogue: 0,0:11:33.88,0:11:38.54,Default,,0,0,0,,and what you see here is that it\Ncontains three values
Dialogue: 0,0:11:38.54,0:11:41.81,Default,,0,0,0,,one is a boolean, the second one
Dialogue: 0,0:11:41.81,0:11:45.00,Default,,0,0,0,,is a character and the third one is\Na boolean again
Dialogue: 0,0:11:45.00,0:11:48.63,Default,,0,0,0,,and that's reflected in the type.\NIn general
Dialogue: 0,0:11:48.63,0:11:52.60,Default,,0,0,0,,if we have a tuple of type t1 to\Ntn
Dialogue: 0,0:11:52.60,0:11:56.75,Default,,0,0,0,,that's the type of a tuple that has\Nn values
Dialogue: 0,0:11:56.75,0:12:00.60,Default,,0,0,0,,of each respective type t1 up to tn.
Dialogue: 0,0:12:00.60,0:12:04.81,Default,,0,0,0,,The type of a tuple
Dialogue: 0,0:12:04.81,0:12:08.30,Default,,0,0,0,,encodes its size so True False or
Dialogue: 0,0:12:08.30,0:12:14.12,Default,,0,0,0,,False True there has type Bool, Bool.\NYou see there the length
Dialogue: 0,0:12:14.12,0:12:17.19,Default,,0,0,0,,of this tuple is reflected in the type.
Dialogue: 0,0:12:17.19,0:12:21.50,Default,,0,0,0,,Second on there there's three booleans\Nso we see that the tuple has three
Dialogue: 0,0:12:21.50,0:12:25.97,Default,,0,0,0,,booleans and the type of the values
Dialogue: 0,0:12:25.97,0:12:30.11,Default,,0,0,0,,is unrestricted, so they can be mixed\Nand matched. In this case we have a
Dialogue: 0,0:12:30.11,0:12:31.06,Default,,0,0,0,,tuple
Dialogue: 0,0:12:31.06,0:12:34.22,Default,,0,0,0,,that contains a character
Dialogue: 0,0:12:34.22,0:12:39.66,Default,,0,0,0,,and then as the second value a tuple\Nthat has a boolean and a character
Dialogue: 0,0:12:39.66,0:12:43.01,Default,,0,0,0,,and then the last example there is a tuple
Dialogue: 0,0:12:43.01,0:12:46.39,Default,,0,0,0,,that has a boolean and then a list of\Ncharacters
Dialogue: 0,0:12:46.39,0:12:51.32,Default,,0,0,0,,You see, there is a boolean here, a boolean\NTrue
Dialogue: 0,0:12:51.32,0:12:55.06,Default,,0,0,0,,and a list of 'a', 'b' and we see that the type\Nthere
Dialogue: 0,0:12:55.06,0:12:59.85,Default,,0,0,0,,is Bool and a list of Char.\NThis is the end of part one
Dialogue: 0,0:12:59.85,0:13:03.16,Default,,0,0,0,,about types and next we'll talk about
Dialogue: 0,0:13:03.16,0:13:06.68,Default,,0,0,0,,functions since we're dealing with the\Nfunctional language
Dialogue: 0,0:13:06.68,0:13:10.77,Default,,0,0,0,,functions are very important so we'll\Nspend
Dialogue: 0,0:13:10.77,0:13:14.27,Default,,0,0,0,,a little bit of time zooming into\Nfunctions. Thank you
Dialogue: 0,0:13:14.27,0:13:15.69,Default,,0,0,0,,and see after the break
