[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: None

[Aegisub Project Garbage]

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,Arial,20,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,2,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:01.02,0:00:03.06,Default,,0,0,0,,Welcome everybody
Dialogue: 0,0:00:03.06,0:00:07.35,Default,,0,0,0,,to the next lecture of functional\Nprogramming 101x.
Dialogue: 0,0:00:07.35,0:00:11.48,Default,,0,0,0,,Today we're going to talk about list\Ncomprehensions.
Dialogue: 0,0:00:11.48,0:00:14.66,Default,,0,0,0,,List comprehensions are
Dialogue: 0,0:00:14.66,0:00:19.27,Default,,0,0,0,,a mechanism to write code that\Nmanipulates collections.
Dialogue: 0,0:00:19.27,0:00:23.07,Default,,0,0,0,,If we look at most programming\Nlanguages,
Dialogue: 0,0:00:23.07,0:00:26.90,Default,,0,0,0,,most of the features in a programming\Nlanguage
Dialogue: 0,0:00:26.90,0:00:31.51,Default,,0,0,0,,have to do with dealing with collections.\NIf you look at
Dialogue: 0,0:00:31.51,0:00:37.02,Default,,0,0,0,,a traditional imperative language\Nsuch as Java or C#,
Dialogue: 0,0:00:37.02,0:00:41.75,Default,,0,0,0,,it has a wide range of mechanisms to\Ndeal with collections.
Dialogue: 0,0:00:41.75,0:00:45.16,Default,,0,0,0,,For loops, while loops, do while loops
Dialogue: 0,0:00:45.16,0:00:48.64,Default,,0,0,0,,foreach loops, continue, break
Dialogue: 0,0:00:48.64,0:00:52.48,Default,,0,0,0,,and all these constructs are there to
Dialogue: 0,0:00:52.48,0:00:56.28,Default,,0,0,0,,iterate over collections.
Dialogue: 0,0:00:56.28,0:01:01.32,Default,,0,0,0,,Now of course mathematicians have been\Ndealing with collections
Dialogue: 0,0:01:01.32,0:01:04.54,Default,,0,0,0,,for centuries.
Dialogue: 0,0:01:04.54,0:01:07.65,Default,,0,0,0,,For mathematicians the favorite
Dialogue: 0,0:01:07.65,0:01:11.50,Default,,0,0,0,,collection type is set.
Dialogue: 0,0:01:11.50,0:01:15.97,Default,,0,0,0,,Sets however are computationally a\Nlittle bit awkward.
Dialogue: 0,0:01:15.97,0:01:19.24,Default,,0,0,0,,Because when you have a set it\Nmeans that duplicated
Dialogue: 0,0:01:19.24,0:01:24.50,Default,,0,0,0,,elements are removed. Which implies that\Nyou need equality to deal with sets.
Dialogue: 0,0:01:24.50,0:01:27.52,Default,,0,0,0,,Especially in a functional language like\NHaskell
Dialogue: 0,0:01:27.52,0:01:32.00,Default,,0,0,0,,it's very hard, well impossible,\Nyou have to solve the halting problem
Dialogue: 0,0:01:32.00,0:01:35.43,Default,,0,0,0,,to decide equality between functions.
Dialogue: 0,0:01:35.43,0:01:38.46,Default,,0,0,0,,So what
Dialogue: 0,0:01:38.46,0:01:43.29,Default,,0,0,0,,Haskell did, it took some of the ideas\Nthat mathematicians have
Dialogue: 0,0:01:43.29,0:01:44.00,Default,,0,0,0,,used
Dialogue: 0,0:01:44.00,0:01:47.28,Default,,0,0,0,,for a long time to deal with sets and
Dialogue: 0,0:01:47.28,0:01:52.82,Default,,0,0,0,,simplified them to work over lists.\NLists are
Dialogue: 0,0:01:52.82,0:01:57.81,Default,,0,0,0,,my favorite collection type and the\Nreason is that a list
Dialogue: 0,0:01:57.81,0:02:01.61,Default,,0,0,0,,just gives you the bare minimum to\Ndeal with a collection.
Dialogue: 0,0:02:01.61,0:02:06.86,Default,,0,0,0,,You can, as you have seen, if we have a\Nlist that's composed out of a head and a
Dialogue: 0,0:02:06.86,0:02:07.45,Default,,0,0,0,,tail
Dialogue: 0,0:02:07.45,0:02:12.97,Default,,0,0,0,,you can decompose that list recursively\Nby just picking off the first element
Dialogue: 0,0:02:12.97,0:02:13.56,Default,,0,0,0,,one by one.
Dialogue: 0,0:02:13.56,0:02:17.03,Default,,0,0,0,,And that's very convenient and\Nthat puts
Dialogue: 0,0:02:17.03,0:02:20.13,Default,,0,0,0,,very few restrictions on the collection\Ntype.
Dialogue: 0,0:02:20.13,0:02:25.12,Default,,0,0,0,,Unless sets where you assume\Nequality of the elements or arrays where
Dialogue: 0,0:02:25.12,0:02:26.07,Default,,0,0,0,,you assume
Dialogue: 0,0:02:26.07,0:02:30.20,Default,,0,0,0,,constant time indexing. Sets
Dialogue: 0,0:02:30.20,0:02:34.01,Default,,0,0,0,,are in some sense the most pure form
Dialogue: 0,0:02:34.01,0:02:37.84,Default,,0,0,0,,of collection types. In Java eight,
Dialogue: 0,0:02:37.84,0:02:41.90,Default,,0,0,0,,they call these lists streams.
Dialogue: 0,0:02:41.90,0:02:44.91,Default,,0,0,0,,To emphasize that these are
Dialogue: 0,0:02:44.91,0:02:47.93,Default,,0,0,0,,collections where you can only\Naccess the elements
Dialogue: 0,0:02:47.93,0:02:51.07,Default,,0,0,0,,one by one. In that sense
Dialogue: 0,0:02:51.07,0:02:56.48,Default,,0,0,0,,Haskell lists are an example of Java\Neight streams in that philosophy.
Dialogue: 0,0:02:56.48,0:02:59.79,Default,,0,0,0,,Alright let's
Dialogue: 0,0:02:59.79,0:03:03.40,Default,,0,0,0,,look at how mathematicians use
Dialogue: 0,0:03:03.40,0:03:07.15,Default,,0,0,0,,so-called set comprehensions to define\Nsets.
Dialogue: 0,0:03:07.15,0:03:10.94,Default,,0,0,0,,Here's an example of a set.
Dialogue: 0,0:03:10.94,0:03:14.79,Default,,0,0,0,,It's a set of all squares
Dialogue: 0,0:03:14.79,0:03:18.15,Default,,0,0,0,,with values
Dialogue: 0,0:03:18.15,0:03:21.59,Default,,0,0,0,,between one and five. It's x\Nsquared
Dialogue: 0,0:03:21.59,0:03:25.29,Default,,0,0,0,,where x is taken from the set\Nfrom one to five.
Dialogue: 0,0:03:25.29,0:03:30.68,Default,,0,0,0,,The result of this is the set\N{1,4,9,16,25}.
Dialogue: 0,0:03:30.68,0:03:34.15,Default,,0,0,0,,But as I said, if we take
Dialogue: 0,0:03:34.15,0:03:39.40,Default,,0,0,0,,x to range over functions then this\Nbecomes really hard to implement.
Dialogue: 0,0:03:39.40,0:03:43.06,Default,,0,0,0,,So what people did
Dialogue: 0,0:03:43.06,0:03:46.94,Default,,0,0,0,,in functional languages is take the same\Nnotation the same ideas
Dialogue: 0,0:03:46.94,0:03:52.25,Default,,0,0,0,,but instead of sets, use lists.\NSet comprehensions from mathematics
Dialogue: 0,0:03:52.25,0:03:55.28,Default,,0,0,0,,become list comprehensions in Haskell.
Dialogue: 0,0:03:55.28,0:04:01.29,Default,,0,0,0,,Here's the same example written as a\Nlist comprehension. Here you see
Dialogue: 0,0:04:01.29,0:04:04.44,Default,,0,0,0,,it's the list of square numbers
Dialogue: 0,0:04:04.44,0:04:08.00,Default,,0,0,0,,x squared where x is taken from\Nthe list
Dialogue: 0,0:04:08.00,0:04:11.15,Default,,0,0,0,,one to five. You read this as x
Dialogue: 0,0:04:11.15,0:04:15.10,Default,,0,0,0,,is taken from the list one to five.
Dialogue: 0,0:04:15.10,0:04:18.50,Default,,0,0,0,,If you evaluate this you will see that
Dialogue: 0,0:04:18.50,0:04:22.46,Default,,0,0,0,,this returns the list [1,4,9,16,25].
Dialogue: 0,0:04:22.46,0:04:27.60,Default,,0,0,0,,But as a list not a set.
Dialogue: 0,0:04:27.60,0:04:28.52,Default,,0,0,0,,The expression
Dialogue: 0,0:04:28.52,0:04:32.30,Default,,0,0,0,,x taken from one to five, that's called a\Ngenerator
Dialogue: 0,0:04:32.30,0:04:36.12,Default,,0,0,0,,and the reason it's called a\Ngenerator is because it
Dialogue: 0,0:04:36.12,0:04:39.91,Default,,0,0,0,,defines how to generate values
Dialogue: 0,0:04:39.91,0:04:43.69,Default,,0,0,0,,for x. So x is taken from that set.
Dialogue: 0,0:04:43.69,0:04:47.33,Default,,0,0,0,,Of course since everything
Dialogue: 0,0:04:47.33,0:04:50.58,Default,,0,0,0,,in Haskell, and that's a good
Dialogue: 0,0:04:50.58,0:04:54.28,Default,,0,0,0,,aspect of programming languages, has to be\Ncompositional so you should be able to
Dialogue: 0,0:04:54.28,0:04:59.16,Default,,0,0,0,,just recursively use the same\Nstructures over and over again.
Dialogue: 0,0:04:59.16,0:05:03.38,Default,,0,0,0,,Comprehensions can have multiple\Ngenerators.
Dialogue: 0,0:05:03.38,0:05:06.60,Default,,0,0,0,,Here you see an example of that:
Dialogue: 0,0:05:06.60,0:05:10.09,Default,,0,0,0,,we take all pairs (x, y)
Dialogue: 0,0:05:10.09,0:05:13.50,Default,,0,0,0,,Where x is drawn from one, two, three,\Nand y
Dialogue: 0,0:05:13.50,0:05:16.99,Default,,0,0,0,,is drawn from four, five. What you see
Dialogue: 0,0:05:16.99,0:05:20.16,Default,,0,0,0,,is that the y varies
Dialogue: 0,0:05:20.16,0:05:24.22,Default,,0,0,0,,faster then the x. The result list is
Dialogue: 0,0:05:24.22,0:05:27.47,Default,,0,0,0,,(1,4) (1,5)
Dialogue: 0,0:05:27.47,0:05:31.11,Default,,0,0,0,,(2,4) (2,5) (3,4) (3,5).
Dialogue: 0,0:05:31.11,0:05:34.46,Default,,0,0,0,,Another way to look at these nested
Dialogue: 0,0:05:34.46,0:05:38.13,Default,,0,0,0,,generators or multiple generators is\Nlike
Dialogue: 0,0:05:38.13,0:05:41.45,Default,,0,0,0,,a nested loop where y is inner loop
Dialogue: 0,0:05:41.45,0:05:48.45,Default,,0,0,0,,and the x is the outer loop.\NIf we swap the order of the
Dialogue: 0,0:05:48.47,0:05:49.34,Default,,0,0,0,,generator
Dialogue: 0,0:05:49.34,0:05:52.69,Default,,0,0,0,,then now x
Dialogue: 0,0:05:52.69,0:05:57.06,Default,,0,0,0,,varies most quickly because this becomes\Nthe inner loop. What we get now
Dialogue: 0,0:05:57.06,0:06:00.13,Default,,0,0,0,,is, but notice that we still
Dialogue: 0,0:06:00.13,0:06:03.86,Default,,0,0,0,,have here (x,y). We only swap\Nthe order
Dialogue: 0,0:06:03.86,0:06:07.19,Default,,0,0,0,,of the generators not the order of the\Nvariables.
Dialogue: 0,0:06:07.19,0:06:11.65,Default,,0,0,0,,Now instead of
Dialogue: 0,0:06:11.65,0:06:15.03,Default,,0,0,0,,this guy moving fastest, you get
Dialogue: 0,0:06:15.03,0:06:18.88,Default,,0,0,0,,x moving fastest. The result is (1,4)
Dialogue: 0,0:06:18.88,0:06:22.44,Default,,0,0,0,,(2,4) (3,4) et cetera
Dialogue: 0,0:06:22.44,0:06:25.78,Default,,0,0,0,,This notion of generators
Dialogue: 0,0:06:25.78,0:06:28.82,Default,,0,0,0,,you will recognize that
Dialogue: 0,0:06:28.82,0:06:32.55,Default,,0,0,0,,in many many programming languages.\NIn Haskell these are list comprehensions
Dialogue: 0,0:06:32.55,0:06:34.59,Default,,0,0,0,,if you use python
Dialogue: 0,0:06:34.59,0:06:38.08,Default,,0,0,0,,it also has list comprehensions.
Dialogue: 0,0:06:38.08,0:06:42.75,Default,,0,0,0,,Scala has for comprehensions. F#\Nhas comprehensions.
Dialogue: 0,0:06:42.75,0:06:46.39,Default,,0,0,0,,C# and Visual Basic
Dialogue: 0,0:06:46.39,0:06:49.55,Default,,0,0,0,,have LINQ comprehensions.
Dialogue: 0,0:06:49.55,0:06:53.50,Default,,0,0,0,,If you look at the language like\NSQL
Dialogue: 0,0:06:53.50,0:06:57.50,Default,,0,0,0,,which is completely built on top of\Ncomprehensions.
Dialogue: 0,0:06:57.50,0:07:01.95,Default,,0,0,0,,Only there you don't write them this concisely.\NYou write select from where
Dialogue: 0,0:07:01.95,0:07:06.27,Default,,0,0,0,,et cetera. But it's basically the same\Nidea so by studying
Dialogue: 0,0:07:06.27,0:07:10.55,Default,,0,0,0,,list comprehensions in Haskell you\Nwill be well equipped
Dialogue: 0,0:07:10.55,0:07:15.02,Default,,0,0,0,,to use the same ideas in whatever\Nlanguage you encounter them in.
Dialogue: 0,0:07:15.02,0:07:18.55,Default,,0,0,0,,Alright,
Dialogue: 0,0:07:18.55,0:07:21.61,Default,,0,0,0,,now
Dialogue: 0,0:07:21.61,0:07:25.90,Default,,0,0,0,,we have seen a few simple examples\Nwith generators
Dialogue: 0,0:07:25.90,0:07:29.50,Default,,0,0,0,,where the generators only had constants.
Dialogue: 0,0:07:29.50,0:07:33.01,Default,,0,0,0,,But generators can also depend on each\Nother.
Dialogue: 0,0:07:33.01,0:07:36.55,Default,,0,0,0,,Just like when you have a loop,\Nthe inner loop
Dialogue: 0,0:07:36.55,0:07:40.49,Default,,0,0,0,,can use variables from the outer loop.\NWith comprehensions
Dialogue: 0,0:07:40.49,0:07:44.36,Default,,0,0,0,,that's no different. If we look here
Dialogue: 0,0:07:44.36,0:07:47.68,Default,,0,0,0,,we say x is drawn from one to three.\NAnd then
Dialogue: 0,0:07:47.68,0:07:50.86,Default,,0,0,0,,y is drawn from x to three.
Dialogue: 0,0:07:50.86,0:07:54.78,Default,,0,0,0,,So x is in scope in the generators that
Dialogue: 0,0:07:54.78,0:07:59.71,Default,,0,0,0,,come after it. If we execute this\Ncomprehension
Dialogue: 0,0:07:59.71,0:08:04.00,Default,,0,0,0,,we get the list (1,1)
Dialogue: 0,0:08:04.00,0:08:07.21,Default,,0,0,0,,because y is drawn from one to three.
Dialogue: 0,0:08:07.21,0:08:12.30,Default,,0,0,0,,Because x starts out at one, so we\Nget (1,1) (1,2) (1,3).
Dialogue: 0,0:08:12.30,0:08:16.32,Default,,0,0,0,,Then y is exhausted.
Dialogue: 0,0:08:16.32,0:08:20.41,Default,,0,0,0,,We're going to check the next value\Nof x, that will be two.
Dialogue: 0,0:08:20.41,0:08:24.57,Default,,0,0,0,,Now y is taken from two to three so\Nwe say
Dialogue: 0,0:08:24.57,0:08:28.31,Default,,0,0,0,,two to three and then the last iteration
Dialogue: 0,0:08:28.31,0:08:32.61,Default,,0,0,0,,we take x to be three and then y is\Ndrawn from the list
Dialogue: 0,0:08:32.61,0:08:35.86,Default,,0,0,0,,three to three, so that is the last value is just
Dialogue: 0,0:08:35.86,0:08:39.36,Default,,0,0,0,,(3,3). But again you’re
Dialogue: 0,0:08:39.36,0:08:44.72,Default,,0,0,0,,totally familiar with this because this\Nis the same as how nested loops work
Dialogue: 0,0:08:44.72,0:08:48.31,Default,,0,0,0,,in any language. The inner loop\Ncan
Dialogue: 0,0:08:48.31,0:08:51.95,Default,,0,0,0,,use variables defined in outer loops.
Dialogue: 0,0:08:51.95,0:08:55.60,Default,,0,0,0,,One of the nice things
Dialogue: 0,0:08:55.60,0:08:59.87,Default,,0,0,0,,of comprehensions and especially of\Ndependent generators
Dialogue: 0,0:08:59.87,0:09:02.95,Default,,0,0,0,,is that you can write very concise code.
Dialogue: 0,0:09:02.95,0:09:07.04,Default,,0,0,0,,For example, if we want to take a list\Nof lists
Dialogue: 0,0:09:07.04,0:09:10.97,Default,,0,0,0,,and flatten them into a single list
Dialogue: 0,0:09:10.97,0:09:14.45,Default,,0,0,0,,we can do that with the following\Ncomprehension.
Dialogue: 0,0:09:14.45,0:09:19.19,Default,,0,0,0,,We say: just give me every list\Nout of that list of lists.
Dialogue: 0,0:09:19.19,0:09:22.64,Default,,0,0,0,,Then just give me every element of\Nthat list
Dialogue: 0,0:09:22.64,0:09:27.56,Default,,0,0,0,,and return that. This is a doubly\Nnested loop that goes over
Dialogue: 0,0:09:27.56,0:09:31.19,Default,,0,0,0,,every list in this list of lists\Nand just
Dialogue: 0,0:09:31.19,0:09:34.52,Default,,0,0,0,,yields all the values to return
Dialogue: 0,0:09:34.52,0:09:38.62,Default,,0,0,0,,a single list of type a, of the same\Nelement type
Dialogue: 0,0:09:38.62,0:09:42.01,Default,,0,0,0,,as the original list. When we
Dialogue: 0,0:09:42.01,0:09:46.43,Default,,0,0,0,,concatenate [1,2,3] [4,5] and [6]
Dialogue: 0,0:09:46.43,0:09:49.58,Default,,0,0,0,,the result will be [1,2,3,4,5,6].
Dialogue: 0,0:09:49.58,0:09:53.91,Default,,0,0,0,,Very very
Dialogue: 0,0:09:53.91,0:10:00.25,Default,,0,0,0,,concise code that we can write\Nusing comprehensions. Now the next thing
Dialogue: 0,0:10:00.25,0:10:04.54,Default,,0,0,0,,besides generators that you want to use\Nin a comprehension, and that's also
Dialogue: 0,0:10:04.54,0:10:09.18,Default,,0,0,0,,used a lot in set comprehensions is to\Nallow filters.
Dialogue: 0,0:10:09.18,0:10:12.35,Default,,0,0,0,,You want to
Dialogue: 0,0:10:12.35,0:10:16.01,Default,,0,0,0,,have x drawn from some collection
Dialogue: 0,0:10:16.01,0:10:19.08,Default,,0,0,0,,but you want to throw out certain values
Dialogue: 0,0:10:19.08,0:10:22.61,Default,,0,0,0,,for which a predicate does not hold.\NFor example, if we want to have
Dialogue: 0,0:10:22.61,0:10:26.05,Default,,0,0,0,,all the even numbers between one and ten
Dialogue: 0,0:10:26.05,0:10:30.33,Default,,0,0,0,,we can just say x is drawn from\None to ten
Dialogue: 0,0:10:30.33,0:10:34.39,Default,,0,0,0,,and filter out only the even numbers.\NThe result
Dialogue: 0,0:10:34.39,0:10:38.44,Default,,0,0,0,,of this is a list [2,4,6,8,10].
Dialogue: 0,0:10:38.44,0:10:41.87,Default,,0,0,0,,The even numbers between one and ten.
Dialogue: 0,0:10:41.87,0:10:46.17,Default,,0,0,0,,In SQL you will recognize\Nthis as a SELECT WHERE.
Dialogue: 0,0:10:46.17,0:10:50.22,Default,,0,0,0,,The WHERE clause here is called a\Nguard
Dialogue: 0,0:10:50.22,0:10:53.60,Default,,0,0,0,,in Haskell and if you use a LINQ
Dialogue: 0,0:10:53.60,0:10:58.30,Default,,0,0,0,,list comprehension or\Ncomprehension syntax that will be also
Dialogue: 0,0:10:58.30,0:10:59.14,Default,,0,0,0,,be called
Dialogue: 0,0:10:59.14,0:11:02.38,Default,,0,0,0,,WHERE.
Dialogue: 0,0:11:02.38,0:11:03.69,Default,,0,0,0,,Here's an
Dialogue: 0,0:11:03.69,0:11:07.92,Default,,0,0,0,,example that uses guards to take
Dialogue: 0,0:11:07.92,0:11:11.75,Default,,0,0,0,,a number and break it down into its\Nfactors.
Dialogue: 0,0:11:11.75,0:11:15.23,Default,,0,0,0,,What are the factors? Well we take a\Nnumber n,
Dialogue: 0,0:11:15.23,0:11:18.98,Default,,0,0,0,,we take all the numbers between 1 and\Nn.
Dialogue: 0,0:11:18.98,0:11:22.88,Default,,0,0,0,,And then we only
Dialogue: 0,0:11:22.88,0:11:26.36,Default,,0,0,0,,retain those for which n modulo x is zero.
Dialogue: 0,0:11:26.36,0:11:30.36,Default,,0,0,0,,The factors of 15; we start out\Nwith all the numbers between
Dialogue: 0,0:11:30.36,0:11:34.43,Default,,0,0,0,,1 and 15 and then we throw out all the\Nnumbers
Dialogue: 0,0:11:34.43,0:11:38.24,Default,,0,0,0,,for which n modulo x is not zero.
Dialogue: 0,0:11:38.24,0:11:42.42,Default,,0,0,0,,In this case the factors are [1,3,5,15].
Dialogue: 0,0:11:42.42,0:11:45.44,Default,,0,0,0,,Then we can use this
Dialogue: 0,0:11:45.44,0:11:49.33,Default,,0,0,0,,factors function
Dialogue: 0,0:11:49.33,0:11:52.74,Default,,0,0,0,,to define a very simple
Dialogue: 0,0:11:52.74,0:11:56.39,Default,,0,0,0,,predicate to check whether a number\Nis prime.
Dialogue: 0,0:11:56.39,0:12:02.23,Default,,0,0,0,,A number is prime if the factors of that\Nnumber are exactly the list [1,n].
Dialogue: 0,0:12:02.23,0:12:05.58,Default,,0,0,0,,For example, fifteen is not a prime
Dialogue: 0,0:12:05.58,0:12:09.51,Default,,0,0,0,,because the factors are not just one and\Nfifteen.
Dialogue: 0,0:12:09.51,0:12:12.56,Default,,0,0,0,,It's one three five and fifteen. But seven
Dialogue: 0,0:12:12.56,0:12:17.42,Default,,0,0,0,,is a prime because you can check by\Nusing GHCi, or your
Dialogue: 0,0:12:17.42,0:12:21.55,Default,,0,0,0,,own favorite programming language, that\Nthe factors of seven are one and seven.
Dialogue: 0,0:12:21.55,0:12:24.65,Default,,0,0,0,,So we decide that
Dialogue: 0,0:12:24.65,0:12:28.17,Default,,0,0,0,,seven is a prime.
Dialogue: 0,0:12:28.17,0:12:31.83,Default,,0,0,0,,If we want to check
Dialogue: 0,0:12:31.83,0:12:35.81,Default,,0,0,0,,what are the primes up to a\Ncertain number.
Dialogue: 0,0:12:35.81,0:12:39.49,Default,,0,0,0,,Well we can write this simple list\Ncomprehension where we say:
Dialogue: 0,0:12:39.49,0:12:43.58,Default,,0,0,0,,give me all the numbers between two and\Nn where n is the parameter to
Dialogue: 0,0:12:43.58,0:12:44.07,Default,,0,0,0,,this
Dialogue: 0,0:12:44.07,0:12:49.08,Default,,0,0,0,,function. Then I only want to\Nmaintain the prime numbers. I filter out
Dialogue: 0,0:12:49.08,0:12:51.57,Default,,0,0,0,,all the numbers that are not prime.\NIf I want to have
Dialogue: 0,0:12:51.57,0:12:55.52,Default,,0,0,0,,all the prime numbers up to 40
Dialogue: 0,0:12:55.52,0:12:59.60,Default,,0,0,0,,I just run this list comprehension
Dialogue: 0,0:12:59.60,0:13:04.29,Default,,0,0,0,,and I get all the prime numbers.\NOf course this is not the most efficient
Dialogue: 0,0:13:04.29,0:13:05.20,Default,,0,0,0,,way
Dialogue: 0,0:13:05.20,0:13:10.19,Default,,0,0,0,,to compute prime numbers but I think\Nit's a very nice illustration
Dialogue: 0,0:13:10.19,0:13:13.45,Default,,0,0,0,,of using list comprehensions. See you
Dialogue: 0,0:13:13.45,0:13:14.30,Default,,0,0,0,,in the next chapter.
