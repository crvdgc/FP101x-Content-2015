[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: None

[Aegisub Project Garbage]

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,Arial,20,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,2,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:00.95,0:00:03.24,Default,,0,0,0,,Hey! Welcome back everybody
Dialogue: 0,0:00:03.24,0:00:06.67,Default,,0,0,0,,to the next episode of FP101x.
Dialogue: 0,0:00:06.67,0:00:10.70,Default,,0,0,0,,And today we're going to talk about\Nrecursive functions.
Dialogue: 0,0:00:10.70,0:00:13.90,Default,,0,0,0,,What is recursion? Well, I have here
Dialogue: 0,0:00:13.90,0:00:20.13,Default,,0,0,0,,a stack of trays and my favorite fruit.\NBy now you all know that I love bananas.
Dialogue: 0,0:00:20.13,0:00:23.76,Default,,0,0,0,,And I need to eat this
Dialogue: 0,0:00:23.76,0:00:29.07,Default,,0,0,0,,whole bunch of bananas. And if we're\Ngoing to do this recursively, so I'm
Dialogue: 0,0:00:29.07,0:00:32.91,Default,,0,0,0,,going to eat the first banana and then...\Noh but
Dialogue: 0,0:00:32.91,0:00:36.50,Default,,0,0,0,,before I do that, I need to eat the next\Nbanana.
Dialogue: 0,0:00:36.50,0:00:39.95,Default,,0,0,0,,Oh, so I have to put this one
Dialogue: 0,0:00:39.95,0:00:43.44,Default,,0,0,0,,on top of this tray and then...\NOh, I have to eat
Dialogue: 0,0:00:43.44,0:00:49.39,Default,,0,0,0,,the next banana. My goodness, I'm eating a\Nlot of bananas. And look at that stack
Dialogue: 0,0:00:49.39,0:00:52.52,Default,,0,0,0,,growing there. Next banana
Dialogue: 0,0:00:52.52,0:00:56.71,Default,,0,0,0,,and finally I have my last banana
Dialogue: 0,0:00:56.71,0:01:01.35,Default,,0,0,0,,and I can put it on the stack. And look\Nit is a beautiful stack
Dialogue: 0,0:01:01.35,0:01:05.04,Default,,0,0,0,,of bananas. See if we can
Dialogue: 0,0:01:05.04,0:01:09.43,Default,,0,0,0,,see them. The problem is that what we\Nhave done here
Dialogue: 0,0:01:09.43,0:01:12.60,Default,,0,0,0,,is we have created a quite a large
Dialogue: 0,0:01:12.60,0:01:17.81,Default,,0,0,0,,stack of bananas. And if we would have a\Nbig bunch of bananas that stack
Dialogue: 0,0:01:17.81,0:01:20.90,Default,,0,0,0,,would overflow. So a better way
Dialogue: 0,0:01:20.90,0:01:24.24,Default,,0,0,0,,to eat the bananas is to not
Dialogue: 0,0:01:24.24,0:01:28.35,Default,,0,0,0,,start with the next banana until you've\Nfinished
Dialogue: 0,0:01:28.35,0:01:31.82,Default,,0,0,0,,the first one. And in that case
Dialogue: 0,0:01:31.82,0:01:34.86,Default,,0,0,0,,you only need one tray
Dialogue: 0,0:01:34.86,0:01:38.50,Default,,0,0,0,,to finish all your bananas.
Dialogue: 0,0:01:38.50,0:01:42.52,Default,,0,0,0,,And that is called tail call elimination.
Dialogue: 0,0:01:42.52,0:01:46.29,Default,,0,0,0,,And tail call elimination is
Dialogue: 0,0:01:46.29,0:01:50.52,Default,,0,0,0,,a very important concept when you're\Nusing recursion
Dialogue: 0,0:01:50.52,0:01:55.14,Default,,0,0,0,,to define control structures. And in\Nimperative languages
Dialogue: 0,0:01:55.14,0:01:58.57,Default,,0,0,0,,typically you don't have tail call\Nelimination
Dialogue: 0,0:01:58.57,0:02:03.07,Default,,0,0,0,,and therefore you have specialized\Ncontrol structures. But in Haskell
Dialogue: 0,0:02:03.07,0:02:06.10,Default,,0,0,0,,we can define
Dialogue: 0,0:02:06.10,0:02:08.32,Default,,0,0,0,,we can
Dialogue: 0,0:02:08.32,0:02:12.51,Default,,0,0,0,,safely define our control structures\Nusing recursive functions
Dialogue: 0,0:02:12.51,0:02:16.62,Default,,0,0,0,,because we will never have this giant\Nstack
Dialogue: 0,0:02:16.62,0:02:21.62,Default,,0,0,0,,of uneaten bananas. Great, let's look at\Nsome code.
Dialogue: 0,0:02:21.62,0:02:26.19,Default,,0,0,0,,I think I have had enough\Nbananas for the rest of the year.
Dialogue: 0,0:02:26.19,0:02:29.86,Default,,0,0,0,,The reason Haskell
Dialogue: 0,0:02:29.86,0:02:32.99,Default,,0,0,0,,folks love recursion is that it's
Dialogue: 0,0:02:32.99,0:02:36.61,Default,,0,0,0,,often a very natural way
Dialogue: 0,0:02:36.61,0:02:40.22,Default,,0,0,0,,to define functions. For example
Dialogue: 0,0:02:40.22,0:02:43.90,Default,,0,0,0,,here is a way to define
Dialogue: 0,0:02:43.90,0:02:48.29,Default,,0,0,0,,the factorial function.\NWe have seen this one before, so
Dialogue: 0,0:02:48.29,0:02:49.50,Default,,0,0,0,,we take the list
Dialogue: 0,0:02:49.50,0:02:52.63,Default,,0,0,0,,of values between 1 to n and then
Dialogue: 0,0:02:52.63,0:02:59.21,Default,,0,0,0,,we multiply them all together.\NIf we are going to evaluate
Dialogue: 0,0:02:59.21,0:03:03.62,Default,,0,0,0,,this factorial 4, we unfold\Nthe definition. That was
Dialogue: 0,0:03:03.62,0:03:10.62,Default,,0,0,0,,product 1 to 4. The list 1 to 4\Nis the product 1,2,3,4
Dialogue: 0,0:03:10.67,0:03:13.68,Default,,0,0,0,,and the product was
Dialogue: 0,0:03:13.68,0:03:16.83,Default,,0,0,0,,just multiplying all the numbers.
Dialogue: 0,0:03:16.83,0:03:20.08,Default,,0,0,0,,So there you see the product of 1,2,3,4
Dialogue: 0,0:03:20.08,0:03:23.26,Default,,0,0,0,,is 1 x 2 x 3 x 4
Dialogue: 0,0:03:23.26,0:03:26.30,Default,,0,0,0,,which is 24.
Dialogue: 0,0:03:26.30,0:03:30.41,Default,,0,0,0,,Here is a way to define
Dialogue: 0,0:03:30.41,0:03:33.52,Default,,0,0,0,,factorial using recursion. And we\Nhave seen
Dialogue: 0,0:03:33.52,0:03:37.80,Default,,0,0,0,,how to define recursive functions\Nover lists
Dialogue: 0,0:03:37.80,0:03:40.85,Default,,0,0,0,,by taking the list, checking whether\Nit is the
Dialogue: 0,0:03:40.85,0:03:45.02,Default,,0,0,0,,empty list or whether it is the head\Nfollowed by the tail.
Dialogue: 0,0:03:45.02,0:03:48.54,Default,,0,0,0,,And in some sense this kind of recursive\Nfunction
Dialogue: 0,0:03:48.54,0:03:51.88,Default,,0,0,0,,over numbers is nothing different.
Dialogue: 0,0:03:51.88,0:03:56.62,Default,,0,0,0,,So we have two cases. We have the fact\Nwhether the number is 0
Dialogue: 0,0:03:56.62,0:03:59.84,Default,,0,0,0,,or in this case whether the number is n
Dialogue: 0,0:03:59.84,0:04:03.36,Default,,0,0,0,,and in that case the recursion will be\Non n-1.
Dialogue: 0,0:04:03.36,0:04:07.49,Default,,0,0,0,,
Dialogue: 0,0:04:07.49,0:04:10.74,Default,,0,0,0,,In a previous version of Haskell there\Nwere so-called
Dialogue: 0,0:04:10.74,0:04:14.34,Default,,0,0,0,,n+k patterns, where you could\Nwrite the factorial of 0
Dialogue: 0,0:04:14.34,0:04:17.68,Default,,0,0,0,,and the factorial of n+1, but
Dialogue: 0,0:04:17.68,0:04:21.60,Default,,0,0,0,,n+k patterns have been\Ndeprecated, so now you
Dialogue: 0,0:04:21.60,0:04:25.18,Default,,0,0,0,,will have to write it in this form.
Dialogue: 0,0:04:25.18,0:04:30.22,Default,,0,0,0,,But apart from that minor detail, what you\Ncan see is that it is
Dialogue: 0,0:04:30.22,0:04:33.71,Default,,0,0,0,,very very similar to the way
Dialogue: 0,0:04:33.71,0:04:36.90,Default,,0,0,0,,you define recursion over lists.
Dialogue: 0,0:04:36.90,0:04:39.96,Default,,0,0,0,,There are two cases: 0
Dialogue: 0,0:04:39.96,0:04:43.94,Default,,0,0,0,,and n, and if it is 0 it's 1,\Nand otherwise
Dialogue: 0,0:04:43.94,0:04:47.53,Default,,0,0,0,,you just take the factorial of\N(n-1) times n.
Dialogue: 0,0:04:47.53,0:04:52.02,Default,,0,0,0,,And if we evaluate
Dialogue: 0,0:04:52.02,0:04:56.43,Default,,0,0,0,,this form of factorial, you will see\Nthat stack
Dialogue: 0,0:04:56.43,0:05:01.05,Default,,0,0,0,,of bananas appearing, because\Nyou see that
Dialogue: 0,0:05:01.05,0:05:04.75,Default,,0,0,0,,there's the factorial going to the\Nright
Dialogue: 0,0:05:04.75,0:05:08.03,Default,,0,0,0,,until we have executed everything
Dialogue: 0,0:05:08.03,0:05:12.27,Default,,0,0,0,,and then we multiply going back
Dialogue: 0,0:05:12.27,0:05:15.50,Default,,0,0,0,,popping off the stack, to get back to 6.
Dialogue: 0,0:05:15.50,0:05:18.81,Default,,0,0,0,,Alright.
Dialogue: 0,0:05:18.81,0:05:21.87,Default,,0,0,0,,The recursive definition
Dialogue: 0,0:05:21.87,0:05:25.06,Default,,0,0,0,,that we have given, of course will
Dialogue: 0,0:05:25.06,0:05:30.81,Default,,0,0,0,,not terminate, or a fancy way to say\Nthat, is it will diverge
Dialogue: 0,0:05:30.81,0:05:33.86,Default,,0,0,0,,for numbers less than 0.
Dialogue: 0,0:05:33.86,0:05:37.93,Default,,0,0,0,,If we look here. Let's go back
Dialogue: 0,0:05:37.93,0:05:42.11,Default,,0,0,0,,a few slides. If n
Dialogue: 0,0:05:42.11,0:05:45.53,Default,,0,0,0,,is less than 0, then
Dialogue: 0,0:05:45.53,0:05:51.03,Default,,0,0,0,,this case doesn't apply, so we\Nmultiply n with the factorial
Dialogue: 0,0:05:51.03,0:05:52.09,Default,,0,0,0,,of (n-1)
Dialogue: 0,0:05:52.09,0:05:56.22,Default,,0,0,0,,which is even more less than zero, and\Nso on, and so on. So this will never
Dialogue: 0,0:05:56.22,0:05:57.09,Default,,0,0,0,,terminate
Dialogue: 0,0:05:57.09,0:06:04.09,Default,,0,0,0,,and it will cause a stack overflow.
Dialogue: 0,0:06:05.11,0:06:09.06,Default,,0,0,0,,Some functions like factorial can be\Ndefined
Dialogue: 0,0:06:09.06,0:06:12.52,Default,,0,0,0,,either recursively or defined in terms
Dialogue: 0,0:06:12.52,0:06:15.74,Default,,0,0,0,,of other functions.
Dialogue: 0,0:06:15.74,0:06:19.37,Default,,0,0,0,,Whether you define something using\Nrecursion
Dialogue: 0,0:06:19.37,0:06:22.87,Default,,0,0,0,,or in terms of other functions, or you
Dialogue: 0,0:06:22.87,0:06:25.99,Default,,0,0,0,,take this recursion pattern
Dialogue: 0,0:06:25.99,0:06:28.71,Default,,0,0,0,,and abstract it as a higher-order\Nfunction and
Dialogue: 0,0:06:28.71,0:06:32.57,Default,,0,0,0,,then use it to define the function, that's\Nall a matter of taste.
Dialogue: 0,0:06:32.57,0:06:35.92,Default,,0,0,0,,In the end you decide as a developer
Dialogue: 0,0:06:35.92,0:06:38.96,Default,,0,0,0,,what is the most readable
Dialogue: 0,0:06:38.96,0:06:42.51,Default,,0,0,0,,for other developers. Alright?
Dialogue: 0,0:06:42.51,0:06:48.02,Default,,0,0,0,,So there is no strong answer when\Nor not to use recursion.
Dialogue: 0,0:06:48.02,0:06:51.07,Default,,0,0,0,,The code just has to be as clear as\Npossible.
Dialogue: 0,0:06:51.07,0:06:55.49,Default,,0,0,0,,But one advantage of recursion is that\Nyou can use
Dialogue: 0,0:06:55.49,0:06:58.99,Default,,0,0,0,,induction to prove properties
Dialogue: 0,0:06:58.99,0:07:03.13,Default,,0,0,0,,of your function. Let's
Dialogue: 0,0:07:03.13,0:07:06.89,Default,,0,0,0,,look at another example of defining a\Nrecursive function
Dialogue: 0,0:07:06.89,0:07:10.89,Default,,0,0,0,,where we are using this product\Nfunction, that we
Dialogue: 0,0:07:10.89,0:07:14.54,Default,,0,0,0,,used in the earlier definition
Dialogue: 0,0:07:14.54,0:07:17.80,Default,,0,0,0,,of factorial, and let's define that
Dialogue: 0,0:07:17.80,0:07:23.31,Default,,0,0,0,,using recursion over lists. So in this\Ncase the structure is exactly the same.
Dialogue: 0,0:07:23.31,0:07:23.64,Default,,0,0,0,,There are
Dialogue: 0,0:07:23.64,0:07:26.72,Default,,0,0,0,,two cases. We either have the empty list
Dialogue: 0,0:07:26.72,0:07:29.96,Default,,0,0,0,,or we have a list of n cons ns.
Dialogue: 0,0:07:29.96,0:07:34.36,Default,,0,0,0,,We look at the recursive structure\Nof lists
Dialogue: 0,0:07:34.36,0:07:39.18,Default,,0,0,0,,and then we define the function over\Nthat recursive structure.
Dialogue: 0,0:07:39.18,0:07:43.06,Default,,0,0,0,,And the same with numbers: we look at the\Nrecursive structure of numbers
Dialogue: 0,0:07:43.06,0:07:46.89,Default,,0,0,0,,and then we define the functions\Naccording to that structure.
Dialogue: 0,0:07:46.89,0:07:50.69,Default,,0,0,0,,In this case: if we have the product of\Nthe empty list
Dialogue: 0,0:07:50.69,0:07:54.86,Default,,0,0,0,,well, that is 1. If we want to
Dialogue: 0,0:07:54.86,0:07:59.29,Default,,0,0,0,,take the product of a value n on top of\Na list ns
Dialogue: 0,0:07:59.29,0:08:02.38,Default,,0,0,0,,what do we do? We take the product
Dialogue: 0,0:08:02.38,0:08:06.34,Default,,0,0,0,,of the rest of the list here and then we\Nmultiply that by n.
Dialogue: 0,0:08:06.34,0:08:09.91,Default,,0,0,0,,So this is a very easy way
Dialogue: 0,0:08:09.91,0:08:13.34,Default,,0,0,0,,to define this function using recursion.
Dialogue: 0,0:08:13.34,0:08:17.04,Default,,0,0,0,,And of course
Dialogue: 0,0:08:17.04,0:08:20.37,Default,,0,0,0,,as we will see, we can take this\Nfunction and
Dialogue: 0,0:08:20.37,0:08:24.78,Default,,0,0,0,,abstract the pattern into a higher-order\Nfunction, that just does the recursion
Dialogue: 0,0:08:24.78,0:08:26.20,Default,,0,0,0,,and then we can plug in
Dialogue: 0,0:08:26.20,0:08:31.08,Default,,0,0,0,,the times and the 1. But if we
Dialogue: 0,0:08:31.08,0:08:36.00,Default,,0,0,0,,execute this product, we unfold the\Ndefinition.
Dialogue: 0,0:08:36.00,0:08:39.08,Default,,0,0,0,,So it's like 2 cons 3,4.
Dialogue: 0,0:08:39.08,0:08:41.86,Default,,0,0,0,,If we unfold that a couple of times\Nyou get 2
Dialogue: 0,0:08:41.86,0:08:45.49,Default,,0,0,0,,times the product of 3,4. We do that a\Ncouple of times
Dialogue: 0,0:08:45.49,0:08:49.16,Default,,0,0,0,,until we arrive here. And then
Dialogue: 0,0:08:49.16,0:08:53.22,Default,,0,0,0,,we pop the stack to get 24. Alright?
Dialogue: 0,0:08:53.22,0:08:57.22,Default,,0,0,0,,So you see that the answer is exactly\Nthe same
Dialogue: 0,0:08:57.22,0:09:00.85,Default,,0,0,0,,as the recursive definition of\Nfactorial.
Dialogue: 0,0:09:00.85,0:09:05.07,Default,,0,0,0,,The only thing is that in this case the\Nrecursion
Dialogue: 0,0:09:05.07,0:09:09.17,Default,,0,0,0,,is hidden in this product function.\NSo if we take the product
Dialogue: 0,0:09:09.17,0:09:13.31,Default,,0,0,0,,of the numbers 1 to n, really we're\Ndefining
Dialogue: 0,0:09:13.31,0:09:17.32,Default,,0,0,0,,the function using recursion as well.\NAnd you can show that
Dialogue: 0,0:09:17.32,0:09:20.98,Default,,0,0,0,,when you fuse these two functions, the\Nfunction that creates a list from 1 to n
Dialogue: 0,0:09:20.98,0:09:21.41,Default,,0,0,0,,
Dialogue: 0,0:09:21.41,0:09:24.98,Default,,0,0,0,,and the product function, that what you\Nget is effectively
Dialogue: 0,0:09:24.98,0:09:30.17,Default,,0,0,0,,the recursive definition of factorial.
Dialogue: 0,0:09:30.17,0:09:34.36,Default,,0,0,0,,Let's look at another function, that we can\Ndefine
Dialogue: 0,0:09:34.36,0:09:37.68,Default,,0,0,0,,recursively over lists.
Dialogue: 0,0:09:37.68,0:09:41.01,Default,,0,0,0,,And here you see again: we have this
Dialogue: 0,0:09:41.01,0:09:45.05,Default,,0,0,0,,recursive structure, so if the\Nlist is empty
Dialogue: 0,0:09:45.05,0:09:49.36,Default,,0,0,0,,the length of that empty list is 0 and
Dialogue: 0,0:09:49.36,0:09:52.44,Default,,0,0,0,,if the list is not empty, we don't care really
Dialogue: 0,0:09:52.44,0:09:57.37,Default,,0,0,0,,what the first element is. We compute\Nthe length of the rest of the list
Dialogue: 0,0:09:57.37,0:10:01.74,Default,,0,0,0,,and just add 1 to it. Super obvious.
Dialogue: 0,0:10:01.74,0:10:05.31,Default,,0,0,0,,Again, it follows the recursive structure
Dialogue: 0,0:10:05.31,0:10:08.48,Default,,0,0,0,,of the list. So it is kind of defined by\Ninduction
Dialogue: 0,0:10:08.48,0:10:14.07,Default,,0,0,0,,on the structure of the list.\NSo length of 1,2,3
Dialogue: 0,0:10:14.07,0:10:18.48,Default,,0,0,0,,1 + length of 2,3, unfold, unfold,\Nunfold
Dialogue: 0,0:10:18.48,0:10:21.60,Default,,0,0,0,,until here and then we add them up
Dialogue: 0,0:10:21.60,0:10:27.61,Default,,0,0,0,,and we get the answer that we expect:\Nthree. Here is another function:
Dialogue: 0,0:10:27.61,0:10:30.80,Default,,0,0,0,,reverse. Empty list.
Dialogue: 0,0:10:30.80,0:10:33.87,Default,,0,0,0,,Reverse of the empty list is empty list.
Dialogue: 0,0:10:33.87,0:10:38.92,Default,,0,0,0,,And if we want to reverse x:xs
Dialogue: 0,0:10:38.92,0:10:42.19,Default,,0,0,0,,we just add x on the other side.
Dialogue: 0,0:10:42.19,0:10:45.89,Default,,0,0,0,,If we execute it like this, you see
Dialogue: 0,0:10:45.89,0:10:49.18,Default,,0,0,0,,that we are appending the elements
Dialogue: 0,0:10:49.18,0:10:53.38,Default,,0,0,0,,from right to left
Dialogue: 0,0:10:53.38,0:10:56.45,Default,,0,0,0,,and then the list gets reversed.
Dialogue: 0,0:10:56.45,0:10:59.63,Default,,0,0,0,,So 1,2,3 turns into 3,2,1.
Dialogue: 0,0:10:59.63,0:11:02.95,Default,,0,0,0,,Of course
Dialogue: 0,0:11:02.95,0:11:06.14,Default,,0,0,0,,we can also define recursive functions\Nthat
Dialogue: 0,0:11:06.14,0:11:09.99,Default,,0,0,0,,don't recurse over just one argument,\Nbut over several.
Dialogue: 0,0:11:09.99,0:11:13.05,Default,,0,0,0,,We have seen in the previous chapter the\Nfunction zip.
Dialogue: 0,0:11:13.05,0:11:16.98,Default,,0,0,0,,How do we define zip? Zip took two lists
Dialogue: 0,0:11:16.98,0:11:21.47,Default,,0,0,0,,and it would take every element of the\Ntwo lists and combine them into a pair.
Dialogue: 0,0:11:21.47,0:11:27.24,Default,,0,0,0,,The easiest thing here is to look at the\Nlast
Dialogue: 0,0:11:27.24,0:11:30.45,Default,,0,0,0,,clause here. If we have two non-empty\Nlists
Dialogue: 0,0:11:30.45,0:11:34.76,Default,,0,0,0,,we take the head of both, put that in a\Npair
Dialogue: 0,0:11:34.76,0:11:39.37,Default,,0,0,0,,and recursively zip the rest.\NWhen do we stop? Well, we stop
Dialogue: 0,0:11:39.37,0:11:43.07,Default,,0,0,0,,when either of the two lists is\Nexhausted
Dialogue: 0,0:11:43.07,0:11:46.08,Default,,0,0,0,,in which case we return the empty list.
Dialogue: 0,0:11:46.08,0:11:49.46,Default,,0,0,0,,And of course we have to put
Dialogue: 0,0:11:49.46,0:11:53.34,Default,,0,0,0,,these cases first here, because there is\Na wildcard
Dialogue: 0,0:11:53.34,0:11:57.36,Default,,0,0,0,,pattern here, that would otherwise not\Nwork.
Dialogue: 0,0:11:57.36,0:12:00.37,Default,,0,0,0,,Good!
Dialogue: 0,0:12:00.37,0:12:04.16,Default,,0,0,0,,A few more functions.
Dialogue: 0,0:12:04.16,0:12:07.85,Default,,0,0,0,,Drop takes an integer and a list
Dialogue: 0,0:12:07.85,0:12:13.16,Default,,0,0,0,,and returns a list. And what this thing\Nis doing, it's recursing over
Dialogue: 0,0:12:13.16,0:12:16.36,Default,,0,0,0,,both
Dialogue: 0,0:12:16.36,0:12:20.18,Default,,0,0,0,,the integer and the list. So in this case
Dialogue: 0,0:12:20.18,0:12:24.46,Default,,0,0,0,,when we say we want to drop zero\Nelements from a list
Dialogue: 0,0:12:24.46,0:12:29.32,Default,,0,0,0,,well, that's the same list. If we have\Nthe empty list
Dialogue: 0,0:12:29.32,0:12:32.37,Default,,0,0,0,,we can drop whatever we want, but\Nwe won't get
Dialogue: 0,0:12:32.37,0:12:36.25,Default,,0,0,0,,very far, so we just return the empty\Nlist. And otherwise
Dialogue: 0,0:12:36.25,0:12:40.20,Default,,0,0,0,,we recurse both over the list and over\Nthe number.
Dialogue: 0,0:12:40.20,0:12:45.07,Default,,0,0,0,,And again, since we don't have n+k\Npatterns, we have to use n-1 here
Dialogue: 0,0:12:45.07,0:12:47.29,Default,,0,0,0,,on the right hand side, so drop of n
Dialogue: 0,0:12:47.29,0:12:51.20,Default,,0,0,0,,and whatever cons xs is drop of
Dialogue: 0,0:12:51.20,0:12:55.04,Default,,0,0,0,,(n-1) and xs. So here we\Nrecurse
Dialogue: 0,0:12:55.04,0:12:58.60,Default,,0,0,0,,over the structure of the number and the\Nstructure
Dialogue: 0,0:12:58.60,0:13:00.86,Default,,0,0,0,,of the list.
Dialogue: 0,0:13:00.86,0:13:03.91,Default,,0,0,0,,The last example here on the slide
Dialogue: 0,0:13:03.91,0:13:07.04,Default,,0,0,0,,appends two lists. If I want to
Dialogue: 0,0:13:07.04,0:13:11.48,Default,,0,0,0,,append the empty list to another list,\Nthat is the other list.
Dialogue: 0,0:13:11.48,0:13:15.59,Default,,0,0,0,,And then, if I want to append a\Nlist x:xs
Dialogue: 0,0:13:15.59,0:13:19.99,Default,,0,0,0,,to a list ys, I first append xs to ys
Dialogue: 0,0:13:19.99,0:13:24.19,Default,,0,0,0,,and then cons x on top. Super\Nobvious.
Dialogue: 0,0:13:24.19,0:13:27.96,Default,,0,0,0,,Thank you so much and see you
Dialogue: 0,0:13:27.96,0:13:28.61,Default,,0,0,0,,in part 2.
