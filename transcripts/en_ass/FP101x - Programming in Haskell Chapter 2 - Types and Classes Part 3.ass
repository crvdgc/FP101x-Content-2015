[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: None

[Aegisub Project Garbage]

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,Arial,20,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,2,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:01.01,0:00:07.60,Default,,0,0,0,,Welcome back! I hope you had some fun with\Ncurrying and tuples and function types.
Dialogue: 0,0:00:07.60,0:00:10.74,Default,,0,0,0,,What we're going to talk about now is
Dialogue: 0,0:00:10.74,0:00:14.83,Default,,0,0,0,,type classes and polymorphic functions.
Dialogue: 0,0:00:14.83,0:00:18.18,Default,,0,0,0,,Polymorphic functions
Dialogue: 0,0:00:18.18,0:00:21.96,Default,,0,0,0,,are functions that are not defined
Dialogue: 0,0:00:21.96,0:00:26.26,Default,,0,0,0,,on concrete types but that are defined\Nusing type variables.
Dialogue: 0,0:00:26.26,0:00:33.18,Default,,0,0,0,,Here is a very polymorphic\Nexample of a polymorphic function:
Dialogue: 0,0:00:33.18,0:00:36.28,Default,,0,0,0,,the function length. If I want to\Ncalculate
Dialogue: 0,0:00:36.28,0:00:40.27,Default,,0,0,0,,the length of a list, it really doesn't\Nmatter at all
Dialogue: 0,0:00:40.27,0:00:43.70,Default,,0,0,0,,what the type of the elements of the\Nlist is.
Dialogue: 0,0:00:43.70,0:00:47.53,Default,,0,0,0,,If I have the list [1, 2, 3] or the list
Dialogue: 0,0:00:47.53,0:00:51.12,Default,,0,0,0,,with 3 characters ['a', 'b', 'c'],
Dialogue: 0,0:00:51.12,0:00:54.64,Default,,0,0,0,,in both cases the length of this\Nlist is three.
Dialogue: 0,0:00:54.64,0:00:58.62,Default,,0,0,0,,The type of the elements doesn't\Nmatter
Dialogue: 0,0:00:58.62,0:01:02.96,Default,,0,0,0,,when I want to calculate the length of\Na list. When we look at the type of
Dialogue: 0,0:01:02.96,0:01:03.94,Default,,0,0,0,,length here
Dialogue: 0,0:01:03.94,0:01:08.47,Default,,0,0,0,,we see it length has type
Dialogue: 0,0:01:08.47,0:01:13.04,Default,,0,0,0,,[a] -> Int and that a is a type variable
Dialogue: 0,0:01:13.04,0:01:16.22,Default,,0,0,0,,and in Haskell that is called ... you can see that
Dialogue: 0,0:01:16.22,0:01:19.40,Default,,0,0,0,,types start with an upper case
Dialogue: 0,0:01:19.40,0:01:24.15,Default,,0,0,0,,letter here: Int is\Na concrete type, because it starts with
Dialogue: 0,0:01:24.15,0:01:27.21,Default,,0,0,0,,an upper case I and the a here,
Dialogue: 0,0:01:27.21,0:01:30.68,Default,,0,0,0,,the lower case a that's a type variable.
Dialogue: 0,0:01:30.68,0:01:34.04,Default,,0,0,0,,Really what this type says is that
Dialogue: 0,0:01:34.04,0:01:37.06,Default,,0,0,0,,length has type for all types a
Dialogue: 0,0:01:37.06,0:01:40.60,Default,,0,0,0,,list a to Int.
Dialogue: 0,0:01:40.60,0:01:45.02,Default,,0,0,0,,If you're used to Java generics or\NC# generics
Dialogue: 0,0:01:45.02,0:01:49.04,Default,,0,0,0,,typically the
Dialogue: 0,0:01:49.04,0:01:52.75,Default,,0,0,0,,type variable is declared explicitly
Dialogue: 0,0:01:52.75,0:01:56.00,Default,,0,0,0,,in the type of the function.
Dialogue: 0,0:01:56.00,0:02:00.03,Default,,0,0,0,,For example in C# you would define\Nlength of t
Dialogue: 0,0:02:00.03,0:02:03.09,Default,,0,0,0,,and then it would have an argument\Nlist of t
Dialogue: 0,0:02:03.09,0:02:06.64,Default,,0,0,0,,and return an Int. But in Haskell this
Dialogue: 0,0:02:06.64,0:02:09.94,Default,,0,0,0,,a here is (since it's a type variable)
Dialogue: 0,0:02:09.94,0:02:13.52,Default,,0,0,0,,its implicitly quantified. You\Ndon't have to
Dialogue: 0,0:02:13.52,0:02:16.53,Default,,0,0,0,,put it in angle brackets or anything.
Dialogue: 0,0:02:16.53,0:02:20.86,Default,,0,0,0,,Haskell is optimized for this case
Dialogue: 0,0:02:20.86,0:02:25.07,Default,,0,0,0,,but the price that you pay is that type\Nvariables start with a
Dialogue: 0,0:02:25.07,0:02:28.14,Default,,0,0,0,,lower case and types start with an\Nupper case.
Dialogue: 0,0:02:28.14,0:02:31.93,Default,,0,0,0,,If we look at this type here, length
Dialogue: 0,0:02:31.93,0:02:37.63,Default,,0,0,0,,has type for any type a length takes a\Nlist of values of type a
Dialogue: 0,0:02:37.63,0:02:41.73,Default,,0,0,0,,and returns an integer. This is\Nwhat you expect
Dialogue: 0,0:02:41.73,0:02:45.57,Default,,0,0,0,,and it doesn't matter what the type of the
Dialogue: 0,0:02:45.57,0:02:48.67,Default,,0,0,0,,elements is of the list, your only\Ninterested
Dialogue: 0,0:02:48.67,0:02:51.87,Default,,0,0,0,,in counting how many there are.\NYou're not
Dialogue: 0,0:02:51.87,0:02:55.00,Default,,0,0,0,,interested what these values\Nactually are.
Dialogue: 0,0:02:55.00,0:03:00.10,Default,,0,0,0,,Let's look here: the length of\N[False True]
Dialogue: 0,0:03:00.10,0:03:03.38,Default,,0,0,0,,then in this case a has type Bool
Dialogue: 0,0:03:03.38,0:03:06.51,Default,,0,0,0,,is 2 and here we have a list of
Dialogue: 0,0:03:06.51,0:03:10.19,Default,,0,0,0,,integers, so a would be in that case Int
Dialogue: 0,0:03:10.19,0:03:14.24,Default,,0,0,0,,but the length here is 4.
Dialogue: 0,0:03:14.24,0:03:17.95,Default,,0,0,0,,In both cases we can use a length
Dialogue: 0,0:03:17.95,0:03:21.06,Default,,0,0,0,,of type for all a to Int
Dialogue: 0,0:03:21.06,0:03:24.66,Default,,0,0,0,,and in the first case a is Bool and in\Nthe second case
Dialogue: 0,0:03:24.66,0:03:27.81,Default,,0,0,0,,a is Int. As I said
Dialogue: 0,0:03:27.81,0:03:31.92,Default,,0,0,0,,the price we pay for not having to\Ndeclare
Dialogue: 0,0:03:31.92,0:03:36.01,Default,,0,0,0,,on what type length is\Npolymorphic
Dialogue: 0,0:03:36.01,0:03:39.17,Default,,0,0,0,,is that we differentiate the namespaces
Dialogue: 0,0:03:39.17,0:03:42.47,Default,,0,0,0,,of types and type variables and in Haskell
Dialogue: 0,0:03:42.47,0:03:46.73,Default,,0,0,0,,type variables must begin with a lower\Ncase letter.
Dialogue: 0,0:03:46.73,0:03:50.33,Default,,0,0,0,,By convention we use
Dialogue: 0,0:03:50.33,0:03:53.63,Default,,0,0,0,,a, b, c, etcetera for types variables,
Dialogue: 0,0:03:53.63,0:03:57.02,Default,,0,0,0,,whereas in languages like Java or C#
Dialogue: 0,0:03:57.02,0:04:00.12,Default,,0,0,0,,typically we use S and T and R
Dialogue: 0,0:04:00.12,0:04:03.95,Default,,0,0,0,,for type variables.
Dialogue: 0,0:04:03.95,0:04:07.56,Default,,0,0,0,,In Haskell its lower case a, b and c
Dialogue: 0,0:04:07.56,0:04:11.14,Default,,0,0,0,,where in C# you would write List<T>
Dialogue: 0,0:04:11.14,0:04:14.23,Default,,0,0,0,,in Haskell you would write [a].
Dialogue: 0,0:04:14.23,0:04:17.62,Default,,0,0,0,,Okay, here are
Dialogue: 0,0:04:17.62,0:04:22.41,Default,,0,0,0,,a number of polymorphic functions from\Nthe Haskell standard prelude.
Dialogue: 0,0:04:22.41,0:04:27.06,Default,,0,0,0,,The standard prelude is the Haskell SDK\Nor the Haskell BCL,
Dialogue: 0,0:04:27.06,0:04:31.18,Default,,0,0,0,,the standard library like every\Nlanguage comes with the standard library
Dialogue: 0,0:04:31.18,0:04:35.71,Default,,0,0,0,,and the types of these functions
Dialogue: 0,0:04:35.71,0:04:40.16,Default,,0,0,0,,reveal quite a lot about their\Nimplementation. For example let's
Dialogue: 0,0:04:40.16,0:04:41.18,Default,,0,0,0,,look at the first one:
Dialogue: 0,0:04:41.18,0:04:44.53,Default,,0,0,0,,first takes a tuple of
Dialogue: 0,0:04:44.53,0:04:48.28,Default,,0,0,0,,a and b and returns a value of type a.
Dialogue: 0,0:04:48.28,0:04:51.53,Default,,0,0,0,,What can this function do?
Dialogue: 0,0:04:51.53,0:04:56.78,Default,,0,0,0,,It takes a tuple and it\Nreturns a value of type a
Dialogue: 0,0:04:56.78,0:05:00.03,Default,,0,0,0,,so really it's quite obvious from that\Ntype
Dialogue: 0,0:05:00.03,0:05:04.50,Default,,0,0,0,,that what this function does is it\Nreturns the first
Dialogue: 0,0:05:04.50,0:05:10.38,Default,,0,0,0,,element of the tuple. Now let's look\Nat the type of head.
Dialogue: 0,0:05:10.38,0:05:13.77,Default,,0,0,0,,head takes a list of a for any type a
Dialogue: 0,0:05:13.77,0:05:17.18,Default,,0,0,0,,and returns an a. In this case
Dialogue: 0,0:05:17.18,0:05:21.06,Default,,0,0,0,,you have more choice:\Ngiven a list of type a
Dialogue: 0,0:05:21.06,0:05:24.77,Default,,0,0,0,,if I have to return a value of type a I\Ncan pick
Dialogue: 0,0:05:24.77,0:05:29.58,Default,,0,0,0,,any value in that list and head gives\Nyou the first one.
Dialogue: 0,0:05:29.58,0:05:34.25,Default,,0,0,0,,One of the interesting things here's\Nwhat happens
Dialogue: 0,0:05:34.25,0:05:37.94,Default,,0,0,0,,when you give head the empty\Nlist.
Dialogue: 0,0:05:37.94,0:05:41.46,Default,,0,0,0,,In that case this function will return
Dialogue: 0,0:05:41.46,0:05:44.69,Default,,0,0,0,,undefined or will throw an exception.
Dialogue: 0,0:05:44.69,0:05:48.02,Default,,0,0,0,,That is not given in this types:\Nthe types says that
Dialogue: 0,0:05:48.02,0:05:51.28,Default,,0,0,0,,for all lists of type a
Dialogue: 0,0:05:51.28,0:05:54.47,Default,,0,0,0,,it will return a value of type a
Dialogue: 0,0:05:54.47,0:05:58.66,Default,,0,0,0,,but that's not really true because when\NI give it the empty list
Dialogue: 0,0:05:58.66,0:06:02.63,Default,,0,0,0,,it will fail and not really give me
Dialogue: 0,0:06:02.63,0:06:06.33,Default,,0,0,0,,a value. The third example here take
Dialogue: 0,0:06:06.33,0:06:10.16,Default,,0,0,0,,takes an integer and returns a function
Dialogue: 0,0:06:10.16,0:06:14.18,Default,,0,0,0,,that takes a list and returns a list.
Dialogue: 0,0:06:14.18,0:06:17.44,Default,,0,0,0,,Remember, when we have a type with arrows the
Dialogue: 0,0:06:17.44,0:06:20.74,Default,,0,0,0,,parentheses associate to the right.
Dialogue: 0,0:06:20.74,0:06:24.46,Default,,0,0,0,,take, if we put in the parentheses, would be
Dialogue: 0,0:06:24.46,0:06:27.78,Default,,0,0,0,,Int -> ([a] -> [a])
Dialogue: 0,0:06:27.78,0:06:31.50,Default,,0,0,0,,take takes a number and
Dialogue: 0,0:06:31.50,0:06:38.50,Default,,0,0,0,,a list, takes the first n elements from\Nthe list and returns that list.
Dialogue: 0,0:06:38.51,0:06:40.26,Default,,0,0,0,,Now the next function here: zip
Dialogue: 0,0:06:40.26,0:06:44.77,Default,,0,0,0,,is a nice one. It takes two lists
Dialogue: 0,0:06:44.77,0:06:47.93,Default,,0,0,0,,and returns a list of pairs
Dialogue: 0,0:06:47.93,0:06:51.37,Default,,0,0,0,,and the way it works is it takes the two\Nlists and
Dialogue: 0,0:06:51.37,0:06:54.63,Default,,0,0,0,,takes each element of these two lists and\Ncombines them
Dialogue: 0,0:06:54.63,0:06:58.05,Default,,0,0,0,,into a tuple. Now I think
Dialogue: 0,0:06:58.05,0:07:01.58,Default,,0,0,0,,the type of zip looks a little bit nicer
Dialogue: 0,0:07:01.58,0:07:06.12,Default,,0,0,0,,when you don't write that in curried form.\NWhen you would write the type list
Dialogue: 0,0:07:06.12,0:07:10.19,Default,,0,0,0,,using tuples it would have type
Dialogue: 0,0:07:10.19,0:07:13.22,Default,,0,0,0,,([a], [b]) -> [(a, b)]
Dialogue: 0,0:07:13.22,0:07:18.03,Default,,0,0,0,,There you can really see in the type
Dialogue: 0,0:07:18.03,0:07:21.72,Default,,0,0,0,,that zip
Dialogue: 0,0:07:21.72,0:07:26.55,Default,,0,0,0,,twists the lists around.\NThen the last function here,
Dialogue: 0,0:07:26.55,0:07:32.01,Default,,0,0,0,,that's perhaps the simplest function\Nyou can imagine in Haskell:
Dialogue: 0,0:07:32.01,0:07:32.69,Default,,0,0,0,,the identity function
Dialogue: 0,0:07:32.69,0:07:37.05,Default,,0,0,0,,it takes at value of type a and returns a\Nvalue of type a
Dialogue: 0,0:07:37.05,0:07:41.46,Default,,0,0,0,,for any a. If you think a\Nlittle bit about that
Dialogue: 0,0:07:41.46,0:07:46.11,Default,,0,0,0,,the only thing this function can do is\Nyou know just return its value because
Dialogue: 0,0:07:46.11,0:07:46.90,Default,,0,0,0,,otherwise
Dialogue: 0,0:07:46.90,0:07:50.09,Default,,0,0,0,,it will be hard to work on any
Dialogue: 0,0:07:50.09,0:07:53.28,Default,,0,0,0,,type a.
Dialogue: 0,0:07:53.28,0:07:56.30,Default,,0,0,0,,The identity goes
Dialogue: 0,0:07:56.30,0:07:59.68,Default,,0,0,0,,for all a: a -> a.
Dialogue: 0,0:07:59.68,0:08:03.66,Default,,0,0,0,,The only thing really that it can do is it\Ncan take the argument
Dialogue: 0,0:08:03.66,0:08:07.38,Default,,0,0,0,,and immediately return that. If you're\Ninterested
Dialogue: 0,0:08:07.38,0:08:11.27,Default,,0,0,0,,in this thing where you look\Nat the type and then you get the
Dialogue: 0,0:08:11.27,0:08:12.12,Default,,0,0,0,,property
Dialogue: 0,0:08:12.12,0:08:15.28,Default,,0,0,0,,about the implementation you should\Nread
Dialogue: 0,0:08:15.28,0:08:18.53,Default,,0,0,0,,Phill Wadler's paper 'Theorems for Free' and
Dialogue: 0,0:08:18.53,0:08:21.88,Default,,0,0,0,,that paper will explain that
Dialogue: 0,0:08:21.88,0:08:26.19,Default,,0,0,0,,every polymorphic type gives you a theorem\Nthat holds
Dialogue: 0,0:08:26.19,0:08:29.41,Default,,0,0,0,,for that function.
Dialogue: 0,0:08:29.41,0:08:32.45,Default,,0,0,0,,That's a little bit advanced so
Dialogue: 0,0:08:32.45,0:08:36.49,Default,,0,0,0,,you can read that if you want and there will\Nbe a link to the paper
Dialogue: 0,0:08:36.49,0:08:40.56,Default,,0,0,0,,on the course website. The last topic
Dialogue: 0,0:08:40.56,0:08:44.62,Default,,0,0,0,,that we're going to do in the context\Nof functions
Dialogue: 0,0:08:44.62,0:08:47.41,Default,,0,0,0,,are overloaded functions.
Dialogue: 0,0:08:47.41,0:08:51.04,Default,,0,0,0,,We all know overloaded function, most\Nlanguages support them
Dialogue: 0,0:08:51.04,0:08:54.78,Default,,0,0,0,,for example in Java you can overload
Dialogue: 0,0:08:54.78,0:08:58.43,Default,,0,0,0,,functions with different parameter type.
Dialogue: 0,0:08:58.43,0:09:02.57,Default,,0,0,0,,I can define a function foo that\Ntakes and int
Dialogue: 0,0:09:02.57,0:09:07.23,Default,,0,0,0,,and then I can have an overload that takes\Na boolean and then I can have a number
Dialogue: 0,0:09:07.23,0:09:11.80,Default,,0,0,0,,another overload takes a List and the\Nname
Dialogue: 0,0:09:11.80,0:09:15.93,Default,,0,0,0,,of that function is the same but the\Ntypes of the parameters
Dialogue: 0,0:09:15.93,0:09:20.99,Default,,0,0,0,,are different. In Haskell overloaded is
Dialogue: 0,0:09:20.99,0:09:24.40,Default,,0,0,0,,done in a slightly different form.
Dialogue: 0,0:09:24.40,0:09:28.10,Default,,0,0,0,,It corresponds more to the notion of\Ninterfaces
Dialogue: 0,0:09:28.10,0:09:31.87,Default,,0,0,0,,in object-oriented languages.\NIn Haskell
Dialogue: 0,0:09:31.87,0:09:35.74,Default,,0,0,0,,when you overload a function it really\Nmeans
Dialogue: 0,0:09:35.74,0:09:39.97,Default,,0,0,0,,not overloading in the\Nobject-oriented sense,
Dialogue: 0,0:09:39.97,0:09:43.26,Default,,0,0,0,,it really means that you're restricting
Dialogue: 0,0:09:43.26,0:09:46.85,Default,,0,0,0,,
Dialogue: 0,0:09:46.85,0:09:51.06,Default,,0,0,0,,the types of the parameters. In this case\Nwhen I want to sum
Dialogue: 0,0:09:51.06,0:09:55.42,Default,,0,0,0,,the elements of a list, I cannot say
Dialogue: 0,0:09:55.42,0:09:58.87,Default,,0,0,0,,that type sum has type [a] -> a
Dialogue: 0,0:09:58.87,0:10:02.43,Default,,0,0,0,,because what if I
Dialogue: 0,0:10:02.43,0:10:06.32,Default,,0,0,0,,have a list of characters I cannot
Dialogue: 0,0:10:06.32,0:10:12.46,Default,,0,0,0,,add characters together. Maybe you can\Nsay I can define to add characters
Dialogue: 0,0:10:12.46,0:10:13.67,Default,,0,0,0,,but let's say then
Dialogue: 0,0:10:13.67,0:10:17.15,Default,,0,0,0,,that we have a list of tuples...
Dialogue: 0,0:10:17.15,0:10:21.62,Default,,0,0,0,,Well, in that case sum of the list of tuples\Nof type (a, b)
Dialogue: 0,0:10:21.62,0:10:26.24,Default,,0,0,0,,doesn't really return a tuple of (a, b).\NThat doesn't make sense.
Dialogue: 0,0:10:26.24,0:10:29.87,Default,,0,0,0,,What we want to do is we want to\Nrestrict the type of
Dialogue: 0,0:10:29.87,0:10:33.58,Default,,0,0,0,,the elements in the list such that they\Ncan be summed.
Dialogue: 0,0:10:33.58,0:10:36.72,Default,,0,0,0,,That is what Haskell overloading
Dialogue: 0,0:10:36.72,0:10:40.38,Default,,0,0,0,,gives you. What you see here in this type\Nsum has type
Dialogue: 0,0:10:40.38,0:10:43.62,Default,,0,0,0,,Num a =>
Dialogue: 0,0:10:43.62,0:10:47.96,Default,,0,0,0,,Num a => [a] -> a. What this means
Dialogue: 0,0:10:47.96,0:10:51.04,Default,,0,0,0,,is that sum doesn't take
Dialogue: 0,0:10:51.04,0:10:54.43,Default,,0,0,0,,a list of values of type a for any a
Dialogue: 0,0:10:54.43,0:10:57.45,Default,,0,0,0,,but only values of type a
Dialogue: 0,0:10:57.45,0:10:59.18,Default,,0,0,0,,that
Dialogue: 0,0:10:59.18,0:11:01.68,Default,,0,0,0,,are in this Num class
Dialogue: 0,0:11:01.68,0:11:04.73,Default,,0,0,0,,or in, if you think about
Dialogue: 0,0:11:04.73,0:11:08.99,Default,,0,0,0,,object orientation, it only takes a\Nlist of
Dialogue: 0,0:11:08.99,0:11:12.29,Default,,0,0,0,,values of type A that implement the
Dialogue: 0,0:11:12.29,0:11:16.52,Default,,0,0,0,,Num interface. When you see this\Nnotation here
Dialogue: 0,0:11:16.52,0:11:20.81,Default,,0,0,0,,Num a => roughly
Dialogue: 0,0:11:20.81,0:11:25.48,Default,,0,0,0,,If you are a Java or C# or PHP\Nprogrammer
Dialogue: 0,0:11:25.48,0:11:28.95,Default,,0,0,0,,or a C++ programmer, think of this
Dialogue: 0,0:11:28.95,0:11:32.88,Default,,0,0,0,,as restricting the values
Dialogue: 0,0:11:32.88,0:11:36.33,Default,,0,0,0,,on which this can work. In Java you have the\Nsame thing: if you have a
Dialogue: 0,0:11:36.33,0:11:39.37,Default,,0,0,0,,generic function you can restrict
Dialogue: 0,0:11:39.37,0:11:42.54,Default,,0,0,0,,the values by requiring
Dialogue: 0,0:11:42.54,0:11:46.81,Default,,0,0,0,,that the types implement a certain\Ninterface. In C# you can do the same
Dialogue: 0,0:11:46.81,0:11:48.30,Default,,0,0,0,,thing...
Dialogue: 0,0:11:48.30,0:11:52.16,Default,,0,0,0,,most languages allow this and\NHaskell is no
Dialogue: 0,0:11:52.16,0:11:56.56,Default,,0,0,0,,exception. sum takes a list
Dialogue: 0,0:11:56.56,0:11:59.86,Default,,0,0,0,,and returns it into a value but it can
Dialogue: 0,0:11:59.86,0:12:03.18,Default,,0,0,0,,only do that when the values in the list
Dialogue: 0,0:12:03.18,0:12:06.50,Default,,0,0,0,,support the Num class or the Num interface.
Dialogue: 0,0:12:06.50,0:12:10.93,Default,,0,0,0,,
Dialogue: 0,0:12:10.93,0:12:14.10,Default,,0,0,0,,In this case we can do sum of\Nintegers
Dialogue: 0,0:12:14.10,0:12:18.06,Default,,0,0,0,,then in that case a = Int and we know
Dialogue: 0,0:12:18.06,0:12:21.63,Default,,0,0,0,,that integers are number,
Dialogue: 0,0:12:21.63,0:12:25.68,Default,,0,0,0,,so that's fine. We will see what this Num class\Nis later. The Num class basically says
Dialogue: 0,0:12:25.68,0:12:28.43,Default,,0,0,0,,that you can do addition and\Nmultiplication and so on.
Dialogue: 0,0:12:28.43,0:12:32.86,Default,,0,0,0,,Second one here is a list of\Nfloating-point numbers.
Dialogue: 0,0:12:32.86,0:12:36.88,Default,,0,0,0,,I can sum them as well, but here
Dialogue: 0,0:12:36.88,0:12:40.07,Default,,0,0,0,,we get a type error. The last thing here we get\Na type error
Dialogue: 0,0:12:40.07,0:12:43.75,Default,,0,0,0,,because here we have a list of\Ncharacters and
Dialogue: 0,0:12:43.75,0:12:47.30,Default,,0,0,0,,characters don't support the Num interface
Dialogue: 0,0:12:47.30,0:12:51.41,Default,,0,0,0,,Characters are not an\Ninstanceof the Num class
Dialogue: 0,0:12:51.41,0:12:55.69,Default,,0,0,0,,in Haskell speak. Haskel has
Dialogue: 0,0:12:55.69,0:13:00.37,Default,,0,0,0,,besides Num several type classes,\Nyou can define your own type classes,
Dialogue: 0,0:13:00.37,0:13:02.26,Default,,0,0,0,,we will see how to do that later
Dialogue: 0,0:13:02.26,0:13:04.16,Default,,0,0,0,,and in this case
Dialogue: 0,0:13:04.16,0:13:07.86,Default,,0,0,0,,the Num class says that you have
Dialogue: 0,0:13:07.86,0:13:11.02,Default,,0,0,0,,addition. What that means is that
Dialogue: 0,0:13:11.02,0:13:14.46,Default,,0,0,0,,the type of addition takes
Dialogue: 0,0:13:14.46,0:13:18.79,Default,,0,0,0,,a value of type a, returns a function that\Ntakes another value
Dialogue: 0,0:13:18.79,0:13:21.91,Default,,0,0,0,,of type a and then returns a value\Nof type a
Dialogue: 0,0:13:21.91,0:13:26.29,Default,,0,0,0,,but it's not for all values of a,
Dialogue: 0,0:13:26.29,0:13:29.58,Default,,0,0,0,,only values in the Num class.\NSimilarly,
Dialogue: 0,0:13:29.58,0:13:32.82,Default,,0,0,0,,when you want to compare two values for\Nequality
Dialogue: 0,0:13:32.82,0:13:37.08,Default,,0,0,0,,they have to be in the Eq class.\NHere you see
Dialogue: 0,0:13:37.08,0:13:40.31,Default,,0,0,0,,that the equality operator has type
Dialogue: 0,0:13:40.31,0:13:43.82,Default,,0,0,0,,Eq a => a -> a -> Bool
Dialogue: 0,0:13:43.82,0:13:46.89,Default,,0,0,0,,and finally
Dialogue: 0,0:13:46.89,0:13:50.51,Default,,0,0,0,,there's the type of values that you can\Ncompare
Dialogue: 0,0:13:50.51,0:13:54.66,Default,,0,0,0,,so the order types and there less than\Nhas type
Dialogue: 0,0:13:54.66,0:13:57.95,Default,,0,0,0,,Ord a => a -> a -> Bool
Dialogue: 0,0:13:57.95,0:14:01.94,Default,,0,0,0,,Here are some
Dialogue: 0,0:14:01.94,0:14:05.51,Default,,0,0,0,,exercises. The exercises you
Dialogue: 0,0:14:05.51,0:14:09.80,Default,,0,0,0,,will do on the website so I won't\Ngive you
Dialogue: 0,0:14:09.80,0:14:12.88,Default,,0,0,0,,the answers right now but the
Dialogue: 0,0:14:12.88,0:14:17.40,Default,,0,0,0,,exercises will be on the website but\NI'll walk you through this exercise
Dialogue: 0,0:14:17.40,0:14:22.52,Default,,0,0,0,,to get you familiar. So the\Nquestion is like what is the type
Dialogue: 0,0:14:22.52,0:14:28.07,Default,,0,0,0,,of the value of the list
Dialogue: 0,0:14:28.07,0:14:31.10,Default,,0,0,0,,with three characters a, b and c
Dialogue: 0,0:14:31.10,0:14:34.48,Default,,0,0,0,,and so on and so on.
Dialogue: 0,0:14:34.48,0:14:38.45,Default,,0,0,0,,Please do these exercises because they\Nwill make sure
Dialogue: 0,0:14:38.45,0:14:42.18,Default,,0,0,0,,that you understand the idea of types\Nthat we
Dialogue: 0,0:14:42.18,0:14:45.31,Default,,0,0,0,,explained in this lecture.
Dialogue: 0,0:14:45.31,0:14:49.19,Default,,0,0,0,,Then here are a couple of more
Dialogue: 0,0:14:49.19,0:14:52.52,Default,,0,0,0,,complicated exercises,
Dialogue: 0,0:14:52.52,0:14:56.38,Default,,0,0,0,,where you don't get a value and you have\Nto compute the type
Dialogue: 0,0:14:56.38,0:14:59.41,Default,,0,0,0,,but you get a function and now you have\Nto
Dialogue: 0,0:14:59.41,0:15:03.64,Default,,0,0,0,,compute the type of the function and the\Ntrick here
Dialogue: 0,0:15:03.64,0:15:07.32,Default,,0,0,0,,and this is what I'm going to...
Dialogue: 0,0:15:07.32,0:15:10.32,Default,,0,0,0,,the secret I'm going to reveal\Nto you
Dialogue: 0,0:15:10.32,0:15:13.10,Default,,0,0,0,,is that you can use GHC
Dialogue: 0,0:15:13.10,0:15:17.38,Default,,0,0,0,,to check your answers. When you're doing\Nthe exercises don't go and
Dialogue: 0,0:15:17.38,0:15:20.42,Default,,0,0,0,,try them out randomly. What you do is
Dialogue: 0,0:15:20.42,0:15:23.80,Default,,0,0,0,,open up GHC and used the :type
Dialogue: 0,0:15:23.80,0:15:27.47,Default,,0,0,0,,functionality to do these exercises.
Dialogue: 0,0:15:27.47,0:15:30.48,Default,,0,0,0,,So you are
Dialogue: 0,0:15:30.48,0:15:34.75,Default,,0,0,0,,sure that you can score a hundred\Npercent on every one of them.
Dialogue: 0,0:15:34.75,0:15:39.15,Default,,0,0,0,,Thank you and happy hacking. Use GHC
Dialogue: 0,0:15:39.15,0:15:43.99,Default,,0,0,0,,to do your exercises and if you\Ndon't use Haskell
Dialogue: 0,0:15:43.99,0:15:48.34,Default,,0,0,0,,but another language, make sure that\Nyou're also using
Dialogue: 0,0:15:48.34,0:15:51.84,Default,,0,0,0,,your compiler to check your types.
Dialogue: 0,0:15:51.84,0:15:55.60,Default,,0,0,0,,Because we as humans should not do this\Ntype checking.
Dialogue: 0,0:15:55.60,0:15:58.74,Default,,0,0,0,,That's why we have computers to do that\Nfor us.
Dialogue: 0,0:15:58.74,0:16:01.23,Default,,0,0,0,,Thank you very much and see you next\Nweek.
