[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: None

[Aegisub Project Garbage]

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,Arial,20,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,2,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:01.75,0:00:03.59,Default,,0,0,0,,Hi everybody! Welcome
Dialogue: 0,0:00:03.59,0:00:06.89,Default,,0,0,0,,to another episode of FP101x.
Dialogue: 0,0:00:06.89,0:00:11.17,Default,,0,0,0,,And what we're going to do today
Dialogue: 0,0:00:11.17,0:00:14.75,Default,,0,0,0,,is we're going to look how to define
Dialogue: 0,0:00:14.75,0:00:18.26,Default,,0,0,0,,functions in Haskell. Now
Dialogue: 0,0:00:18.26,0:00:21.66,Default,,0,0,0,,I think everybody of you that
Dialogue: 0,0:00:21.66,0:00:25.24,Default,,0,0,0,,has been to college in a different town
Dialogue: 0,0:00:25.24,0:00:28.42,Default,,0,0,0,,than where they grew up has had
Dialogue: 0,0:00:28.42,0:00:31.80,Default,,0,0,0,,this experience in one way or\Nanother.
Dialogue: 0,0:00:31.80,0:00:35.69,Default,,0,0,0,,You leave your hometown where you grew\Nup, you went to
Dialogue: 0,0:00:35.69,0:00:40.42,Default,,0,0,0,,elementary school, you went to highschool,\Nyou go off for college
Dialogue: 0,0:00:40.42,0:00:43.57,Default,,0,0,0,,and then ten years later you come back
Dialogue: 0,0:00:43.57,0:00:46.98,Default,,0,0,0,,and things have changed slightly
Dialogue: 0,0:00:46.98,0:00:50.02,Default,,0,0,0,,but they're also a little bit the same.
Dialogue: 0,0:00:50.02,0:00:53.46,Default,,0,0,0,,And that can be a little bit\Ndisorientating because
Dialogue: 0,0:00:53.46,0:00:56.80,Default,,0,0,0,,in your memory things were
Dialogue: 0,0:00:56.80,0:01:00.50,Default,,0,0,0,,like they were, but in reality they have\Nchanged
Dialogue: 0,0:01:00.50,0:01:04.07,Default,,0,0,0,,slightly.
Dialogue: 0,0:01:04.07,0:01:07.72,Default,,0,0,0,,You will get the same experience when\Nyou look
Dialogue: 0,0:01:07.72,0:01:11.93,Default,,0,0,0,,at Haskell. Haskell looks very familiar
Dialogue: 0,0:01:11.93,0:01:16.22,Default,,0,0,0,,to other programming languages, but it\Ndiffers in subtle ways.
Dialogue: 0,0:01:16.22,0:01:19.40,Default,,0,0,0,,And the goal of this lecture is to
Dialogue: 0,0:01:19.40,0:01:23.02,Default,,0,0,0,,walk through some of the syntax of Haskell
Dialogue: 0,0:01:23.02,0:01:26.11,Default,,0,0,0,,function definition and expressions
Dialogue: 0,0:01:26.11,0:01:29.75,Default,,0,0,0,,and compare and contrast these with
Dialogue: 0,0:01:29.75,0:01:33.97,Default,,0,0,0,,how you do these things in other\Nprogramming languages.
Dialogue: 0,0:01:33.97,0:01:37.00,Default,,0,0,0,,And once you're aware of these\Ndifferences
Dialogue: 0,0:01:37.00,0:01:40.65,Default,,0,0,0,,it will be fairly easy to adopt to them\Nbut
Dialogue: 0,0:01:40.65,0:01:45.07,Default,,0,0,0,,there are some things where Haskell is\Ndefinitely a little bit
Dialogue: 0,0:01:45.07,0:01:49.60,Default,,0,0,0,,different than what
Dialogue: 0,0:01:49.60,0:01:52.74,Default,,0,0,0,,most people are used to in Java or
Dialogue: 0,0:01:52.74,0:01:58.15,Default,,0,0,0,,in PHP or whatever your favorite\Nlanguage is.
Dialogue: 0,0:01:58.15,0:02:01.53,Default,,0,0,0,,So
Dialogue: 0,0:02:01.53,0:02:06.37,Default,,0,0,0,,the first thing is conditional\Nexpressions. Every language has
Dialogue: 0,0:02:06.37,0:02:12.16,Default,,0,0,0,,conditional expressions. And often\Nthere's a difference between conditional
Dialogue: 0,0:02:12.16,0:02:13.17,Default,,0,0,0,,statements,
Dialogue: 0,0:02:13.17,0:02:18.08,Default,,0,0,0,,that are written using if then else,\Nand conditional expressions,
Dialogue: 0,0:02:18.08,0:02:21.16,Default,,0,0,0,,ternary expressions, that are written\Nwith question mark
Dialogue: 0,0:02:21.16,0:02:26.30,Default,,0,0,0,,colon. Other languages do have if\Nthen else for expressions as well, for
Dialogue: 0,0:02:26.30,0:02:27.52,Default,,0,0,0,,example in Scala
Dialogue: 0,0:02:27.52,0:02:30.70,Default,,0,0,0,,but if you're using C# or
Dialogue: 0,0:02:30.70,0:02:34.97,Default,,0,0,0,,Java, there's the conditional\Nstatements
Dialogue: 0,0:02:34.97,0:02:38.57,Default,,0,0,0,,and then for conditional expressions\Nthere's
Dialogue: 0,0:02:38.57,0:02:42.54,Default,,0,0,0,,different syntax. In Haskell since\Nthere's no statements
Dialogue: 0,0:02:42.54,0:02:46.16,Default,,0,0,0,,when you want to write a conditional\Nyou write
Dialogue: 0,0:02:46.16,0:02:49.93,Default,,0,0,0,,if then else. In this
Dialogue: 0,0:02:49.93,0:02:53.58,Default,,0,0,0,,case we're defining a function that\Ntakes an integer
Dialogue: 0,0:02:53.58,0:02:57.25,Default,,0,0,0,,and returns another integer, and it's\Ndefined..
Dialogue: 0,0:02:57.25,0:03:00.47,Default,,0,0,0,,This is the absolute value. So it\Ntakes
Dialogue: 0,0:03:00.47,0:03:04.33,Default,,0,0,0,,a value and says that if that value is greater\Nthan 0
Dialogue: 0,0:03:04.33,0:03:07.98,Default,,0,0,0,,then you return n else you return -n.
Dialogue: 0,0:03:07.98,0:03:13.57,Default,,0,0,0,,You negate the value. So here you\Nsee that we're using the familiar
Dialogue: 0,0:03:13.57,0:03:20.37,Default,,0,0,0,,if then else as an expression form.
Dialogue: 0,0:03:20.37,0:03:23.88,Default,,0,0,0,,Of course, since it's just an expression
Dialogue: 0,0:03:23.88,0:03:27.00,Default,,0,0,0,,they can be nested as well.
Dialogue: 0,0:03:27.00,0:03:30.87,Default,,0,0,0,,And since conditionals are\Nexpressions
Dialogue: 0,0:03:30.87,0:03:34.16,Default,,0,0,0,,you always have to have a then and an else\Npart.
Dialogue: 0,0:03:34.16,0:03:38.37,Default,,0,0,0,,So in this case you can define
Dialogue: 0,0:03:38.37,0:03:42.70,Default,,0,0,0,,the sign of a number, so if n is\Nless than 0
Dialogue: 0,0:03:42.70,0:03:46.36,Default,,0,0,0,,it's -1, if n is zero
Dialogue: 0,0:03:46.36,0:03:52.13,Default,,0,0,0,,then the sign is 0 and else n is\Ngreater than zero, then the sign
Dialogue: 0,0:03:52.13,0:03:56.59,Default,,0,0,0,,is 1. So you always have to\Nhave both
Dialogue: 0,0:03:56.59,0:04:00.76,Default,,0,0,0,,a then and an else branch, just like in ternary\Nexpressions.
Dialogue: 0,0:04:00.76,0:04:04.34,Default,,0,0,0,,
Dialogue: 0,0:04:04.34,0:04:07.60,Default,,0,0,0,,Because Haskell people like brevity
Dialogue: 0,0:04:07.60,0:04:12.17,Default,,0,0,0,,they often don't use conditional\Nexpressions, but they use so-called
Dialogue: 0,0:04:12.17,0:04:14.06,Default,,0,0,0,,guarded equations.
Dialogue: 0,0:04:14.06,0:04:16.53,Default,,0,0,0,,And a guarded equation
Dialogue: 0,0:04:16.53,0:04:21.59,Default,,0,0,0,,captures a common pattern where a function\Nstarts with a conditional.
Dialogue: 0,0:04:21.59,0:04:26.62,Default,,0,0,0,,So, if the right hand side of a function\Ndefinition immediately has a conditional
Dialogue: 0,0:04:26.62,0:04:32.03,Default,,0,0,0,,it's often nicer to use this form with\Nguarded equations. So you write your
Dialogue: 0,0:04:32.03,0:04:34.09,Default,,0,0,0,,function definition on your left hand side
Dialogue: 0,0:04:34.09,0:04:37.37,Default,,0,0,0,,and then you write you're conditions\Nhere, so
Dialogue: 0,0:04:37.37,0:04:40.76,Default,,0,0,0,,the absolute value of n is
Dialogue: 0,0:04:40.76,0:04:44.75,Default,,0,0,0,,n when n is greater than or equal to 0
Dialogue: 0,0:04:44.75,0:04:49.84,Default,,0,0,0,,or it's -n otherwise. And otherwise is\Njust
Dialogue: 0,0:04:49.84,0:04:53.30,Default,,0,0,0,,another alias for True. Now let's
Dialogue: 0,0:04:53.30,0:04:57.28,Default,,0,0,0,,go back to
Dialogue: 0,0:04:57.28,0:05:03.61,Default,,0,0,0,,the definition here, of the absolute value\Nusing a conditional.
Dialogue: 0,0:05:03.61,0:05:07.06,Default,,0,0,0,,And here you see what I said.\NThis is a function
Dialogue: 0,0:05:07.06,0:05:10.63,Default,,0,0,0,,that is defined immediately using
Dialogue: 0,0:05:10.63,0:05:13.68,Default,,0,0,0,,a conditional.
Dialogue: 0,0:05:13.68,0:05:18.47,Default,,0,0,0,,And Haskell people prefer to write it\Nlike this. And now you see that the right hand
Dialogue: 0,0:05:18.47,0:05:19.11,Default,,0,0,0,,side
Dialogue: 0,0:05:19.11,0:05:22.33,Default,,0,0,0,,is simpler and the cases are
Dialogue: 0,0:05:22.33,0:05:26.02,Default,,0,0,0,,more distinguished. You can easily\Nreason about this.
Dialogue: 0,0:05:26.02,0:05:29.15,Default,,0,0,0,,If it's greater than 0 or
Dialogue: 0,0:05:29.15,0:05:36.15,Default,,0,0,0,,if it's less than zero. And the other\Nfunction, especially when you have nested
Dialogue: 0,0:05:36.44,0:05:37.38,Default,,0,0,0,,conditionals
Dialogue: 0,0:05:37.38,0:05:40.78,Default,,0,0,0,,this becomes even more worthwhile.
Dialogue: 0,0:05:40.78,0:05:44.91,Default,,0,0,0,,So in order to define the sign of a\Nnumber: if it's less than zero
Dialogue: 0,0:05:44.91,0:05:48.16,Default,,0,0,0,,-1, if it's equal to zero 0
Dialogue: 0,0:05:48.16,0:05:52.16,Default,,0,0,0,,and otherwise it's one. Here you see
Dialogue: 0,0:05:52.16,0:05:55.77,Default,,0,0,0,,the kind of mathematical heritage of\NHaskell
Dialogue: 0,0:05:55.77,0:05:58.97,Default,,0,0,0,,where we like to write things in a very
Dialogue: 0,0:05:58.97,0:06:02.97,Default,,0,0,0,,concise way. And these guarded equations
Dialogue: 0,0:06:02.97,0:06:06.02,Default,,0,0,0,,are something that are very
Dialogue: 0,0:06:06.02,0:06:09.72,Default,,0,0,0,,idiomatic Haskell. So typically you don't\Nwrite
Dialogue: 0,0:06:09.72,0:06:12.77,Default,,0,0,0,,if then else, you write
Dialogue: 0,0:06:12.77,0:06:18.28,Default,,0,0,0,,these guarded equations.
Dialogue: 0,0:06:18.28,0:06:20.72,Default,,0,0,0,,Another thing that
Dialogue: 0,0:06:20.72,0:06:24.21,Default,,0,0,0,,is very heavily used in Haskell
Dialogue: 0,0:06:24.21,0:06:27.50,Default,,0,0,0,,and that few contemporary languages
Dialogue: 0,0:06:27.50,0:06:30.97,Default,,0,0,0,,have is pattern matching.
Dialogue: 0,0:06:30.97,0:06:34.31,Default,,0,0,0,,Scala for example has pattern\Nmatching
Dialogue: 0,0:06:34.31,0:06:38.52,Default,,0,0,0,,but there you have to use a case statement\Nto do the pattern matching.
Dialogue: 0,0:06:38.52,0:06:42.65,Default,,0,0,0,,C# will get pattern matching.\NIt uses the switch statement.
Dialogue: 0,0:06:42.65,0:06:46.42,Default,,0,0,0,,But in Haskell you can use pattern\Nmatching directly when you define
Dialogue: 0,0:06:46.42,0:06:48.75,Default,,0,0,0,,functions. So for example when we
Dialogue: 0,0:06:48.75,0:06:52.55,Default,,0,0,0,,want to define negation, function from\NBool
Dialogue: 0,0:06:52.55,0:06:57.16,Default,,0,0,0,,to Bool, we can define it with pattern\Nmatching directly. We can say not of
Dialogue: 0,0:06:57.16,0:06:57.89,Default,,0,0,0,,False
Dialogue: 0,0:06:57.89,0:07:01.88,Default,,0,0,0,,equals True and not of True equals\NFalse.
Dialogue: 0,0:07:01.88,0:07:05.39,Default,,0,0,0,,That is a very very concise
Dialogue: 0,0:07:05.39,0:07:10.53,Default,,0,0,0,,definition of negation. Let's look at\Nanother example.
Dialogue: 0,0:07:10.53,0:07:13.80,Default,,0,0,0,,Say that we want to define &&
Dialogue: 0,0:07:13.80,0:07:18.10,Default,,0,0,0,,of two booleans, a function from\NBool to Bool to Bool
Dialogue: 0,0:07:18.10,0:07:21.93,Default,,0,0,0,,and we just write down
Dialogue: 0,0:07:21.93,0:07:25.64,Default,,0,0,0,,the truth table for &&. So this is
Dialogue: 0,0:07:25.64,0:07:29.42,Default,,0,0,0,,exactly how you... if you look\Nup the definition
Dialogue: 0,0:07:29.42,0:07:35.02,Default,,0,0,0,,of && in any book on digital logic, you\Nwill see the same truth table here.
Dialogue: 0,0:07:35.02,0:07:38.04,Default,,0,0,0,,We can write that down, but if you look at
Dialogue: 0,0:07:38.04,0:07:41.68,Default,,0,0,0,,all of this, you see that it can be\Nwritten
Dialogue: 0,0:07:41.68,0:07:45.09,Default,,0,0,0,,even more compactly. Because the only\Ncase
Dialogue: 0,0:07:45.09,0:07:48.17,Default,,0,0,0,,where this thing is true is when
Dialogue: 0,0:07:48.17,0:07:52.15,Default,,0,0,0,,both arguments here are true.
Dialogue: 0,0:07:52.15,0:07:56.67,Default,,0,0,0,,And in all other cases it's false. So you\Ncan take
Dialogue: 0,0:07:56.67,0:07:59.91,Default,,0,0,0,,these four cases here and collapse them\Ndown to these two.
Dialogue: 0,0:07:59.91,0:08:03.46,Default,,0,0,0,,True && True equals True and\Notherwise
Dialogue: 0,0:08:03.46,0:08:07.26,Default,,0,0,0,,whatever and whatever equals False.
Dialogue: 0,0:08:07.26,0:08:11.22,Default,,0,0,0,,And this underscore here is used
Dialogue: 0,0:08:11.22,0:08:14.45,Default,,0,0,0,,very very often in Haskell and it means
Dialogue: 0,0:08:14.45,0:08:18.84,Default,,0,0,0,,this is a variable that I don't care about.\NIt's just used as a placeholder
Dialogue: 0,0:08:18.84,0:08:24.23,Default,,0,0,0,,when doing pattern matching.
Dialogue: 0,0:08:24.23,0:08:28.45,Default,,0,0,0,,If you look at this definition
Dialogue: 0,0:08:28.45,0:08:31.96,Default,,0,0,0,,it will evaluate
Dialogue: 0,0:08:31.96,0:08:35.59,Default,,0,0,0,,both arguments
Dialogue: 0,0:08:35.59,0:08:39.02,Default,,0,0,0,,in order to do this match, because we're\Nputting a pattern
Dialogue: 0,0:08:39.02,0:08:42.58,Default,,0,0,0,,on both sides of the &&.
Dialogue: 0,0:08:42.58,0:08:47.72,Default,,0,0,0,,Haskell people are very sensitive to\Nthis, because Haskell is a lazy language
Dialogue: 0,0:08:47.72,0:08:48.05,Default,,0,0,0,,and
Dialogue: 0,0:08:48.05,0:08:52.04,Default,,0,0,0,,you want to do as little\Nevaluation as possible
Dialogue: 0,0:08:52.04,0:08:55.26,Default,,0,0,0,,in order to find
Dialogue: 0,0:08:55.26,0:08:58.32,Default,,0,0,0,,the answer to
Dialogue: 0,0:08:58.32,0:09:02.43,Default,,0,0,0,,this function call. A nicer\Ndefinition
Dialogue: 0,0:09:02.43,0:09:05.74,Default,,0,0,0,,according to the Haskell idiom is the\Nfollowing:
Dialogue: 0,0:09:05.74,0:09:09.18,Default,,0,0,0,,If it's True then
Dialogue: 0,0:09:09.18,0:09:12.69,Default,,0,0,0,,True and something is the same as b
Dialogue: 0,0:09:12.69,0:09:16.57,Default,,0,0,0,,and False and whatever is False.
Dialogue: 0,0:09:16.57,0:09:20.17,Default,,0,0,0,,Let's see if this is true. True
Dialogue: 0,0:09:20.17,0:09:25.26,Default,,0,0,0,,and True equals True. True and\NFalse
Dialogue: 0,0:09:25.26,0:09:29.66,Default,,0,0,0,,equals False. So True and whatever\Nis there
Dialogue: 0,0:09:29.66,0:09:32.76,Default,,0,0,0,,is whatever was there. And if it's
Dialogue: 0,0:09:32.76,0:09:37.25,Default,,0,0,0,,False on the left hand side, it doesn't\Nmatter what's here on the right hand side.
Dialogue: 0,0:09:37.25,0:09:37.68,Default,,0,0,0,,It's
Dialogue: 0,0:09:37.68,0:09:41.36,Default,,0,0,0,,always False. This is actually
Dialogue: 0,0:09:41.36,0:09:44.83,Default,,0,0,0,,the most
Dialogue: 0,0:09:44.83,0:09:47.92,Default,,0,0,0,,optimal definition of
Dialogue: 0,0:09:47.92,0:09:51.01,Default,,0,0,0,,&& because it only
Dialogue: 0,0:09:51.01,0:09:54.30,Default,,0,0,0,,evaluates the first argument
Dialogue: 0,0:09:54.30,0:09:58.43,Default,,0,0,0,,as necessary.
Dialogue: 0,0:09:58.43,0:10:01.34,Default,,0,0,0,,In Haskell patterns are matched in\Norder.
Dialogue: 0,0:10:01.34,0:10:06.61,Default,,0,0,0,,They are matched top to bottom left\Nto right, or left to right
Dialogue: 0,0:10:06.61,0:10:10.75,Default,,0,0,0,,top to bottom, if I'm really precise.
Dialogue: 0,0:10:10.75,0:10:14.11,Default,,0,0,0,,And so the compiler does not try to\Nrearrange
Dialogue: 0,0:10:14.11,0:10:17.57,Default,,0,0,0,,the patterns necessarily to
Dialogue: 0,0:10:17.57,0:10:20.67,Default,,0,0,0,,make them more optimal, because the order
Dialogue: 0,0:10:20.67,0:10:25.37,Default,,0,0,0,,is important and you can intermix\Npattern matching
Dialogue: 0,0:10:25.37,0:10:29.70,Default,,0,0,0,,with guarded equations.
Dialogue: 0,0:10:29.70,0:10:33.85,Default,,0,0,0,,The easiest thing to think about is that\Npatterns are always matched
Dialogue: 0,0:10:33.85,0:10:37.40,Default,,0,0,0,,left to right, top to bottom.
Dialogue: 0,0:10:37.40,0:10:40.65,Default,,0,0,0,,You cannot repeat variables, for example:
Dialogue: 0,0:10:40.65,0:10:44.27,Default,,0,0,0,,You cannot say b && b equals b
Dialogue: 0,0:10:44.27,0:10:47.96,Default,,0,0,0,,and assume that this is implicitly doing\Nequality
Dialogue: 0,0:10:47.96,0:10:51.10,Default,,0,0,0,,over b. All the variables
Dialogue: 0,0:10:51.10,0:10:55.98,Default,,0,0,0,,inside a pattern must be unique.
Dialogue: 0,0:10:55.98,0:11:01.47,Default,,0,0,0,,One thing that we have seen: we have\Nwritten lists using these square brackets.
Dialogue: 0,0:11:01.47,0:11:06.34,Default,,0,0,0,,And these square brackets really are just\Nsyntactic sugar for
Dialogue: 0,0:11:06.34,0:11:09.43,Default,,0,0,0,,writing the list using explicit
Dialogue: 0,0:11:09.43,0:11:13.16,Default,,0,0,0,,cons and empty list.
Dialogue: 0,0:11:13.16,0:11:17.02,Default,,0,0,0,,When a list
Dialogue: 0,0:11:17.02,0:11:20.20,Default,,0,0,0,,a constant list appears in some place
Dialogue: 0,0:11:20.20,0:11:24.34,Default,,0,0,0,,it will mean this, but inside pattern\Nmatching
Dialogue: 0,0:11:24.34,0:11:30.24,Default,,0,0,0,,we often have to write lists in this form.\NSo for example when we want to define
Dialogue: 0,0:11:30.24,0:11:34.70,Default,,0,0,0,,the head of a list, we define it using\Npattern matching as follows:
Dialogue: 0,0:11:34.70,0:11:38.51,Default,,0,0,0,,We write the list in head
Dialogue: 0,0:11:38.51,0:11:42.54,Default,,0,0,0,,tail form. Let's call it like that.
Dialogue: 0,0:11:42.54,0:11:47.46,Default,,0,0,0,,The head of a list, with head x and\Ntail
Dialogue: 0,0:11:47.46,0:11:51.21,Default,,0,0,0,,I don't care, is the head. And the tail
Dialogue: 0,0:11:51.21,0:11:54.79,Default,,0,0,0,,of a list, with a head that I don't care\Nabout, and tail xs
Dialogue: 0,0:11:54.79,0:11:58.34,Default,,0,0,0,,is xs. So again
Dialogue: 0,0:11:58.34,0:12:01.58,Default,,0,0,0,,very concise definitions. And just for\Nfun
Dialogue: 0,0:12:01.58,0:12:05.27,Default,,0,0,0,,let's look at the types. Tail takes\Na list
Dialogue: 0,0:12:05.27,0:12:08.73,Default,,0,0,0,,and since the tail of a list\Nis a list
Dialogue: 0,0:12:08.73,0:12:10.62,Default,,0,0,0,,the type is list
Dialogue: 0,0:12:10.62,0:12:13.61,Default,,0,0,0,,to list. Head takes a list
Dialogue: 0,0:12:13.61,0:12:16.69,Default,,0,0,0,,but the value of the head
Dialogue: 0,0:12:16.69,0:12:21.19,Default,,0,0,0,,is the element type of the list, so\Nit's a, so this thing goes from list
Dialogue: 0,0:12:21.19,0:12:24.41,Default,,0,0,0,,of a to a. Of course
Dialogue: 0,0:12:24.41,0:12:29.13,Default,,0,0,0,,these are not total functions, because\Nhead and tail
Dialogue: 0,0:12:29.13,0:12:34.01,Default,,0,0,0,,are not defined on the empty list.\NWhen I apply head to the empty list
Dialogue: 0,0:12:34.01,0:12:35.77,Default,,0,0,0,,there's no pattern that matches
Dialogue: 0,0:12:35.77,0:12:39.50,Default,,0,0,0,,and so what you will get is\Nan error. And the same for tail.
Dialogue: 0,0:12:39.50,0:12:46.50,Default,,0,0,0,,Another way to say that
Dialogue: 0,0:12:46.89,0:12:51.86,Default,,0,0,0,,is that a pattern like this\Nx:xs only matches
Dialogue: 0,0:12:51.86,0:12:55.24,Default,,0,0,0,,a non-empty list. If you call head\Nwith the empty list
Dialogue: 0,0:12:55.24,0:12:58.80,Default,,0,0,0,,this pattern here
Dialogue: 0,0:12:58.80,0:13:02.22,Default,,0,0,0,,doesn't match, because it's not of the form
Dialogue: 0,0:13:02.22,0:13:05.36,Default,,0,0,0,,x cons anything.
Dialogue: 0,0:13:05.36,0:13:09.64,Default,,0,0,0,,When you see head of empty list, there's no\Ncase that matches
Dialogue: 0,0:13:09.64,0:13:13.37,Default,,0,0,0,,you get an error. The other thing
Dialogue: 0,0:13:13.37,0:13:17.98,Default,,0,0,0,,is that you have to parenthesize\Nthese list
Dialogue: 0,0:13:17.98,0:13:22.29,Default,,0,0,0,,patterns, because application\Nbinds strongest.
Dialogue: 0,0:13:22.29,0:13:26.01,Default,,0,0,0,,This would mean head of x cons
Dialogue: 0,0:13:26.01,0:13:30.50,Default,,0,0,0,,anything, so you have to put\Nparentheses
Dialogue: 0,0:13:30.50,0:13:34.54,Default,,0,0,0,,in these patterns to make it work.\NAlright.
Dialogue: 0,0:13:34.54,0:13:39.32,Default,,0,0,0,,That was our first part of defining\Nfunctions in Haskell.
Dialogue: 0,0:13:39.32,0:13:40.55,Default,,0,0,0,,See you after the break.
