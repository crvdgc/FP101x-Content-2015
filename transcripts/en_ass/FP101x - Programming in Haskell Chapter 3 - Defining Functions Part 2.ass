[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: None

[Aegisub Project Garbage]

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,Arial,20,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,2,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:01.51,0:00:03.12,Default,,0,0,0,,Welcome back!
Dialogue: 0,0:00:03.12,0:00:06.15,Default,,0,0,0,,In the first part of this lecture
Dialogue: 0,0:00:06.15,0:00:09.51,Default,,0,0,0,,we have seen some simple examples of
Dialogue: 0,0:00:09.51,0:00:13.21,Default,,0,0,0,,how to define functions in Haskell\Nand especially how that
Dialogue: 0,0:00:13.21,0:00:16.57,Default,,0,0,0,,differs from most contemporary languages.
Dialogue: 0,0:00:16.57,0:00:20.83,Default,,0,0,0,,We have seen that in Haskell\Nconditionals are expressions, not
Dialogue: 0,0:00:20.83,0:00:21.60,Default,,0,0,0,,statements
Dialogue: 0,0:00:21.60,0:00:25.36,Default,,0,0,0,,but that Haskell programmers rather\Nwrite
Dialogue: 0,0:00:25.36,0:00:28.84,Default,,0,0,0,,guarded equations than conditional\Nexpressions.
Dialogue: 0,0:00:28.84,0:00:32.63,Default,,0,0,0,,The other thing we have seen is how\Nto define functions
Dialogue: 0,0:00:32.63,0:00:35.94,Default,,0,0,0,,using pattern matching.
Dialogue: 0,0:00:35.94,0:00:40.95,Default,,0,0,0,,And we have seen in particular how to\Ndefine functions over lists
Dialogue: 0,0:00:40.95,0:00:45.46,Default,,0,0,0,,using pattern matching. What we're going\Nto look at now
Dialogue: 0,0:00:45.46,0:00:49.45,Default,,0,0,0,,is how to define functions, because\NHaskell is a functional language
Dialogue: 0,0:00:49.45,0:00:52.57,Default,,0,0,0,,so we have to have a way, a concise way
Dialogue: 0,0:00:52.57,0:00:56.25,Default,,0,0,0,,to define functions. And that is\Nlambda expressions.
Dialogue: 0,0:00:56.25,0:01:01.12,Default,,0,0,0,,You probably know lambda expressions
Dialogue: 0,0:01:01.12,0:01:05.04,Default,,0,0,0,,from the language that you're using.\NIf you are a Java programmer
Dialogue: 0,0:01:05.04,0:01:09.45,Default,,0,0,0,,in Java 8 the lambda expressions\Nwere introduced.
Dialogue: 0,0:01:09.45,0:01:13.00,Default,,0,0,0,,If you are a C# programmer, you\Nknow lambda expressions.
Dialogue: 0,0:01:13.00,0:01:16.03,Default,,0,0,0,,If you are a Hack or PHP programmer
Dialogue: 0,0:01:16.03,0:01:20.83,Default,,0,0,0,,you have lambda expressions. In\NJavaScript you have lambda expressions.
Dialogue: 0,0:01:20.83,0:01:22.08,Default,,0,0,0,,Lambda expressions are
Dialogue: 0,0:01:22.08,0:01:25.22,Default,,0,0,0,,everywhere. C++, you name it, D
Dialogue: 0,0:01:25.22,0:01:31.22,Default,,0,0,0,,Swift, every modern language has lambda\Nexpressions. And as we saw in the very
Dialogue: 0,0:01:31.22,0:01:32.17,Default,,0,0,0,,first lecture
Dialogue: 0,0:01:32.17,0:01:35.27,Default,,0,0,0,,this was an invention from Alonzo Church
Dialogue: 0,0:01:35.27,0:01:38.64,Default,,0,0,0,,in the 1930s.
Dialogue: 0,0:01:38.64,0:01:41.88,Default,,0,0,0,,In most languages lambda expressions\Nlook similar
Dialogue: 0,0:01:41.88,0:01:45.00,Default,,0,0,0,,and in Haskell they look as follows:
Dialogue: 0,0:01:45.00,0:01:48.43,Default,,0,0,0,,They look like this:
Dialogue: 0,0:01:48.43,0:01:52.75,Default,,0,0,0,,Lambda x, arrow, body of the lambda\Nexpression.
Dialogue: 0,0:01:52.75,0:01:56.82,Default,,0,0,0,,In the actual code that you type\Nyou don't write the lambda.
Dialogue: 0,0:01:56.82,0:02:00.06,Default,,0,0,0,,You write the slash, so you write \x
Dialogue: 0,0:02:00.06,0:02:03.45,Default,,0,0,0,,and instead of the arrow you write
Dialogue: 0,0:02:03.45,0:02:08.61,Default,,0,0,0,,-> but since we\Nwant these slides to look fancy
Dialogue: 0,0:02:08.61,0:02:10.22,Default,,0,0,0,,we are
Dialogue: 0,0:02:10.22,0:02:13.74,Default,,0,0,0,,actually writing a lambda and a real arrow.
Dialogue: 0,0:02:13.74,0:02:17.31,Default,,0,0,0,,But when you write this in code,\Nyou write slash
Dialogue: 0,0:02:17.31,0:02:21.17,Default,,0,0,0,,for the lambda and you just write the\Narrow
Dialogue: 0,0:02:21.17,0:02:24.89,Default,,0,0,0,,as you would expect. So what is this\Nthing?
Dialogue: 0,0:02:24.89,0:02:28.92,Default,,0,0,0,,This is a function that takes an x\Nand adds it
Dialogue: 0,0:02:28.92,0:02:33.58,Default,,0,0,0,,to itself. And that function has no name,\Nso it's an expression
Dialogue: 0,0:02:33.58,0:02:36.69,Default,,0,0,0,,of function type. That's what lambda\Nexpressions are.
Dialogue: 0,0:02:36.69,0:02:40.22,Default,,0,0,0,,They are expressions that denote\Nfunctions.
Dialogue: 0,0:02:40.22,0:02:43.37,Default,,0,0,0,,
Dialogue: 0,0:02:43.37,0:02:46.94,Default,,0,0,0,,In mathematics and
Dialogue: 0,0:02:46.94,0:02:50.42,Default,,0,0,0,,as Church designed them,
Dialogue: 0,0:02:50.42,0:02:54.48,Default,,0,0,0,,if you read the lambda calculus literature, they're\Nwritten as a lambda, but we type them
Dialogue: 0,0:02:54.48,0:02:54.93,Default,,0,0,0,,as
Dialogue: 0,0:02:54.93,0:02:58.82,Default,,0,0,0,,backslash and instead of the arrow\Nsymbol
Dialogue: 0,0:02:58.82,0:03:02.37,Default,,0,0,0,,we write the arrow symbol.
Dialogue: 0,0:03:02.37,0:03:07.74,Default,,0,0,0,,But for the rest Haskell, I think, is a\Nlanguage that is closest to the lambda
Dialogue: 0,0:03:07.74,0:03:08.40,Default,,0,0,0,,calculus
Dialogue: 0,0:03:08.40,0:03:11.89,Default,,0,0,0,,because it's based on pure functions,\Nwhereas
Dialogue: 0,0:03:11.89,0:03:15.69,Default,,0,0,0,,in other languages lambda expressions are
Dialogue: 0,0:03:15.69,0:03:19.26,Default,,0,0,0,,I think a better way would be to call\Nthem closures.
Dialogue: 0,0:03:19.26,0:03:23.13,Default,,0,0,0,,And we will see why, because they can\Nclose over variables
Dialogue: 0,0:03:23.13,0:03:28.25,Default,,0,0,0,,in the outer scope. But these lambda\Nexpressions can have side effects.
Dialogue: 0,0:03:28.25,0:03:31.38,Default,,0,0,0,,But as we said it doesn't really\Nmatter.
Dialogue: 0,0:03:31.38,0:03:36.42,Default,,0,0,0,,We are really emphasizing the fact that\Nfunctional programming is
Dialogue: 0,0:03:36.42,0:03:42.29,Default,,0,0,0,,programming using expressions. So why are\Nlambda expressions useful?
Dialogue: 0,0:03:42.29,0:03:49.29,Default,,0,0,0,,Well, they are useful, because they allow\Nyou to express your intent better
Dialogue: 0,0:03:49.40,0:03:54.45,Default,,0,0,0,,when you're currying functions. Let's\Nlook at this first example here.
Dialogue: 0,0:03:54.45,0:03:58.25,Default,,0,0,0,,Instead of writing add x y = x+y
Dialogue: 0,0:03:58.25,0:04:01.95,Default,,0,0,0,,so this is a curried definition
Dialogue: 0,0:04:01.95,0:04:05.60,Default,,0,0,0,,This is a function that takes\Na parameter x
Dialogue: 0,0:04:05.60,0:04:08.78,Default,,0,0,0,,returns a function that takes a\Nparameter y
Dialogue: 0,0:04:08.78,0:04:12.51,Default,,0,0,0,,and then returns x plus y. Really
Dialogue: 0,0:04:12.51,0:04:16.16,Default,,0,0,0,,the intent is better expressed by this:
Dialogue: 0,0:04:16.16,0:04:19.32,Default,,0,0,0,,add is a function
Dialogue: 0,0:04:19.32,0:04:24.63,Default,,0,0,0,,that takes a parameter x, returns a\Nfunction that takes a parameter y
Dialogue: 0,0:04:24.63,0:04:27.75,Default,,0,0,0,,and then adds them together.
Dialogue: 0,0:04:27.75,0:04:30.83,Default,,0,0,0,,This is actually syntactic sugar
Dialogue: 0,0:04:30.83,0:04:35.66,Default,,0,0,0,,for this and when I write Haskell I often\Nwrite them in this form.
Dialogue: 0,0:04:35.66,0:04:38.88,Default,,0,0,0,,Even though it's a little bit longer
Dialogue: 0,0:04:38.88,0:04:42.47,Default,,0,0,0,,it means that I have to type more\Ncharacters
Dialogue: 0,0:04:42.47,0:04:46.68,Default,,0,0,0,,but I think this form is more readable\Nthan that form.
Dialogue: 0,0:04:46.68,0:04:50.03,Default,,0,0,0,,And in the course of
Dialogue: 0,0:04:50.03,0:04:53.86,Default,,0,0,0,,these lectures we will switch\Nbetween
Dialogue: 0,0:04:53.86,0:04:58.35,Default,,0,0,0,,both of these. But again, if you look\Nat my Haskell code
Dialogue: 0,0:04:58.35,0:05:03.22,Default,,0,0,0,,I prefer to write things using explicit\Nlambdas to convey
Dialogue: 0,0:05:03.22,0:05:09.59,Default,,0,0,0,,the actual meaning of a curried\Nfunction. Lambda expressions
Dialogue: 0,0:05:09.59,0:05:13.41,Default,,0,0,0,,are also useful when you want to
Dialogue: 0,0:05:13.41,0:05:17.11,Default,,0,0,0,,make explicit that you're returning a\Nfunction. That's
Dialogue: 0,0:05:17.11,0:05:20.93,Default,,0,0,0,,in some sense the same as currying,\Nbut here
Dialogue: 0,0:05:20.93,0:05:24.53,Default,,0,0,0,,if we define a constant function
Dialogue: 0,0:05:24.53,0:05:29.71,Default,,0,0,0,,so this is a function that given an a will\Nreturn a function that whatever b
Dialogue: 0,0:05:29.71,0:05:34.49,Default,,0,0,0,,you give it, will return that a. So\Nhere it's defined: const of x
Dialogue: 0,0:05:34.49,0:05:39.38,Default,,0,0,0,,returns a function that will, whatever\Nyou give it, just ignore it
Dialogue: 0,0:05:39.38,0:05:43.99,Default,,0,0,0,,and return x. So that constant\Nfunction there
Dialogue: 0,0:05:43.99,0:05:47.66,Default,,0,0,0,,is very concisely defined using a\Nlambda expression
Dialogue: 0,0:05:47.66,0:05:50.74,Default,,0,0,0,,whereas here I think it's a little bit\Nless clear.
Dialogue: 0,0:05:50.74,0:05:53.94,Default,,0,0,0,,Const of x underscore equals x.
Dialogue: 0,0:05:53.94,0:05:58.02,Default,,0,0,0,,This one doesn't make explicit\Nthe fact
Dialogue: 0,0:05:58.02,0:06:02.16,Default,,0,0,0,,that you are returning a function. So here\Nit is also emphasized by putting the
Dialogue: 0,0:06:02.16,0:06:03.12,Default,,0,0,0,,parentheses
Dialogue: 0,0:06:03.12,0:06:06.30,Default,,0,0,0,,around the type and here you don't do that.
Dialogue: 0,0:06:06.30,0:06:09.50,Default,,0,0,0,,This is how I would write\Nthis function. I would
Dialogue: 0,0:06:09.50,0:06:12.84,Default,,0,0,0,,put the parentheses on the type and I
Dialogue: 0,0:06:12.84,0:06:18.09,Default,,0,0,0,,write the function as a lambda expression.
Dialogue: 0,0:06:18.09,0:06:21.65,Default,,0,0,0,,Here is another use of lambda expressions.
Dialogue: 0,0:06:21.65,0:06:25.53,Default,,0,0,0,,And that's to avoid inventing names.
Dialogue: 0,0:06:25.53,0:06:27.88,Default,,0,0,0,,Inventing names is
Dialogue: 0,0:06:27.88,0:06:32.25,Default,,0,0,0,,one of the hardest things that we have\Nto do with programming.
Dialogue: 0,0:06:32.25,0:06:35.38,Default,,0,0,0,,Coming up with meaningful names, because often
Dialogue: 0,0:06:35.38,0:06:40.58,Default,,0,0,0,,the language forces you to\Nname something where you just don't want
Dialogue: 0,0:06:40.58,0:06:42.99,Default,,0,0,0,,to name it. You just want to pass the thing\Ndirectly.
Dialogue: 0,0:06:42.99,0:06:46.33,Default,,0,0,0,,For example: if I want to map a\Nfunction
Dialogue: 0,0:06:46.33,0:06:50.53,Default,,0,0,0,,over a list, there is no reason I should\Ngive that function here
Dialogue: 0,0:06:50.53,0:06:54.52,Default,,0,0,0,,a name f. And what does f say anyway?
Dialogue: 0,0:06:54.52,0:06:57.81,Default,,0,0,0,,So instead, what I can do, I can just
Dialogue: 0,0:06:57.81,0:07:00.90,Default,,0,0,0,,pass a lambda expression to the map
Dialogue: 0,0:07:00.90,0:07:04.34,Default,,0,0,0,,and that will be used to map this\Nfunction
Dialogue: 0,0:07:04.34,0:07:07.68,Default,,0,0,0,,over the list. This is
Dialogue: 0,0:07:07.68,0:07:11.37,Default,,0,0,0,,not idiomatic Haskell. This
Dialogue: 0,0:07:11.37,0:07:15.27,Default,,0,0,0,,is idiomatic Haskell. Really the only
Dialogue: 0,0:07:15.27,0:07:19.97,Default,,0,0,0,,place where you want to name something, is\Nwhen you use it more than once.
Dialogue: 0,0:07:19.97,0:07:24.65,Default,,0,0,0,,Or if it becomes clear, but that's
Dialogue: 0,0:07:24.65,0:07:28.83,Default,,0,0,0,,up to interpretation. Here is another
Dialogue: 0,0:07:28.83,0:07:32.88,Default,,0,0,0,,oddity of Haskell and that's called\Nsections.
Dialogue: 0,0:07:32.88,0:07:36.58,Default,,0,0,0,,With sections you can take
Dialogue: 0,0:07:36.58,0:07:39.91,Default,,0,0,0,,a binary operator, an infix operator,\Nlike plus
Dialogue: 0,0:07:39.91,0:07:43.08,Default,,0,0,0,,and use it as a function. So by putting
Dialogue: 0,0:07:43.08,0:07:47.58,Default,,0,0,0,,parentheses around it, you can use plus as a\Nfunction. So 1+2
Dialogue: 0,0:07:47.58,0:07:51.62,Default,,0,0,0,,equals 3 and plus in parentheses
Dialogue: 0,0:07:51.62,0:07:56.59,Default,,0,0,0,,1 2 is also 3. This is a nice trick
Dialogue: 0,0:07:56.59,0:08:01.39,Default,,0,0,0,,because we can also put
Dialogue: 0,0:08:01.39,0:08:04.83,Default,,0,0,0,,(1+) and we can do
Dialogue: 0,0:08:04.83,0:08:08.46,Default,,0,0,0,,(+2) So we can section, we can
Dialogue: 0,0:08:08.46,0:08:12.02,Default,,0,0,0,,partially apply + by putting
Dialogue: 0,0:08:12.02,0:08:15.18,Default,,0,0,0,,parentheses around the plus. Here we see:
Dialogue: 0,0:08:15.18,0:08:18.69,Default,,0,0,0,,We can do (1+) which is a function
Dialogue: 0,0:08:18.69,0:08:22.02,Default,,0,0,0,,that expects a second argument, and will
Dialogue: 0,0:08:22.02,0:08:25.33,Default,,0,0,0,,add 1 to it. And here we have the function
Dialogue: 0,0:08:25.33,0:08:30.09,Default,,0,0,0,,section, (+2) which is a function that\Nexpects
Dialogue: 0,0:08:30.09,0:08:33.47,Default,,0,0,0,,a value here and then adds it
Dialogue: 0,0:08:33.47,0:08:37.82,Default,,0,0,0,,to it. So this is 1+2 equals 3.\NIn general
Dialogue: 0,0:08:37.82,0:08:39.56,Default,,0,0,0,,
Dialogue: 0,0:08:39.56,0:08:43.27,Default,,0,0,0,,if funny plus is a binary\Noperator
Dialogue: 0,0:08:43.27,0:08:47.10,Default,,0,0,0,,then you can write plus in parentheses
Dialogue: 0,0:08:47.10,0:08:50.12,Default,,0,0,0,,to use it as a normal function
Dialogue: 0,0:08:50.12,0:08:53.18,Default,,0,0,0,,and you can left or right section it by
Dialogue: 0,0:08:53.18,0:08:56.38,Default,,0,0,0,,partially applying it to an argument.
Dialogue: 0,0:08:56.38,0:09:00.50,Default,,0,0,0,,This is something that you will\Nsee quite a lot in Haskell
Dialogue: 0,0:09:00.50,0:09:04.75,Default,,0,0,0,,specially here, if you want to have a\Nfunction that increments something
Dialogue: 0,0:09:04.75,0:09:11.02,Default,,0,0,0,,you just write (1+) as a section. Why\Nare sections useful?
Dialogue: 0,0:09:11.02,0:09:16.24,Default,,0,0,0,,Here are a couple of examples. You\Nwant a function that takes an
Dialogue: 0,0:09:16.24,0:09:18.05,Default,,0,0,0,,argument and halves it?
Dialogue: 0,0:09:18.05,0:09:21.99,Default,,0,0,0,,You just write (/2)
Dialogue: 0,0:09:21.99,0:09:25.19,Default,,0,0,0,,And you don't have to write lambda x
Dialogue: 0,0:09:25.19,0:09:29.70,Default,,0,0,0,,x divided by 2. So sectioning allows\Nyou to write something
Dialogue: 0,0:09:29.70,0:09:32.99,Default,,0,0,0,,without inventing a name. And that's
Dialogue: 0,0:09:32.99,0:09:36.36,Default,,0,0,0,,the whole goal of this exercise.
Dialogue: 0,0:09:36.36,0:09:39.74,Default,,0,0,0,,Giving names is hard, so we want to avoid\Nthat.
Dialogue: 0,0:09:39.74,0:09:44.64,Default,,0,0,0,,And sectioning allows you to do that.
Dialogue: 0,0:09:44.64,0:09:51.12,Default,,0,0,0,,Here is a preview of the\Nexercises. The exercises will be
Dialogue: 0,0:09:51.12,0:09:52.64,Default,,0,0,0,,available on the website.
Dialogue: 0,0:09:52.64,0:09:55.93,Default,,0,0,0,,And in these exercises we will ask you
Dialogue: 0,0:09:55.93,0:09:59.75,Default,,0,0,0,,to use some of these constructs that
Dialogue: 0,0:09:59.75,0:10:03.41,Default,,0,0,0,,we have seen in this lecture to define
Dialogue: 0,0:10:03.41,0:10:07.60,Default,,0,0,0,,functions. And as I promise you, this will\Nbe the last
Dialogue: 0,0:10:07.60,0:10:10.86,Default,,0,0,0,,exercise that's very Haskell\Nspecific
Dialogue: 0,0:10:10.86,0:10:14.81,Default,,0,0,0,,but since we have been\Ntalking about how Haskell
Dialogue: 0,0:10:14.81,0:10:18.68,Default,,0,0,0,,differs from other languages, I think\Nit's quite useful
Dialogue: 0,0:10:18.68,0:10:23.49,Default,,0,0,0,,to follow the rest of the lectures to\Ndo these exercises
Dialogue: 0,0:10:23.49,0:10:26.80,Default,,0,0,0,,to get a little bit familiar
Dialogue: 0,0:10:26.80,0:10:31.11,Default,,0,0,0,,with the Haskell syntax. Happy hacking
Dialogue: 0,0:10:31.11,0:10:33.68,Default,,0,0,0,,and see you next week. Bye bye.
