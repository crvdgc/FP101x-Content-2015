1
00:00:01,520 --> 00:00:03,560
欢迎大家参加
Welcome everybody, to the

2
00:00:03,560 --> 00:00:08,849
FP101x 函数式程序设计
FP101x functional programming MOOC.
I'm really happy that we can do this one

3
00:00:08,849 --> 00:00:12,820
这门包含练习之类的慕课
as a MOOC with exercises and
everything.

4
00:00:12,820 --> 00:00:17,820
让我们现在就开始吧
Let's get started

5
00:00:17,820 --> 00:00:23,480
在讨论其他事情之前 我想说的是
immediately. One thing that I wanted
to tell you before we get going

6
00:00:23,480 --> 00:00:28,160
正如标题所说 这门慕课是关于函数式程序设计的
is that this is a MOOC about functional
programming that's what the title says

7
00:00:28,160 --> 00:00:33,090
它不是一门 Haskell 课程 我们是将
FP101 functional programming. This is
not a course on Haskell, were using

8
00:00:33,090 --> 00:00:33,920
Haskell
Haskell

9
00:00:33,920 --> 00:00:39,379
作为一门函数式语言 但我们不是学习如何用 Haskell 编程的
as a functional language but we're not
learning to program Haskell per se.

10
00:00:39,379 --> 00:00:42,469
让我给你讲一个小故事吧
Let me tell you a little bit 
of a story.

11
00:00:42,469 --> 00:00:46,000
我经常旅行 开会
I travel a lot, going to conferences,

12
00:00:46,000 --> 00:00:49,200
讲课 等等
giving courses et cetera 

13
00:00:49,200 --> 00:00:52,989
旅行途中 我有很多时间来看电视
and during those travels I have ample 
time to watch TV.

14
00:00:52,989 --> 00:00:57,520
有一天晚上 当我随意调台时
One night I was zapping through the channels

15
00:00:57,520 --> 00:01:00,770
看到一档求生类节目
and there was one of those survival
shows

16
00:01:00,770 --> 00:01:03,960
里面一个人试着在晚上扎营
where this guy was trying to make up

17
00:01:03,960 --> 00:01:07,340
并且想要点火
camp at night and trying to make a fire

18
00:01:07,340 --> 00:01:10,939
但是火柴都湿了
but his matches were wet. 

19
00:01:10,939 --> 00:01:14,030
也许他会很慌乱并说
He could have gotten in panic and said:

20
00:01:14,030 --> 00:01:17,250
我的火柴湿了 点不着火了
my matches are wet I cannot make a fire.

21
00:01:17,250 --> 00:01:20,680
但他做的却是拿出一部手机
What he did instead is he took a
cell phone

22
00:01:20,680 --> 00:01:23,840
用他的刀
and his knife and he

23
00:01:23,840 --> 00:01:27,869
把电池从上面拆了下来 并打开了电池
took the battery out of his cell phone,
opened the battery

24
00:01:27,869 --> 00:01:30,869
之后电池开始燃烧
and then the battery started to combust.

25
00:01:30,869 --> 00:01:35,220
他就用这个点着了火
That's what he used to start a fire.
And this is the same

26
00:01:35,220 --> 00:01:38,380
这也是我想在这门课中教给你的态度
attitude that I want to teach you in
this course.

27
00:01:38,380 --> 00:01:42,530
当我们用 Haskell 学习函数式程序设计时
While we're learning to do
functional programming using Haskell so

28
00:01:42,530 --> 00:01:44,159
Haskell 是我们的火柴
Haskell's our matches,

29
00:01:44,159 --> 00:01:47,860
在实际工作中 你可能没有火柴能用
when at work you don't have matches
available

30
00:01:47,860 --> 00:01:52,049
但你仍然可以进行函数式编程 有时你需要拆开你的
you still can do functional programming.
Sometimes you have to smash your

31
00:01:52,049 --> 00:01:52,950
手机
cell phone

32
00:01:52,950 --> 00:01:58,320
打开你的电池才能生火 别认为这只是关于
and open your battery to start a fire.
Don't think that this is about

33
00:01:58,320 --> 00:02:02,030
Haskell 的 我们用是 Haskell 但教的是函数式程序设计
Haskell per se, we're going to teach
functional programming

34
00:02:02,030 --> 00:02:06,299
好了 现在让我们
using Haskell. 
Alright, let's get

35
00:02:06,299 --> 00:02:09,869
开始吧
started then.

36
00:02:09,869 --> 00:02:13,090
我们要解决的是什么问题？
What's the problem that we're trying to
solve? The problem

37
00:02:13,090 --> 00:02:17,000
要解决的问题就是所谓的 软件危机
is the so called software crisis. 
We all know

38
00:02:17,000 --> 00:02:21,090
我们都知道开发者写代码十分困难
as developers that writing code is
pretty difficult.

39
00:02:21,090 --> 00:02:24,180
我们需要写大型的程序
We're writing huge programs and

40
00:02:24,180 --> 00:02:28,500
同时又要缩减开发时间 降低开发成本
what we need to do is to reduce the
time

41
00:02:28,500 --> 00:02:32,830
我们希望快速发布软件
and the cost of development. 
We want to deliver software fast

42
00:02:32,830 --> 00:02:37,200
又希望发布的软件正确无误
and we want to deliver correct software. 
The question is

43
00:02:37,200 --> 00:02:40,440
问题是我们如何写程序
how can we make programs

44
00:02:40,440 --> 00:02:44,260
来保证我们有信心认为软件正确工作呢？
such that that we are confident that our
programs work

45
00:02:44,260 --> 00:02:47,609
我们又如何写代码
and how can we make code

46
00:02:47,609 --> 00:02:50,959
来实现快速发布
such that this code is delivered fast.

47
00:02:50,959 --> 00:02:54,370
不是几年后才发布
It doesn't take years to deliver but
it takes 

48
00:02:54,370 --> 00:03:00,970
而是几个月或者更短 一种现代编程语言中
months or as long as it needs to be. 
One way to do that, and we see this now

49
00:03:00,970 --> 00:03:06,260
常见的实现方式是 为编程语言增加特性
in all modern programming languages, is to
add features to our languages

50
00:03:06,260 --> 00:03:11,310
允许程序的表达方式简洁清晰
that allow programs to be written
clearly concisely and at a high level of

51
00:03:11,310 --> 00:03:12,220
抽象层次也较高
abstraction.

52
00:03:12,220 --> 00:03:16,319
我们在现代编程语言中使用的这些技术
And the techniques that we use in these
modern languages

53
00:03:16,319 --> 00:03:19,880
都是基于函数式程序设计
are all based on functional programming.
These techniques

54
00:03:19,880 --> 00:03:23,989
基于 lambda 演算的概念
are all based on concepts from the 
lambda calculus.

55
00:03:23,989 --> 00:03:27,410
Haskell 是一种
And Haskell is a

56
00:03:27,410 --> 00:03:30,660
纯函数式编程语言
functional language that is pure and
therefore

57
00:03:30,660 --> 00:03:34,669
因此适用于这些概念的教学
a really good vehicle to teach these
concept.

58
00:03:34,669 --> 00:03:39,019
函数式编程语言
Functional languages

59
00:03:39,019 --> 00:03:42,799
则提供一种十分优雅的框架
therefore provide a very elegant framework

60
00:03:42,799 --> 00:03:46,120
让我们在一个较高的抽象层次写代码
to write code at a high level of
abstraction.

61
00:03:46,120 --> 00:03:50,139
但正如我说过的 Haskell 只是一个工具
But as I said, Haskell is just our
vehicle.

62
00:03:50,139 --> 00:03:55,329
我们在这门课中所学到的东西
What we learn in this course, you
will be able to apply this

63
00:03:55,329 --> 00:03:59,169
你可以用于任何编程语言 即使你用的是汇编语言
to any language even if you're programming
in assembly

64
00:03:59,169 --> 00:04:02,599
Java 或 PHP
or in Java or in PHP

65
00:04:02,599 --> 00:04:06,489
或者 JavaScript 你在这里学习到的想法
or in JavaScript, all the ideas that you
will learn here

66
00:04:06,489 --> 00:04:09,720
可以立刻用在
you can apply immediately

67
00:04:09,720 --> 00:04:13,150
无论你用的哪种编程语言中
in whatever language you're happening
to use.

68
00:04:13,150 --> 00:04:16,930
那么什么是函数式编程语言呢？
What is a functional programming
language?

69
00:04:16,930 --> 00:04:20,700
可能的回答有很多
The ideas about that

70
00:04:20,700 --> 00:04:24,960
现在还没有明确的定义
vary, there's no real clear
definition.

71
00:04:24,960 --> 00:04:28,740
如果我们考虑最纯的函数式编程语言
If we take a very purist approach a
functional language

72
00:04:28,740 --> 00:04:32,800
那么函数式编程语言就是使用数学函数编程的语言
is a language in which we program using
mathematical functions.

73
00:04:32,800 --> 00:04:37,980
这一定义适用于 Haskell 它本身是一门
And that definition applies to Haskell,
which is a pure language, one of the very

74
00:04:37,980 --> 00:04:38,830
纯函数式语言
few

75
00:04:38,830 --> 00:04:42,320
在函数式语言中仅有很少几门是纯的
functional programming languages that is
pure. But of course

76
00:04:42,320 --> 00:04:46,860
当然 我在说我们可以将这些技术应用到其他编程语言中
and when I say that we can use these
techniques to program also in other

77
00:04:46,860 --> 00:04:47,670
的时候
languages

78
00:04:47,670 --> 00:04:52,020
我们不能使用这个定义
we cannot use that definition.

79
00:04:52,020 --> 00:04:56,020
我们要用的时下面的定义
What will use in this course is the
following definition: 

80
00:04:56,020 --> 00:04:56,930
函数式编程语言
functional programming

81
00:04:56,930 --> 00:05:00,900
是一种编程的风格
is a style of programming in which

82
00:05:00,900 --> 00:05:04,310
其中表达式比语句更为重要
expressions are more important than
using statements.

83
00:05:04,310 --> 00:05:09,000
我们想做的事情时用表达式组成程序
What we want to do is: we want to
compose programs using expressions

84
00:05:09,000 --> 00:05:13,800
这些表达式都可以求值 因此我们可以把两个可以求值的
and these expressions deliver a value so
we take two expressions that deliver a

85
00:05:13,800 --> 00:05:14,530
表达式
value

86
00:05:14,530 --> 00:05:18,620
组合起来成为一个更大的表达式
and compose them in a bigger expression.

87
00:05:18,620 --> 00:05:23,780
比较一下使用语句编程
Compare and contrast that with writing
your program using statements.

88
00:05:23,780 --> 00:05:28,040
当你将语句组合起来的时候 每条语句都有隐藏的副作用
When you compose statements the
statements have an implicit side-effect

89
00:05:28,040 --> 00:05:32,410
这些副作用影响全局状态 它们通过全局状态实现通信
on the global state and they
communicate values via that global

90
00:05:32,410 --> 00:05:32,880
state.

91
00:05:32,880 --> 00:05:36,000
而使用表达式编程时
Whereas in an expression based

92
00:05:36,000 --> 00:05:40,620
表达式返回一个值
programming style expressions return
values

93
00:05:40,620 --> 00:05:46,320
我们直接将值组合起来 一门函数式编程语言
and we compose these values directly.
A functional programming language

94
00:05:46,320 --> 00:05:50,190
就是支持并且鼓励
is a language that supports and
encourages

95
00:05:50,190 --> 00:05:53,410
使用表达式编程的语言
writing code using expressions.

96
00:05:53,410 --> 00:05:57,230
正如我说过的一样 大部分现代语言
As I said before, most modern
languages

97
00:05:57,230 --> 00:06:01,240
现在都支持这种风格
now support this style. 
And they support the style

98
00:06:01,240 --> 00:06:04,850
特别时通过支持 lambda 表达式来实现这一点
specifically by supporting lambda
expressions.

99
00:06:04,850 --> 00:06:08,830
随着课程的进行 我们可以在很多很多语言中
We'll see examples of functional
programming

100
00:06:08,830 --> 00:06:11,960
看到函数式编程的例子
in many many languages as we progress

101
00:06:11,960 --> 00:06:15,430
让我们
through this course. Let's

102
00:06:15,430 --> 00:06:19,190
从第一段代码开始吧
start with our first fragment of code
here. 

103
00:06:19,190 --> 00:06:22,440
这是一种老式的 Java 编程风格
This is some old-fashioned Java

104
00:06:22,440 --> 00:06:27,070
我们要计算 1 到 10 的加和
where we're computing the sum of the
integers from one to ten.

105
00:06:27,070 --> 00:06:31,250
我们做的方式 使用传统的过程式编程风格
The way we do that, as I said, in the
traditional imperative

106
00:06:31,250 --> 00:06:33,820
它是基于语句的
style, this is based by doing

107
00:06:33,820 --> 00:06:38,530
我们做的第一件事是声明了一个整数类型的
statements. The first thing we do
is we declare a variable total

108
00:06:38,530 --> 00:06:41,920
变量 total 并将它初始化为 0
of type int. We initialize it with zero

109
00:06:41,920 --> 00:06:46,380
接下来我们用一个循环变量写一个 for 循环
and then we write a for loop with a
loop variable.

110
00:06:46,380 --> 00:06:49,660
你可以看到这边的变量 i
That int i, that you see there and then we

111
00:06:49,660 --> 00:06:53,530
然后我们给 total 变量赋值
assign to that the total
variable:

112
00:06:53,530 --> 00:06:57,100
成为 total + i 你可以看到
total variable + i. Here you see that

113
00:06:57,100 --> 00:07:00,240
这个程序是用一种
the program is written

114
00:07:00,240 --> 00:07:03,860
过程式的风格写的 我们有语句
in an imperative style. 
We have statements,

115
00:07:03,860 --> 00:07:06,990
我们有可变状态
we have mutable state and we

116
00:07:06,990 --> 00:07:10,660
我们过程式地执行一条语句接一条语句
imperatively execute statement after
statement

117
00:07:10,660 --> 00:07:14,160
更新状态来计算最终结果
updating the state to compute the result.

118
00:07:14,160 --> 00:07:18,710
这是你用 Haskell 编写相同程序的方式
Now here is how you would write that same
program

119
00:07:18,710 --> 00:07:21,980
你可以看到的第一点是
in Haskell. The first thing you see is
that it's

120
00:07:21,980 --> 00:07:26,980
程序更加简洁 另一点是没有语句了
much more concise but the other thing is
that there's no statement. It's just

121
00:07:26,980 --> 00:07:30,230
只有两个表达式
two expressions. 
The expression you see

122
00:07:30,230 --> 00:07:33,430
这里
here

123
00:07:33,430 --> 00:07:36,740
右面这个 1 点点 10 （1..10）
on the right. One dot dot ten.

124
00:07:36,740 --> 00:07:40,300
创建了一个从 1 到 10 的整数列表
Creates a list of the integers from one
to ten.

125
00:07:40,300 --> 00:07:43,920
然后我们仅仅将这些整数相加
And then we just sum those integers up.

126
00:07:43,920 --> 00:07:47,380
所以你可以看到我们使用表达式
So here you see that we're composing

127
00:07:47,380 --> 00:07:52,670
来组合成为程序 一个表达式创建从 1 到 10 的列表
the code by having an expression. 
One that creates this list from one to ten

128
00:07:52,670 --> 00:07:56,600
我们将它的返回值应用到
and then we apply that value

129
00:07:56,600 --> 00:07:59,680
sum 函数上 从而把内容求和
to a function sum that will sum things

130
00:07:59,680 --> 00:08:03,080
在 Java 8 中
up for us. In Java 8

131
00:08:03,080 --> 00:08:06,670
你可以用 Java 8 的流（streams）
you can write the same code

132
00:08:06,670 --> 00:08:10,040
写同样的程序
using Java 8 streams, we will

133
00:08:10,040 --> 00:08:14,070
我们将在未来的课程中深入探讨 Java 8
dive deeper into Java 8 and a future

134
00:08:14,070 --> 00:08:17,590
但现在我们只看用 Haskell 实现的方式
lesson but for now here is the way

135
00:08:17,590 --> 00:08:21,990
十分感谢
we do this in Haskell. 
Thank you

136
00:08:21,990 --> 00:08:24,590
第二部分再见
and see you in part two.

