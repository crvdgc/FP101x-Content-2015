[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: None

[Aegisub Project Garbage]
Scroll Position: 141
Active Line: 156

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,Arial,20,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,2,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:01.81,0:00:03.05,Default,,0,0,0,,大家欢迎回来
Dialogue: 0,0:00:03.05,0:00:09.99,Default,,0,0,0,,来上 FP101x
Dialogue: 0,0:00:09.99,0:00:13.07,Default,,0,0,0,,让我们现在开始吧
Dialogue: 0,0:00:13.07,0:00:16.35,Default,,0,0,0,,首先介绍一点函数式程序设计的历史
Dialogue: 0,0:00:16.35,0:00:19.68,Default,,0,0,0,,当我们看 Java 或 JavaScript 这样的语言时
Dialogue: 0,0:00:19.68,0:00:25.35,Default,,0,0,0,,很容易忘记函数式程序设计的概念
Dialogue: 0,0:00:25.35,0:00:28.77,Default,,0,0,0,,实际上非常古老
Dialogue: 0,0:00:28.77,0:00:35.54,Default,,0,0,0,,甚至是在我们大多数人出生之前就被发明了
Dialogue: 0,0:00:35.54,0:00:39.87,Default,,0,0,0,,这位是阿隆佐·邱奇（Alonzo Church）
Dialogue: 0,0:00:39.87,0:00:44.04,Default,,0,0,0,,他在20世纪30年代发明了 lambda 演算
Dialogue: 0,0:00:44.04,0:00:47.96,Default,,0,0,0,,他是打算将 lambda 演算作为数学的基础的
Dialogue: 0,0:00:47.96,0:00:51.93,Default,,0,0,0,,他想要找到一种方式
Dialogue: 0,0:00:51.93,0:00:55.10,Default,,0,0,0,,来描述数学的基础
Dialogue: 0,0:00:55.10,0:00:58.14,Default,,0,0,0,,结果令人惊奇的是
Dialogue: 0,0:00:58.14,0:01:02.39,Default,,0,0,0,,他在20世纪30年代的工作
Dialogue: 0,0:01:02.39,0:01:06.61,Default,,0,0,0,,成为了今天大多数编程语言的基础
Dialogue: 0,0:01:06.61,0:01:10.36,Default,,0,0,0,,如果你去看 JavaScript 这门支撑起万维网的语言
Dialogue: 0,0:01:10.36,0:01:14.36,Default,,0,0,0,,我们都知道在 JavaScript 中函数很重要
Dialogue: 0,0:01:14.36,0:01:17.67,Default,,0,0,0,,所以人们可以说
Dialogue: 0,0:01:17.67,0:01:20.78,Default,,0,0,0,,是 lambda 演算支持着万维网
Dialogue: 0,0:01:20.78,0:01:28.29,Default,,0,0,0,,现在 Java 8 也有 lambda 表达式 C++
Dialogue: 0,0:01:28.29,0:01:32.61,Default,,0,0,0,,也有 lambda 表达式 如今正在使用的编程语言没有一门
Dialogue: 0,0:01:32.61,0:01:35.97,Default,,0,0,0,,不支持阿隆佐·丘奇
Dialogue: 0,0:01:35.97,0:01:41.72,Default,,0,0,0,,在20世纪30年代发明的这个概念
Dialogue: 0,0:01:41.72,0:01:44.97,Default,,0,0,0,,如果再靠近现代一点
Dialogue: 0,0:01:44.97,0:01:48.43,Default,,0,0,0,,20世纪50年代，约翰·麦卡锡
Dialogue: 0,0:01:48.43,0:01:53.00,Default,,0,0,0,,发明了 Lisp 语言 这是最早几门编程语言之一
Dialogue: 0,0:01:53.00,0:02:02.07,Default,,0,0,0,,它同时也是第一个 函数式编程语言 约翰·麦卡锡（John McCarthy）
Dialogue: 0,0:02:02.07,0:02:06.65,Default,,0,0,0,,受 lambda 演算影响 但他也同时
Dialogue: 0,0:02:06.65,0:02:12.29,Default,,0,0,0,,也在 Lisp 中设计了过程式的赋值
Dialogue: 0,0:02:12.29,0:02:20.01,Default,,0,0,0,,在某种程度上你可以说 Lisp 是最早的 几门现代语言之一
Dialogue: 0,0:02:20.01,0:02:33.04,Default,,0,0,0,,它结合了纯 lambda 演算的思想 以及一些编程语言中的过程式特性
Dialogue: 0,0:02:33.04,0:02:36.70,Default,,0,0,0,,在20世纪60年代 彼得·兰丁发明了 ISWIM
Dialogue: 0,0:02:36.70,0:02:40.15,Default,,0,0,0,,意思是 如果你知道我的意思是什么（If You See What I Mean）
Dialogue: 0,0:02:40.15,0:02:44.20,Default,,0,0,0,,它是第一个纯函数式语言
Dialogue: 0,0:02:44.20,0:02:48.04,Default,,0,0,0,,基于 lambda 演算 这也意味着
Dialogue: 0,0:02:48.04,0:02:51.93,Default,,0,0,0,,语言中没有赋值 只有纯函数
Dialogue: 0,0:02:51.93,0:03:01.34,Default,,0,0,0,,20世纪70年代 约翰·巴科斯（John Backus） 设计了 FP 意思是
Dialogue: 0,0:03:01.34,0:03:04.34,Default,,0,0,0,,函数式编程（Functional Programming） 约翰·巴科斯
Dialogue: 0,0:03:04.34,0:03:07.90,Default,,0,0,0,,同时也是 Fortran 的设计者之一
Dialogue: 0,0:03:07.90,0:03:11.62,Default,,0,0,0,,那门语言大约是和 Lisp 同时设计出来的
Dialogue: 0,0:03:11.62,0:03:14.97,Default,,0,0,0,,是一门过程特性十分强的语言
Dialogue: 0,0:03:14.97,0:03:19.84,Default,,0,0,0,,他在七十年代设计了这门新语言
Dialogue: 0,0:03:19.84,0:03:22.90,Default,,0,0,0,,强调高阶函数
Dialogue: 0,0:03:22.90,0:03:26.82,Default,,0,0,0,,并特别强调对程序进行推理
Dialogue: 0,0:03:26.82,0:03:33.98,Default,,0,0,0,,希望能够推理得出 FP 代码的正确性
Dialogue: 0,0:03:33.98,0:03:38.51,Default,,0,0,0,,FP 对这点十分强调 同样在七十年代
Dialogue: 0,0:03:38.51,0:03:41.95,Default,,0,0,0,,这边的这位罗宾·米尔纳（Robin Milner）
Dialogue: 0,0:03:41.95,0:03:45.01,Default,,0,0,0,,发明了 ML 编程语言
Dialogue: 0,0:03:45.01,0:03:49.44,Default,,0,0,0,,ML 同样是一门混合式编程语言
Dialogue: 0,0:03:49.44,0:03:53.13,Default,,0,0,0,,既包含纯函数编程语言的思想
Dialogue: 0,0:03:53.13,0:03:56.23,Default,,0,0,0,,又允许过程式赋值
Dialogue: 0,0:03:56.23,0:03:59.72,Default,,0,0,0,,关于 ML 的一个有趣的细节是
Dialogue: 0,0:03:59.72,0:04:02.98,Default,,0,0,0,,ML 最初的设计目标是一门脚本语言
Dialogue: 0,0:04:02.98,0:04:07.62,Default,,0,0,0,,它被设计成能让人们写出证明的脚本
Dialogue: 0,0:04:07.62,0:04:12.09,Default,,0,0,0,,当你写下数学证明时 有很多地方只是套用模板
Dialogue: 0,0:04:12.09,0:04:15.93,Default,,0,0,0,,需要很多步骤 为了让这一过程自动化
Dialogue: 0,0:04:15.93,0:04:20.35,Default,,0,0,0,,米尔纳和他的同事发明了 ML
Dialogue: 0,0:04:20.35,0:04:28.85,Default,,0,0,0,,来让你能够用脚本完成无聊的步骤
Dialogue: 0,0:04:28.85,0:04:33.94,Default,,0,0,0,,ML 有一个优点 记住当时是七十年代
Dialogue: 0,0:04:33.94,0:04:37.53,Default,,0,0,0,,它就支持类型推断了
Dialogue: 0,0:04:37.53,0:04:43.00,Default,,0,0,0,,因此你可以写下一个函数 编译器就会帮你推断出类型
Dialogue: 0,0:04:43.00,0:04:50.43,Default,,0,0,0,,ML 同时也有多态类型 或者我们现在所谓的
Dialogue: 0,0:04:50.43,0:04:55.49,Default,,0,0,0,,泛型 比如你可以有一个 T 类型的列表
Dialogue: 0,0:04:55.49,0:05:00.63,Default,,0,0,0,,之后将 T 实例化为整数类型或字符串类型
Dialogue: 0,0:05:00.63,0:05:07.10,Default,,0,0,0,,甚至是另一个列表类型 这些类型推断的概念
Dialogue: 0,0:05:07.10,0:05:11.24,Default,,0,0,0,,以及泛型的概念实际上都很古老
Dialogue: 0,0:05:11.24,0:05:22.66,Default,,0,0,0,,过了几十年后这些概念才从学术界进入主流
Dialogue: 0,0:05:22.66,0:05:25.95,Default,,0,0,0,,在七八十年代 大卫·特纳（David Turner）
Dialogue: 0,0:05:25.95,0:05:29.59,Default,,0,0,0,,设计了多门编程语言 开始是 SASL
Dialogue: 0,0:05:29.59,0:05:33.50,Default,,0,0,0,,接着是 KRC 最终的顶点是
Dialogue: 0,0:05:33.50,0:05:37.73,Default,,0,0,0,,Miranda 这些都是惰性函数式语言
Dialogue: 0,0:05:37.73,0:05:41.21,Default,,0,0,0,,我们将在后面看到惰性函数式语言
Dialogue: 0,0:05:41.21,0:05:44.39,Default,,0,0,0,,和严格的函数式语言的区别
Dialogue: 0,0:05:44.39,0:05:49.66,Default,,0,0,0,,大卫·特纳极具影响力
Dialogue: 0,0:05:49.66,0:05:54.29,Default,,0,0,0,,因为 Haskell 这门我们的课中要用的编程语言
Dialogue: 0,0:05:54.29,0:05:57.56,Default,,0,0,0,,同样是惰性语言 它是基于
Dialogue: 0,0:05:57.56,0:06:01.73,Default,,0,0,0,,大卫·特纳在 Miranda SASL 和 KRC
Dialogue: 0,0:06:01.73,0:06:07.22,Default,,0,0,0,,上所做的很多工作 当我开始学计算机科学时
Dialogue: 0,0:06:07.22,0:06:10.47,Default,,0,0,0,,在八十年代 接触到的第一门函数式语言
Dialogue: 0,0:06:10.47,0:06:17.44,Default,,0,0,0,,就是 SASL 所以 SASL 在我心中一直有特别的地位
Dialogue: 0,0:06:17.44,0:06:27.69,Default,,0,0,0,,我们也会在之后的课程中了解一下 SASL
Dialogue: 0,0:06:27.69,0:06:34.91,Default,,0,0,0,,因为在某种程度上 SASL 是 Haskell 之母
Dialogue: 0,0:06:34.91,0:06:41.00,Default,,0,0,0,,现在说说 Haskell 大约 1987 年
Dialogue: 0,0:06:41.00,0:06:47.81,Default,,0,0,0,,一些编程语言研究者和函数式语言研究者
Dialogue: 0,0:06:47.81,0:06:52.50,Default,,0,0,0,,开始设计 Haskell 语言 想法就是
Dialogue: 0,0:06:52.50,0:06:56.52,Default,,0,0,0,,设计一门人们可以在上面进行试验的标准语言
Dialogue: 0,0:06:56.52,0:07:01.38,Default,,0,0,0,,因为如果你想试验一下 比方说 一种新的类型系统
Dialogue: 0,0:07:01.38,0:07:04.81,Default,,0,0,0,,搭建整个编程语言的框架需要做很多工作
Dialogue: 0,0:07:04.81,0:07:09.14,Default,,0,0,0,,比如语言本身 解析器 等等 尽管你想做的只是
Dialogue: 0,0:07:09.14,0:07:12.82,Default,,0,0,0,,研究这个新的类型系统
Dialogue: 0,0:07:12.82,0:07:15.95,Default,,0,0,0,,Haskell 有时被称为
Dialogue: 0,0:07:15.95,0:07:19.42,Default,,0,0,0,,编程语言研究的培养皿
Dialogue: 0,0:07:19.42,0:07:24.10,Default,,0,0,0,,它实现了这个目标 有很多研究论文
Dialogue: 0,0:07:24.10,0:07:27.36,Default,,0,0,0,,中 Haskell 被用作
Dialogue: 0,0:07:27.36,0:07:32.54,Default,,0,0,0,,实验的 基质 同时 Haskell 本身
Dialogue: 0,0:07:32.54,0:07:34.90,Default,,0,0,0,,作为一门编程语言也是十分成功的
Dialogue: 0,0:07:34.90,0:07:44.43,Default,,0,0,0,,Haskell 同时也是我们在这门课中使用的编程语言
Dialogue: 0,0:07:44.43,0:07:48.06,Default,,0,0,0,,2003年 有趣的是
Dialogue: 0,0:07:48.06,0:07:55.85,Default,,0,0,0,,发表的却是 Haskell 98 报告 也就是说设计完成已经过去了很多年
Dialogue: 0,0:07:55.85,0:08:02.08,Default,,0,0,0,,Haskell 98 的目的是定义这门编程语言的一个稳定版本
Dialogue: 0,0:08:02.08,0:08:05.12,Default,,0,0,0,,Haskell 作为一个研究工具
Dialogue: 0,0:08:05.12,0:08:13.42,Default,,0,0,0,,有着许多的扩展 为了使这门语言能够在主流中使用
Dialogue: 0,0:08:13.42,0:08:17.67,Default,,0,0,0,,需要的就是它的一个稳定版本
Dialogue: 0,0:08:17.67,0:08:21.02,Default,,0,0,0,,只包含那些一致且完成的特性
Dialogue: 0,0:08:21.02,0:08:25.65,Default,,0,0,0,,因此人们才能依靠它们
Dialogue: 0,0:08:25.65,0:08:28.99,Default,,0,0,0,,与此同时 Haskell 也在不断进化
Dialogue: 0,0:08:28.99,0:08:36.86,Default,,0,0,0,,但在这门课程中 我们只使用 Haskell 98 这一子集
Dialogue: 0,0:08:36.86,0:08:45.39,Default,,0,0,0,,如果你用的是 GHC 下一节课中将讲到 GHC 有许多扩展
Dialogue: 0,0:08:45.39,0:08:49.65,Default,,0,0,0,,但那是之后的话题了
Dialogue: 0,0:08:49.65,0:08:52.88,Default,,0,0,0,,我们将仅仅使用 Haskell 98
Dialogue: 0,0:08:52.88,0:09:01.60,Default,,0,0,0,,目前 Haskell 有 Haskell platform
Dialogue: 0,0:09:01.60,0:09:07.17,Default,,0,0,0,,供你下载 课程网站上有很多的相关信息
Dialogue: 0,0:09:12.01,0:09:15.01,Default,,0,0,0,,让你能用其他方式运行 Haskell 程序
Dialogue: 0,0:09:15.01,0:09:19.25,Default,,0,0,0,,以及其他语言的链接 可以用于完成练习
Dialogue: 0,0:09:19.25,0:09:24.44,Default,,0,0,0,,但是 Haskell platform 提供了一种 Haskell 语言的实现
Dialogue: 0,0:09:24.44,0:09:33.80,Default,,0,0,0,,外加针对 Windows Mac 和 Linux 这些主要平台的标准库
Dialogue: 0,0:09:33.80,0:09:38.48,Default,,0,0,0,,Haskell platform 在工业界广泛使用
Dialogue: 0,0:09:38.48,0:09:41.71,Default,,0,0,0,,用来设计真正的软件
Dialogue: 0,0:09:41.71,0:09:44.96,Default,,0,0,0,,同时我们也将看到
Dialogue: 0,0:09:44.96,0:09:48.75,Default,,0,0,0,,Haskell 对其他语言的影响
Dialogue: 0,0:09:48.75,0:09:55.55,Default,,0,0,0,,让我们用一小段 Haskell 程序作为这部分的结尾
Dialogue: 0,0:09:55.55,0:09:58.74,Default,,0,0,0,,来展示 Haskell 的简洁程度
Dialogue: 0,0:09:58.74,0:10:09.05,Default,,0,0,0,,这个程序 实现的是 使用快速排序算法对列表进行排序
Dialogue: 0,0:10:09.05,0:10:13.70,Default,,0,0,0,,这是代码 当我们完成几节课之后
Dialogue: 0,0:10:13.70,0:10:17.75,Default,,0,0,0,,你就能够自己写这样的代码了
Dialogue: 0,0:10:17.75,0:10:21.85,Default,,0,0,0,,当我们要对一个列表进行排序时 首先要看的是
Dialogue: 0,0:10:21.85,0:10:26.01,Default,,0,0,0,,如果列表是空表 也就是这里的第一种情况
Dialogue: 0,0:10:26.01,0:10:29.72,Default,,0,0,0,,我们对空表进行排序
Dialogue: 0,0:10:29.72,0:10:33.31,Default,,0,0,0,,结果仍然是空表 因为空表本身已经排好序了
Dialogue: 0,0:10:33.31,0:10:37.14,Default,,0,0,0,,接下来的一步是 如果我们有一个列表 xs
Dialogue: 0,0:10:37.14,0:10:40.14,Default,,0,0,0,,前面的值是 x
Dialogue: 0,0:10:40.14,0:10:43.15,Default,,0,0,0,,我们要做的是
Dialogue: 0,0:10:43.15,0:10:47.41,Default,,0,0,0,,首先把小于 x 的元素取出来
Dialogue: 0,0:10:47.41,0:10:51.73,Default,,0,0,0,,把它们放在名为 ys 的列表中 接下来
Dialogue: 0,0:10:51.73,0:10:58.28,Default,,0,0,0,,我们取出所有大于 x 的值 放在名为 zs 的列表中
Dialogue: 0,0:10:58.28,0:11:01.32,Default,,0,0,0,,接下来要做的就是递归地
Dialogue: 0,0:11:01.32,0:11:05.31,Default,,0,0,0,,用函数 f 来对 ys 进行排序
Dialogue: 0,0:11:05.31,0:11:08.33,Default,,0,0,0,,因此所有小于 x 的值都会被排序
Dialogue: 0,0:11:08.33,0:11:13.14,Default,,0,0,0,,接下来我们将大于 x 的值 也就是 zs 排序
Dialogue: 0,0:11:13.14,0:11:16.29,Default,,0,0,0,,接下来我们连接
Dialogue: 0,0:11:16.29,0:11:19.88,Default,,0,0,0,,这两个表 并把 x 放在中间
Dialogue: 0,0:11:19.88,0:11:23.06,Default,,0,0,0,,可以很容易看到
Dialogue: 0,0:11:23.06,0:11:26.14,Default,,0,0,0,,这个递归调用的结果
Dialogue: 0,0:11:26.14,0:11:30.43,Default,,0,0,0,,是我们现在有一个排好序的表了
Dialogue: 0,0:11:30.43,0:11:33.62,Default,,0,0,0,,提醒一下 这个程序
Dialogue: 0,0:11:33.62,0:11:37.26,Default,,0,0,0,,仅仅是想你展现快速排序算法的结构
Dialogue: 0,0:11:37.26,0:11:41.16,Default,,0,0,0,,它展现了递归分解的排序方式
Dialogue: 0,0:11:41.16,0:11:44.93,Default,,0,0,0,,真正的快速排序 在一门过程式的语言中
Dialogue: 0,0:11:44.93,0:11:48.37,Default,,0,0,0,,并不如此创建新的列表
Dialogue: 0,0:11:48.37,0:11:54.26,Default,,0,0,0,,也就是这两个表 相反 它会只用一个列表 并在原位置改变值
Dialogue: 0,0:11:54.26,0:11:58.49,Default,,0,0,0,,因此只使用一个列表的空间
Dialogue: 0,0:11:58.49,0:12:04.94,Default,,0,0,0,,即使如此 如果你想学习快速排序的算法结构
Dialogue: 0,0:12:04.94,0:12:08.47,Default,,0,0,0,,这个程序是十分优雅的
Dialogue: 0,0:12:08.47,0:12:12.29,Default,,0,0,0,,当然 我们可能以这个程序作为出发点 接下来我们想
Dialogue: 0,0:12:12.29,0:12:16.86,Default,,0,0,0,,实现一种更有效率的方式 通过改变状态
Dialogue: 0,0:12:16.86,0:12:24.60,Default,,0,0,0,,十分感谢 这就是第一节课的结尾了
Dialogue: 0,0:12:24.60,0:12:27.63,Default,,0,0,0,,祝你 Hacking 课程网站上的练习题愉快！
Dialogue: 0,0:12:27.63,0:12:30.48,Default,,0,0,0,,下周我们第二节课再见
