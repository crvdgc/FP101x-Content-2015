[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: None

[Aegisub Project Garbage]
Scroll Position: 120
Active Line: 132

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,Arial,20,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,2,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:01.01,0:00:07.60,Default,,0,0,0,,欢迎回来，希望学习柯里化 元组和函数类型给你带来了乐趣
Dialogue: 0,0:00:07.60,0:00:14.83,Default,,0,0,0,,我们现在要讲的是类型类（type class）和多态（polymorphic）函数
Dialogue: 0,0:00:14.83,0:00:26.26,Default,,0,0,0,,多态函数不是用具体类型定义的 而是用类型变量（type variable）定义的
Dialogue: 0,0:00:26.26,0:00:33.18,Default,,0,0,0,,下面是一个十分多态的多态函数例子
Dialogue: 0,0:00:33.18,0:00:40.27,Default,,0,0,0,,length 函数 想要计算一个列表的长度
Dialogue: 0,0:00:40.27,0:00:43.70,Default,,0,0,0,,不需要知道列表元素的类型
Dialogue: 0,0:00:43.70,0:00:54.64,Default,,0,0,0,,列表 [1, 2, 3] 和列表 ['a', 'b', 'c'] 的长度都是 3
Dialogue: 0,0:00:54.64,0:01:02.96,Default,,0,0,0,,计算列表的长度时 元素的类型无关紧要
Dialogue: 0,0:01:02.96,0:01:08.47,Default,,0,0,0,,这里 length 的类型是
Dialogue: 0,0:01:08.47,0:01:16.22,Default,,0,0,0,,[a] -> Int 其中 a 在 Haskell 中称作类型变量
Dialogue: 0,0:01:16.22,0:01:24.15,Default,,0,0,0,,以大写字母开头的类型是具体类型 比如 Int 的 I 大写了
Dialogue: 0,0:01:24.15,0:01:30.68,Default,,0,0,0,,a 以小写字母开头 因此是类型变量
Dialogue: 0,0:01:30.68,0:01:40.60,Default,,0,0,0,,意思是对于任意类型 a length 的类型是 a 的列表到整数
Dialogue: 0,0:01:40.60,0:01:56.00,Default,,0,0,0,,如果你习惯使用 Java 和 C# 的泛型（generic） 类型变量一般是在函数类型中显式声明的
Dialogue: 0,0:01:56.00,0:02:00.03,Default,,0,0,0,,比如在 C# 中会定义类型 t 的 length 函数（length<t>）
Dialogue: 0,0:02:00.03,0:02:03.09,Default,,0,0,0,,参数是 t 的列表 返回值是一个整数
Dialogue: 0,0:02:03.09,0:02:13.52,Default,,0,0,0,,但在 Haskell  中 a 是类型变量 因此被隐式限定了
Dialogue: 0,0:02:13.52,0:02:16.53,Default,,0,0,0,,不需要加尖括号之类的
Dialogue: 0,0:02:16.53,0:02:20.86,Default,,0,0,0,,Haskell 在这方面有优势
Dialogue: 0,0:02:20.86,0:02:28.14,Default,,0,0,0,,但代价就是类型变量需要以小写字母开头 类型以大写字母
Dialogue: 0,0:02:28.14,0:02:37.63,Default,,0,0,0,,这里的类型是 对于任意类型 a length 接受一个 a 的列表
Dialogue: 0,0:02:37.63,0:02:41.73,Default,,0,0,0,,返回一个整数 和你想的一样
Dialogue: 0,0:02:41.73,0:02:45.57,Default,,0,0,0,,并且和列表元素的类型没有关系
Dialogue: 0,0:02:45.57,0:02:55.00,Default,,0,0,0,,你只关心元素有多少 不关心是什么
Dialogue: 0,0:02:55.00,0:03:03.38,Default,,0,0,0,,在 length [False True] 中 a 的类型是 Bool 长度是 2
Dialogue: 0,0:03:03.38,0:03:10.19,Default,,0,0,0,,这里则是整数的列表 因此 a 的类型是 Int
Dialogue: 0,0:03:10.19,0:03:14.24,Default,,0,0,0,,长度是 4
Dialogue: 0,0:03:14.24,0:03:21.06,Default,,0,0,0,,两个例子中都使用了 length 的类型是 对于任意 a [a] -> Int
Dialogue: 0,0:03:21.06,0:03:27.81,Default,,0,0,0,,第一种情况 a 是 Bool 第二种是 Int
Dialogue: 0,0:03:27.81,0:03:36.01,Default,,0,0,0,,为了不显式声明 length 的哪个类型是多态的
Dialogue: 0,0:03:36.01,0:03:42.47,Default,,0,0,0,,Haskell 就得对类型和类型变量的名字空间进行区分
Dialogue: 0,0:03:42.47,0:03:46.73,Default,,0,0,0,,类型变量必须以小写字母开头
Dialogue: 0,0:03:46.73,0:03:53.63,Default,,0,0,0,,习惯上用 a b c 等等表示类型变量
Dialogue: 0,0:03:53.63,0:04:03.95,Default,,0,0,0,,在 Java 和 C# 这类语言中 习惯上使用 S T R 表示类型变量
Dialogue: 0,0:04:03.95,0:04:14.23,Default,,0,0,0,,Haskell 中是小写的 a b c C# 中会写 List<T> 而 Haskell 中是 [a].
Dialogue: 0,0:04:14.23,0:04:22.41,Default,,0,0,0,,接下来是一些 Haskell 标准 Prelude （序幕）中的多态函数
Dialogue: 0,0:04:22.41,0:04:27.06,Default,,0,0,0,,标准 Prelude 库相当于 Haskell 版的 SDK （Java 标准库）或者 BCL （C# 标准库）
Dialogue: 0,0:04:27.06,0:04:31.18,Default,,0,0,0,,和每种语言都带有的标准库一样
Dialogue: 0,0:04:31.18,0:04:40.16,Default,,0,0,0,,函数的类型揭示了很多实现相关的信息
Dialogue: 0,0:04:40.16,0:04:41.18,Default,,0,0,0,,看第一个
Dialogue: 0,0:04:41.18,0:04:48.28,Default,,0,0,0,,fst 接收类型为 (a, b) 的元组 返回类型 a 的值
Dialogue: 0,0:04:48.28,0:04:51.53,Default,,0,0,0,,这个函数能做什么呢
Dialogue: 0,0:04:51.53,0:04:56.78,Default,,0,0,0,,它接收一个元组 返回 a 类型的值
Dialogue: 0,0:04:56.78,0:05:04.50,Default,,0,0,0,,因此从类型中可以很明显看出功能 返回元组第一个元素
Dialogue: 0,0:05:04.50,0:05:17.18,Default,,0,0,0,,现在看 head 函数的类型 对任意类型 a 接收一个 a 的列表 返回一个 a 类型的值
Dialogue: 0,0:05:17.18,0:05:21.06,Default,,0,0,0,,这种情况下有很多选择 给定一个 a 类型的列表
Dialogue: 0,0:05:21.06,0:05:29.58,Default,,0,0,0,,如果需要返回一个 a 类型的值的话 可以挑选表里任意一个元素 head 返回第一个元素
Dialogue: 0,0:05:29.58,0:05:37.94,Default,,0,0,0,,有趣的事情是 在空表上使用 head 会发生什么
Dialogue: 0,0:05:37.94,0:05:44.69,Default,,0,0,0,,这种情况下会返回 undefined 或者抛出异常（exception）
Dialogue: 0,0:05:44.69,0:05:54.47,Default,,0,0,0,,这没有在类型中给出 类型说的是对于任意类型 a 的列表函数将返回 a 类型的值
Dialogue: 0,0:05:54.47,0:05:58.66,Default,,0,0,0,,但这并不是完全正确的 因为给定空表
Dialogue: 0,0:05:58.66,0:06:02.63,Default,,0,0,0,,它会失败 并且无法返回一个值
Dialogue: 0,0:06:02.63,0:06:14.18,Default,,0,0,0,,第三个函数 接收一个整数返回一个函数 返回的函数接收一个列表并返回一个列表
Dialogue: 0,0:06:14.18,0:06:20.74,Default,,0,0,0,,记住 带箭头的类型中 结合性是向右的
Dialogue: 0,0:06:20.74,0:06:27.78,Default,,0,0,0,,如果加上括号的话 应该是 Int -> ([a] -> [a])
Dialogue: 0,0:06:27.78,0:06:38.50,Default,,0,0,0,,take 接收一个数 再接收一个列表 取出前 n 个元素 作为返回的列表
Dialogue: 0,0:06:38.51,0:06:47.93,Default,,0,0,0,,下面的 zip 函数接收两个列表 返回一个元素对列表
Dialogue: 0,0:06:47.93,0:06:58.05,Default,,0,0,0,,它工作的方式是别收两个列表 分别将其元素结对
Dialogue: 0,0:06:58.05,0:07:06.12,Default,,0,0,0,,当不用柯里化时 zip 的类型更清晰一点
Dialogue: 0,0:07:06.12,0:07:13.22,Default,,0,0,0,,它的类型成了 ([a], [b]) -> [(a, b)]
Dialogue: 0,0:07:13.22,0:07:26.55,Default,,0,0,0,,从中可以看出 zip 将两个列表扭到一起了
Dialogue: 0,0:07:26.55,0:07:32.69,Default,,0,0,0,,最后一个函数可能时 Haskell 中最简单的函数了 恒等函数 id
Dialogue: 0,0:07:32.69,0:07:37.05,Default,,0,0,0,,对于任意类型 a 它接收一个 a 类型的值 返回一个 a 类型的值
Dialogue: 0,0:07:37.05,0:07:46.11,Default,,0,0,0,,稍加思考就会发现 这个函数只能直接返回参数值
Dialogue: 0,0:07:46.11,0:07:53.28,Default,,0,0,0,,否则很难对任意类型 a 进行处理
Dialogue: 0,0:07:53.28,0:08:07.38,Default,,0,0,0,,恒等函数 id 也就是对任意 a : a -> a 它能做的唯一事情就是立刻返回参数
Dialogue: 0,0:08:07.38,0:08:15.28,Default,,0,0,0,,如果你对观察类型就可以得到实现方面的信息这件事很感兴趣的话
Dialogue: 0,0:08:15.28,0:08:18.53,Default,,0,0,0,,可以读 Philip Wadler 的论文 Theorems for Free （免费定理）
Dialogue: 0,0:08:18.53,0:08:29.41,Default,,0,0,0,,论文中会解释 每一个多态类型 都会给出一个对该函数成立的定理
Dialogue: 0,0:08:29.41,0:08:40.56,Default,,0,0,0,,这一话题深入 如果想要读的话 课程网站上会有到那篇论文的链接
Dialogue: 0,0:08:40.56,0:08:47.41,Default,,0,0,0,,最后一个函数相关的话题是重载（overload）
Dialogue: 0,0:08:47.41,0:08:51.04,Default,,0,0,0,,函数重载应该众所周知了 很多语言都支持
Dialogue: 0,0:08:51.04,0:08:58.43,Default,,0,0,0,,比如 Java 中可以使用不同的参数类型重载函数
Dialogue: 0,0:08:58.43,0:09:02.57,Default,,0,0,0,,我可以定义函数 foo 接收一个整数
Dialogue: 0,0:09:02.57,0:09:07.23,Default,,0,0,0,,接下来可以重载它让它接受布尔值
Dialogue: 0,0:09:07.23,0:09:11.80,Default,,0,0,0,,还可以让它重载接收一个列表
Dialogue: 0,0:09:11.80,0:09:15.93,Default,,0,0,0,,注意到函数的名字不变 但参数的类型不同
Dialogue: 0,0:09:15.93,0:09:24.40,Default,,0,0,0,,但在 Haskell 中 重载的形式有所不同
Dialogue: 0,0:09:24.40,0:09:31.87,Default,,0,0,0,,它对应于面向对象编程语言中的接口（interface）
Dialogue: 0,0:09:31.87,0:09:39.97,Default,,0,0,0,,在 Haskell 中重载函数的意思和面向对象中的重载完全不同
Dialogue: 0,0:09:39.97,0:09:55.42,Default,,0,0,0,,它的意思是限制参数的类型 比如要对列表求和的话
Dialogue: 0,0:09:55.42,0:10:06.32,Default,,0,0,0,,不能将 sum 的类型写成 [a] -> a 因为假如是字符的列表就不能求和了
Dialogue: 0,0:10:06.32,0:10:17.15,Default,,0,0,0,,也许你会说可以定义对字符的求和 但对元组列表进行求和呢
Dialogue: 0,0:10:17.15,0:10:26.24,Default,,0,0,0,,这种情况下 对 (a, b) 类型的列表的和 不应该返回 (a, b) 这很不合理
Dialogue: 0,0:10:26.24,0:10:33.58,Default,,0,0,0,,我们想要的是将列表元素的类型限制在能求和的类型上
Dialogue: 0,0:10:33.58,0:10:36.72,Default,,0,0,0,,这就是 Haskell 重载的用处
Dialogue: 0,0:10:36.72,0:10:47.96,Default,,0,0,0,,sum 的类型是 Num a => [a] -> a
Dialogue: 0,0:10:47.96,0:10:54.43,Default,,0,0,0,,意思是 sum 并不是接收任何类型 a 的列表
Dialogue: 0,0:10:54.43,0:11:01.68,Default,,0,0,0,,而只接受类型类 Num 中的类型 a
Dialogue: 0,0:11:01.68,0:11:12.29,Default,,0,0,0,,如果用面向对象的说法的话 就是实现了 Num 接口的类型 a 的列表
Dialogue: 0,0:11:12.29,0:11:20.81,Default,,0,0,0,,记号是 Num a =>
Dialogue: 0,0:11:20.81,0:11:28.95,Default,,0,0,0,,如果你是 Java C# PHP 或者 C++ 程序员的话
Dialogue: 0,0:11:28.95,0:11:32.88,Default,,0,0,0,,你可以把它想象成限制函数可以使用的值
Dialogue: 0,0:11:32.88,0:11:46.81,Default,,0,0,0,,Java 中可以做同样的事 对一个泛型函数可以限制参数需要实现特定的接口
Dialogue: 0,0:11:46.81,0:11:52.16,Default,,0,0,0,,C# 和大多数语言中都可以 Haskell 也不例外
Dialogue: 0,0:11:52.16,0:12:10.93,Default,,0,0,0,,sum 接收一个列表 返回一个值 但只有当列表中的值支持 Num 类型类 或者说 Num 接口时才可以做到 
Dialogue: 0,0:12:10.93,0:12:18.06,Default,,0,0,0,,这个例子是整数上的 sum 这里 a 是 Int
Dialogue: 0,0:12:18.06,0:12:21.63,Default,,0,0,0,,我们知道整数是数
Dialogue: 0,0:12:21.63,0:12:25.68,Default,,0,0,0,,因此没有问题 之后会看到 Num 类型类到底是什么
Dialogue: 0,0:12:25.68,0:12:28.43,Default,,0,0,0,,基本上就是可以做加法和乘法等等
Dialogue: 0,0:12:28.43,0:12:32.86,Default,,0,0,0,,第二个例子是浮点数列表的求和
Dialogue: 0,0:12:32.86,0:12:36.88,Default,,0,0,0,,同样也可以进行
Dialogue: 0,0:12:36.88,0:12:40.07,Default,,0,0,0,,最后一个例子中会出现类型错误
Dialogue: 0,0:12:40.07,0:12:43.75,Default,,0,0,0,,因为给定的是字符的列表
Dialogue: 0,0:12:43.75,0:12:47.30,Default,,0,0,0,,而字符不支持 Num 接口
Dialogue: 0,0:12:47.30,0:12:55.69,Default,,0,0,0,,用 Haskell 的话来说就是 字符类型不在 Num 类型类中
Dialogue: 0,0:12:55.69,0:13:00.37,Default,,0,0,0,,除了 Num 以外 Haskell 还有很多类型类 也可以自定义类型类
Dialogue: 0,0:13:00.37,0:13:02.26,Default,,0,0,0,,之后会看到如何定义
Dialogue: 0,0:13:02.26,0:13:07.86,Default,,0,0,0,,这里 Num 类型类表明这一类型支持加法
Dialogue: 0,0:13:07.86,0:13:14.46,Default,,0,0,0,,意味着加法的类型是
Dialogue: 0,0:13:14.46,0:13:21.91,Default,,0,0,0,,接收一个 a 类型的值 返回一个函数 它接收另一个 a 类型的值 最终返回 a 类型的值
Dialogue: 0,0:13:21.91,0:13:26.29,Default,,0,0,0,,但并不是对所有类型 a 都可以
Dialogue: 0,0:13:26.29,0:13:29.58,Default,,0,0,0,,而仅仅是 Num 类型类中的类型
Dialogue: 0,0:13:29.58,0:13:37.08,Default,,0,0,0,,当想要比较两个值是否相等时 它们需要在 Eq 类型类中
Dialogue: 0,0:13:37.08,0:13:43.82,Default,,0,0,0,,可以看到等号操作符的类型是 Eq a => a -> a -> Bool
Dialogue: 0,0:13:43.82,0:13:50.51,Default,,0,0,0,,最后是可以比较大小的值
Dialogue: 0,0:13:50.51,0:13:57.95,Default,,0,0,0,,也就是有序关系的类型 小于操作符的类型是 Ord a => a -> a -> Bool
Dialogue: 0,0:13:57.95,0:14:12.88,Default,,0,0,0,,这里是一些练习 你可以在课程网站上完成 我不会现在给出答案
Dialogue: 0,0:14:12.88,0:14:17.40,Default,,0,0,0,,但我会带你先看看这些练习
Dialogue: 0,0:14:17.40,0:14:31.10,Default,,0,0,0,,第一个问题是 一个由 a b c 三个字符组成的列表 其类型是什么
Dialogue: 0,0:14:31.10,0:14:34.48,Default,,0,0,0,,等等等等
Dialogue: 0,0:14:34.48,0:14:45.31,Default,,0,0,0,,请完成这些练习 因为它们会确保你理解了课程中的概念
Dialogue: 0,0:14:45.31,0:14:52.52,Default,,0,0,0,,还有一些比较复杂的练习
Dialogue: 0,0:14:52.52,0:14:56.38,Default,,0,0,0,,其中没有具体的值 需要计算得到类型
Dialogue: 0,0:14:56.38,0:15:03.64,Default,,0,0,0,,也就是给定一个函数 计算函数的类型
Dialogue: 0,0:15:03.64,0:15:10.32,Default,,0,0,0,,有一个技巧 也就是我想告诉你的秘密
Dialogue: 0,0:15:10.32,0:15:20.42,Default,,0,0,0,,可以使用 GHCi 来检查你的答案 做练习时不用一个一个尝试
Dialogue: 0,0:15:20.42,0:15:27.47,Default,,0,0,0,,你可以打开 GHCi 使用 :type 命令完成练习
Dialogue: 0,0:15:27.47,0:15:34.75,Default,,0,0,0,,就能确保完全正确了
Dialogue: 0,0:15:34.75,0:15:51.84,Default,,0,0,0,,祝你 Hacking 愉快 用 GHCi 来做练习 如果你不用 Haskell 而是其他语言的话 也记得用编译器检查类型
Dialogue: 0,0:15:51.84,0:15:55.60,Default,,0,0,0,,因为我们人类不应该做类型检查
Dialogue: 0,0:15:55.60,0:15:58.74,Default,,0,0,0,,那是应该由计算机来帮我们做的
Dialogue: 0,0:15:58.74,0:16:01.23,Default,,0,0,0,,十分感谢 下周再见
