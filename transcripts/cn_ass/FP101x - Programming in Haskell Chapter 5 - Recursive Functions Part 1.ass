[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: None

[Aegisub Project Garbage]
Scroll Position: 9
Active Line: 32

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,Arial,20,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,2,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:00.95,0:00:06.67,Default,,0,0,0,,欢迎来到新的一期FP101x
Dialogue: 0,0:00:06.67,0:00:10.70,Default,,0,0,0,,今天讲的是递归函数（recursive function）
Dialogue: 0,0:00:10.70,0:00:13.90,Default,,0,0,0,,什么是递归
Dialogue: 0,0:00:13.90,0:00:20.13,Default,,0,0,0,,这有一堆托盘 还有我最喜欢的水果 现在你们知道我喜欢香蕉了
Dialogue: 0,0:00:20.13,0:00:29.07,Default,,0,0,0,,我要吃这些香蕉 如果用递归的方式来的话
Dialogue: 0,0:00:29.07,0:00:32.91,Default,,0,0,0,,首先要吃第一根香蕉 哦
Dialogue: 0,0:00:32.91,0:00:36.50,Default,,0,0,0,,在那之前 我必须先吃下一根香蕉
Dialogue: 0,0:00:36.50,0:00:39.95,Default,,0,0,0,,哦 我先把这根香蕉
Dialogue: 0,0:00:39.95,0:00:43.44,Default,,0,0,0,,放在这个托盘上 接下来我要吃
Dialogue: 0,0:00:43.44,0:00:49.39,Default,,0,0,0,,下一根香蕉 哎呀要吃这么多香蕉
Dialogue: 0,0:00:49.39,0:00:52.52,Default,,0,0,0,,这一堆栈（stack）越来越大 再下一根香蕉
Dialogue: 0,0:00:52.52,0:00:56.71,Default,,0,0,0,,到了最后一根香蕉了
Dialogue: 0,0:00:56.71,0:01:05.04,Default,,0,0,0,,把它放到堆里 看这一堆香蕉多漂亮
Dialogue: 0,0:01:05.04,0:01:09.43,Default,,0,0,0,,注意这种做法的问题在于
Dialogue: 0,0:01:09.43,0:01:12.60,Default,,0,0,0,,我们建立了一个大的香蕉堆栈
Dialogue: 0,0:01:12.60,0:01:17.81,Default,,0,0,0,,如果香蕉太多的话 就会栈溢出（overflow）
Dialogue: 0,0:01:17.81,0:01:28.35,Default,,0,0,0,,一种更好的方法是不用等下一根吃完了就开始吃第一根
Dialogue: 0,0:01:28.35,0:01:38.50,Default,,0,0,0,,这样只需要一个托盘就可以吃完所有的香蕉了
Dialogue: 0,0:01:38.50,0:01:42.52,Default,,0,0,0,,这叫做尾调用消除（tail call elimination）
Dialogue: 0,0:01:42.52,0:01:50.52,Default,,0,0,0,,尾调用消除是使用递归时的一个重要的定义控制结构的概念
Dialogue: 0,0:01:50.52,0:01:58.57,Default,,0,0,0,,过程式语言中通常没有尾调用消除
Dialogue: 0,0:01:58.57,0:02:03.07,Default,,0,0,0,,因此需要特殊的控制结构
Dialogue: 0,0:02:03.07,0:02:12.51,Default,,0,0,0,,但在 Haskell 中 我们可以安全地使用递归来定义控制结构
Dialogue: 0,0:02:12.51,0:02:16.62,Default,,0,0,0,,因为不会产生这么大一堆没吃的香蕉
Dialogue: 0,0:02:16.62,0:02:21.62,Default,,0,0,0,,很好 让我们看点代码吧
Dialogue: 0,0:02:21.62,0:02:26.19,Default,,0,0,0,,我觉得这些香蕉够吃一年了
Dialogue: 0,0:02:26.19,0:02:40.22,Default,,0,0,0,,Haskell 程序员喜欢递归 是因为它是一种很自然的定义函数的方式
Dialogue: 0,0:02:40.22,0:02:43.90,Default,,0,0,0,,例如要定义
Dialogue: 0,0:02:43.90,0:02:48.29,Default,,0,0,0,,阶乘（factorial）函数 之前也见过
Dialogue: 0,0:02:48.29,0:02:52.63,Default,,0,0,0,,取 1 到 n 之间值的列表
Dialogue: 0,0:02:52.63,0:02:59.21,Default,,0,0,0,,再把它们乘到一起 比如求值
Dialogue: 0,0:02:59.21,0:03:03.62,Default,,0,0,0,,4 的阶乘 把定义展开
Dialogue: 0,0:03:03.62,0:03:10.62,Default,,0,0,0,,也就是 1 到 4 的乘积 这是 1 到 4 的列表 也就是 [1,2,3,4] 的乘积
Dialogue: 0,0:03:10.67,0:03:16.83,Default,,0,0,0,,最终的积就是把这些数都乘起来
Dialogue: 0,0:03:16.83,0:03:20.08,Default,,0,0,0,,[1, 2, 3, 4] 的乘积
Dialogue: 0,0:03:20.08,0:03:23.26,Default,,0,0,0,,就是 1*2*3*4
Dialogue: 0,0:03:23.26,0:03:26.30,Default,,0,0,0,,也就是 24
Dialogue: 0,0:03:26.30,0:03:33.52,Default,,0,0,0,,下面是用递归的方式定义阶乘
Dialogue: 0,0:03:33.52,0:03:37.80,Default,,0,0,0,,我们已经看过如何定义列表的递归函数
Dialogue: 0,0:03:37.80,0:03:40.85,Default,,0,0,0,,取列表 检查是否为空表
Dialogue: 0,0:03:40.85,0:03:45.02,Default,,0,0,0,,还是一个头元素（head）接一个尾列表（tail）
Dialogue: 0,0:03:45.02,0:03:51.88,Default,,0,0,0,,某种程度上 数字上的递归函数也是一样
Dialogue: 0,0:03:51.88,0:03:56.62,Default,,0,0,0,,要考虑两种情况 一是当数字为 0 时
Dialogue: 0,0:03:56.62,0:03:59.84,Default,,0,0,0,,另一种情况是数字为 n
Dialogue: 0,0:03:59.84,0:04:07.49,Default,,0,0,0,,在第二种情况下 就在 n-1 上进行递归 
Dialogue: 0,0:04:07.49,0:04:10.74,Default,,0,0,0,,之前版本的 Haskell 中有一种叫做 n+k 的模式
Dialogue: 0,0:04:10.74,0:04:14.34,Default,,0,0,0,,你可以定义为 0 时的阶乘
Dialogue: 0,0:04:14.34,0:04:17.68,Default,,0,0,0,,还有 n+1 时的阶乘
Dialogue: 0,0:04:17.68,0:04:21.60,Default,,0,0,0,,但 n+k 模式已经弃置不用了
Dialogue: 0,0:04:21.60,0:04:25.18,Default,,0,0,0,,现在只能用这种形式写了
Dialogue: 0,0:04:25.18,0:04:36.90,Default,,0,0,0,,但除了这个小细节之外 可以看出和在列表上的递归很像
Dialogue: 0,0:04:36.90,0:04:43.94,Default,,0,0,0,,两种情况 0 和 n 0的时候结果是 1
Dialogue: 0,0:04:43.94,0:04:47.53,Default,,0,0,0,,否则先取 n-1 的阶乘 再乘上 n
Dialogue: 0,0:04:47.53,0:04:56.43,Default,,0,0,0,,如果对这种形式的阶乘求值 就会发现堆栈
Dialogue: 0,0:04:56.43,0:05:01.05,Default,,0,0,0,,变得像香蕉一样 这是因为
Dialogue: 0,0:05:01.05,0:05:08.03,Default,,0,0,0,,阶乘会首先不断进入右边的调用 等一切都执行完
Dialogue: 0,0:05:08.03,0:05:12.27,Default,,0,0,0,,再乘回来
Dialogue: 0,0:05:12.27,0:05:15.50,Default,,0,0,0,,从栈中弹出 得到结果 6
Dialogue: 0,0:05:15.50,0:05:18.81,Default,,0,0,0,,好了
Dialogue: 0,0:05:18.81,0:05:25.06,Default,,0,0,0,,我们给出的阶乘递归定义
Dialogue: 0,0:05:25.06,0:05:33.86,Default,,0,0,0,,可能会停不下来 用术语来说就是 对小于 0 的数字发散（diverge）
Dialogue: 0,0:05:33.86,0:05:42.11,Default,,0,0,0,,让我们回去看看
Dialogue: 0,0:05:42.11,0:05:45.53,Default,,0,0,0,,如果 n 小于 0
Dialogue: 0,0:05:45.53,0:05:52.09,Default,,0,0,0,,那么不符合这种情况 因此将 n 与 n-1 的阶乘相乘
Dialogue: 0,0:05:52.09,0:05:57.09,Default,,0,0,0,,参数比 0 更小了 依此类推 永远不会停下
Dialogue: 0,0:05:57.09,0:06:04.09,Default,,0,0,0,,最终会造成栈溢出
Dialogue: 0,0:06:05.11,0:06:15.74,Default,,0,0,0,,像阶乘这样的有些函数 可以递归定义 或用其他函数定义
Dialogue: 0,0:06:15.74,0:06:19.37,Default,,0,0,0,,无论是用递归方式定义
Dialogue: 0,0:06:19.37,0:06:22.87,Default,,0,0,0,,还是使用其他函数定义
Dialogue: 0,0:06:22.87,0:06:28.71,Default,,0,0,0,,又或者把递归的模式抽象成高阶函数（higher-order function）
Dialogue: 0,0:06:28.71,0:06:32.57,Default,,0,0,0,,再用它来定义 其实只是品味问题
Dialogue: 0,0:06:32.57,0:06:42.51,Default,,0,0,0,,最终 作为一个开发者要决定的是 怎样最方便其他开发者阅读 对吧
Dialogue: 0,0:06:42.51,0:06:48.02,Default,,0,0,0,,因此是否要用递归这个问题 没有一个明确的答案
Dialogue: 0,0:06:48.02,0:06:51.07,Default,,0,0,0,,代码越简洁越好
Dialogue: 0,0:06:51.07,0:06:55.49,Default,,0,0,0,,但使用递归的一个好处是
Dialogue: 0,0:06:55.49,0:07:03.13,Default,,0,0,0,,可以递推（induction）证明程序的性质
Dialogue: 0,0:07:03.13,0:07:06.89,Default,,0,0,0,,让我们再看一个递归定义函数的例子
Dialogue: 0,0:07:06.89,0:07:14.54,Default,,0,0,0,,之前定义阶乘时用到的乘积（product）函数
Dialogue: 0,0:07:14.54,0:07:23.31,Default,,0,0,0,,让我们用列表上的递归来定义 这样结构完全相同
Dialogue: 0,0:07:23.31,0:07:26.72,Default,,0,0,0,,有两种情况要考虑 要么是空列表
Dialogue: 0,0:07:26.72,0:07:29.96,Default,,0,0,0,,要么是 n 连接着（cons） ns
Dialogue: 0,0:07:29.96,0:07:34.36,Default,,0,0,0,,对照着列表的递归结构
Dialogue: 0,0:07:34.36,0:07:39.18,Default,,0,0,0,,再将函数定义在递归的结构上
Dialogue: 0,0:07:39.18,0:07:43.06,Default,,0,0,0,,这和数字是一样的 首先对照数字的递归结构
Dialogue: 0,0:07:43.06,0:07:46.89,Default,,0,0,0,,再根据那种结构定义函数
Dialogue: 0,0:07:46.89,0:07:50.69,Default,,0,0,0,,回到这里 如果要计算空表的乘积
Dialogue: 0,0:07:50.69,0:07:54.86,Default,,0,0,0,,结果就是 1
Dialogue: 0,0:07:54.86,0:07:59.29,Default,,0,0,0,,如果要对元素 n 和列表 ns 计算乘积
Dialogue: 0,0:07:59.29,0:08:06.34,Default,,0,0,0,,该怎么做 首先取余下列表的乘积 再乘上 n
Dialogue: 0,0:08:06.34,0:08:13.34,Default,,0,0,0,,因此这是个很简单的用递归定义函数的方式
Dialogue: 0,0:08:13.34,0:08:20.37,Default,,0,0,0,,当然 我们也可以取这个函数
Dialogue: 0,0:08:20.37,0:08:24.78,Default,,0,0,0,,将其模式抽象成一个高阶函数 只处理递归
Dialogue: 0,0:08:24.78,0:08:31.08,Default,,0,0,0,,然后可以放入乘法和 1 就行
Dialogue: 0,0:08:31.08,0:08:39.08,Default,,0,0,0,,如果执行乘积函数 展开列表定义 2 连接 3 和 4
Dialogue: 0,0:08:39.08,0:08:41.86,Default,,0,0,0,,再展开乘积的定义 得到
Dialogue: 0,0:08:41.86,0:08:45.49,Default,,0,0,0,,2 乘上 [3, 4] 的乘积 如此反复几次
Dialogue: 0,0:08:45.49,0:08:49.16,Default,,0,0,0,,直到这一步
Dialogue: 0,0:08:49.16,0:08:53.22,Default,,0,0,0,,最后从栈中弹出 得到结果 24
Dialogue: 0,0:08:53.22,0:09:00.85,Default,,0,0,0,,可以看到答案和阶乘的递归定义完全相同
Dialogue: 0,0:09:00.85,0:09:09.17,Default,,0,0,0,,唯一的区别就是 这里的递归隐藏在乘积函数里
Dialogue: 0,0:09:09.17,0:09:13.31,Default,,0,0,0,,如果计算 1 到 n 的乘积 事实上
Dialogue: 0,0:09:13.31,0:09:17.32,Default,,0,0,0,,是在用递归定义函数 并且可以说明
Dialogue: 0,0:09:17.32,0:09:30.17,Default,,0,0,0,,把两个函数合并到一起时 一个创建从 1 到 n 的列表 另一个是乘积函数 得到的和阶乘的递归定义一样
Dialogue: 0,0:09:30.17,0:09:37.68,Default,,0,0,0,,再看一个可以递归定义在列表上的函数
Dialogue: 0,0:09:37.68,0:09:41.01,Default,,0,0,0,,可以再次看到递归结构
Dialogue: 0,0:09:41.01,0:09:49.36,Default,,0,0,0,,如果列表是空的 空列表的长度是 0
Dialogue: 0,0:09:49.36,0:09:52.44,Default,,0,0,0,,如果表不是空的 我们不关心
Dialogue: 0,0:09:52.44,0:09:57.37,Default,,0,0,0,,第一个元素具体是什么 直接计算其余列表的长度
Dialogue: 0,0:09:57.37,0:10:01.74,Default,,0,0,0,,再加上 1 就好了 十分明显
Dialogue: 0,0:10:01.74,0:10:05.31,Default,,0,0,0,,同样可以看到 它遵循了列表递归的结构
Dialogue: 0,0:10:05.31,0:10:08.48,Default,,0,0,0,,因此基本上是按列表结构递推定义的
Dialogue: 0,0:10:08.48,0:10:14.07,Default,,0,0,0,,计算 [1, 2, 3] 的长度
Dialogue: 0,0:10:14.07,0:10:18.48,Default,,0,0,0,,也就是 1 + [2, 3] 的长度 展开 展开 再展开
Dialogue: 0,0:10:18.48,0:10:21.60,Default,,0,0,0,,直到这里 再把它们加到一起
Dialogue: 0,0:10:21.60,0:10:27.61,Default,,0,0,0,,就得到了预期的结果 3 再看另一个函数
Dialogue: 0,0:10:27.61,0:10:30.80,Default,,0,0,0,,反转列表（reverse） 对空列表来说
Dialogue: 0,0:10:30.80,0:10:33.87,Default,,0,0,0,,反转空列表得到的还是空列表
Dialogue: 0,0:10:33.87,0:10:38.92,Default,,0,0,0,,如果想要反转 (x:xs)
Dialogue: 0,0:10:38.92,0:10:42.19,Default,,0,0,0,,只需要把 x 放到另外一边就行
Dialogue: 0,0:10:42.19,0:10:45.89,Default,,0,0,0,,如果像这样执行
Dialogue: 0,0:10:45.89,0:10:53.38,Default,,0,0,0,,可以看到元素变成了从右向左连接的
Dialogue: 0,0:10:53.38,0:10:56.45,Default,,0,0,0,,因此列表反转了
Dialogue: 0,0:10:56.45,0:10:59.63,Default,,0,0,0,,[1, 2, 3] 变成了 [3, 2, 1]
Dialogue: 0,0:10:59.63,0:11:09.99,Default,,0,0,0,,当然也可以定义不只在一个参数上递归 而是在多个参数上递归的函数
Dialogue: 0,0:11:09.99,0:11:13.05,Default,,0,0,0,,上一章介绍过 zip （拉链）函数
Dialogue: 0,0:11:13.05,0:11:16.98,Default,,0,0,0,,如何定义 zip 呢 zip 接收两个列表
Dialogue: 0,0:11:16.98,0:11:21.47,Default,,0,0,0,,它取两个列表中的元素 将它们结合成一对
Dialogue: 0,0:11:21.47,0:11:30.45,Default,,0,0,0,,最简单的情况是最后一种 如果有两个非空列表
Dialogue: 0,0:11:30.45,0:11:34.76,Default,,0,0,0,,取两个的头元素（head） 结合成一对
Dialogue: 0,0:11:34.76,0:11:39.37,Default,,0,0,0,,再递归地 zip 剩下的列表 什么时候停下呢
Dialogue: 0,0:11:39.37,0:11:43.07,Default,,0,0,0,,两个列表中只要有一个空了 就停下了
Dialogue: 0,0:11:43.07,0:11:46.08,Default,,0,0,0,,此时返回空表
Dialogue: 0,0:11:46.08,0:11:53.34,Default,,0,0,0,,当然我们需要把这两种情况放在前面 因为有个通配符（wild card）模式
Dialogue: 0,0:11:53.34,0:11:57.36,Default,,0,0,0,,否则就不对了
Dialogue: 0,0:11:57.36,0:12:00.37,Default,,0,0,0,,很好
Dialogue: 0,0:12:00.37,0:12:04.16,Default,,0,0,0,,再看几个函数
Dialogue: 0,0:12:04.16,0:12:07.85,Default,,0,0,0,,drop（丢弃）接收一个整数和一个列表
Dialogue: 0,0:12:07.85,0:12:20.18,Default,,0,0,0,,最终返回一个列表 它既在数字上递归 又在列表上递归
Dialogue: 0,0:12:20.18,0:12:24.46,Default,,0,0,0,,如果想从列表中丢弃 0 个元素
Dialogue: 0,0:12:24.46,0:12:29.32,Default,,0,0,0,,结果和原列表一样 当列表为空时
Dialogue: 0,0:12:29.32,0:12:36.25,Default,,0,0,0,,那丢弃多少元素都可以 只不过没什么作用 因此直接返回空列表
Dialogue: 0,0:12:36.25,0:12:40.20,Default,,0,0,0,,最后同时在列表和数字上递归
Dialogue: 0,0:12:40.20,0:12:47.29,Default,,0,0,0,,同样 因为没有 n+k 模式 右手边要用 n-1
Dialogue: 0,0:12:47.29,0:12:55.04,Default,,0,0,0,,因此从无论什么元素连接 xs  的列表中丢弃 n 个元素 得到的就是从 xs 中丢弃 n-1 个元素
Dialogue: 0,0:12:55.04,0:13:00.86,Default,,0,0,0,,因此这里既在数字上递归 又在列表的结构上递归了
Dialogue: 0,0:13:00.86,0:13:07.04,Default,,0,0,0,,课件上的最后一个例子是接续（append）两个列表
Dialogue: 0,0:13:07.04,0:13:11.48,Default,,0,0,0,,如果把一个空表接到另一个表上 结果和原来那个列表一样
Dialogue: 0,0:13:11.48,0:13:19.99,Default,,0,0,0,,如果想将 (x:xs) 的列表接到 ys 这个列表上时 首先将 xs 和 ys 接续到一起
Dialogue: 0,0:13:19.99,0:13:24.19,Default,,0,0,0,,再在前面连接（cons） x 十分显而易见
Dialogue: 0,0:13:24.19,0:13:28.61,Default,,0,0,0,,非常感谢 第二部分再见
