[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: None

[Aegisub Project Garbage]
Scroll Position: 63
Active Line: 84

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,Arial,20,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,2,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:01.03,0:00:04.99,Default,,0,0,0,,欢迎回到列表解析的课程
Dialogue: 0,0:00:04.99,0:00:11.75,Default,,0,0,0,,第二部分要讲的是
Dialogue: 0,0:00:11.75,0:00:18.91,Default,,0,0,0,,一个可以合并两个列表的函数 zip （拉链）
Dialogue: 0,0:00:18.91,0:00:23.64,Default,,0,0,0,,下面是 zip 的签名
Dialogue: 0,0:00:23.64,0:00:29.97,Default,,0,0,0,,zip 的类型是从 a 的列表到 b 的列表 到 (a,b) 对的列表
Dialogue: 0,0:00:29.97,0:00:34.73,Default,,0,0,0,,下面是一个合并两个列表的例子
Dialogue: 0,0:00:34.73,0:00:41.21,Default,,0,0,0,,从中可以看出为什么这个函数称为 zip 它接收两个列表
Dialogue: 0,0:00:41.21,0:00:44.98,Default,,0,0,0,,从中各取一个值 合成一对
Dialogue: 0,0:00:44.98,0:00:48.57,Default,,0,0,0,,[a,b,c] 和 [1,2,3,4] 的 zip 结果是
Dialogue: 0,0:00:48.57,0:00:51.57,Default,,0,0,0,,[(a,1), (b,2), (c,3)]
Dialogue: 0,0:00:51.57,0:00:55.69,Default,,0,0,0,,一旦其中一个列表的值用尽
Dialogue: 0,0:00:55.69,0:01:00.89,Default,,0,0,0,,zip 函数就停止 右侧列表有四个元素
Dialogue: 0,0:01:00.89,0:01:05.85,Default,,0,0,0,,左侧列表只有三个元素 结果列表
Dialogue: 0,0:01:05.85,0:01:10.67,Default,,0,0,0,,有三个元素 正如之前提到过的
Dialogue: 0,0:01:10.67,0:01:13.86,Default,,0,0,0,,我认为 zip 函数的签名
Dialogue: 0,0:01:13.86,0:01:17.99,Default,,0,0,0,,如果没有被柯里化（curried）会好一点
Dialogue: 0,0:01:17.99,0:01:21.14,Default,,0,0,0,,从 a 的列表与 b 的列表的一对
Dialogue: 0,0:01:21.14,0:01:24.24,Default,,0,0,0,,到 (a,b) 对的列表
Dialogue: 0,0:01:24.24,0:01:30.49,Default,,0,0,0,,但 zip 在 Haskell 标准库中是这么定义的
Dialogue: 0,0:01:30.49,0:01:37.88,Default,,0,0,0,,使用 zip 可以定义下列函数
Dialogue: 0,0:01:37.88,0:01:46.22,Default,,0,0,0,,给定一个列表 返回相邻两个元素对组成的列表
Dialogue: 0,0:01:46.22,0:01:50.25,Default,,0,0,0,,在看实现之前 让我们先看一个例子
Dialogue: 0,0:01:50.25,0:01:52.46,Default,,0,0,0,,我认为看了例子后 实现也就很简单了
Dialogue: 0,0:01:52.46,0:02:05.78,Default,,0,0,0,,想要做的是 给定列表 [1, 2, 3, 4] 要创建一个元素对的链条 像一个像滑动窗口一样 [(1, 2), (2, 3), (3, 4)]
Dialogue: 0,0:02:05.78,0:02:14.01,Default,,0,0,0,,可以看到相邻的两个元素被链到了一起 (1, 2) (2, 3) 之后是 (2, 3), (3, 4)
Dialogue: 0,0:02:14.01,0:02:27.26,Default,,0,0,0,,其实现是一个使用 zip 的很好的例子
Dialogue: 0,0:02:27.26,0:02:30.68,Default,,0,0,0,,要做的是取这个列表 [1, 2, 3, 4]
Dialogue: 0,0:02:30.68,0:02:34.62,Default,,0,0,0,,再取这个列表的 tail
Dialogue: 0,0:02:34.62,0:02:38.65,Default,,0,0,0,,[2, 3, 4] 再两个列表 zip 到一起
Dialogue: 0,0:02:38.65,0:02:43.34,Default,,0,0,0,,结果就是 因为第一个列表是 [1, 2, 3, 4]
Dialogue: 0,0:02:43.34,0:02:47.65,Default,,0,0,0,,第二个列表是 [2, 3, 4] zip 到一起就是 (2, 3)
Dialogue: 0,0:02:47.65,0:02:52.10,Default,,0,0,0,,之后下一个 zip 到一起 抱歉前一个应该是 (1, 2)
Dialogue: 0,0:02:52.10,0:02:55.73,Default,,0,0,0,,下一个是 (2, 3) 再下一个是 (3, 4)
Dialogue: 0,0:02:55.73,0:02:59.06,Default,,0,0,0,,如果画图表示的话
Dialogue: 0,0:02:59.06,0:03:02.98,Default,,0,0,0,,首先是原来的列表 接着去掉第一个元素
Dialogue: 0,0:03:02.98,0:03:06.56,Default,,0,0,0,,其余元素向前移一位 接下来把两个列表 zip 到一起
Dialogue: 0,0:03:06.56,0:03:11.04,Default,,0,0,0,,最终结果就会如此
Dialogue: 0,0:03:11.04,0:03:22.29,Default,,0,0,0,,这是另一个函数 用 pairs 函数检查列表是否排好了序
Dialogue: 0,0:03:22.29,0:03:25.97,Default,,0,0,0,,要做的是取列表中的相邻元素对
Dialogue: 0,0:03:25.97,0:03:29.43,Default,,0,0,0,,也就是许多 (x, y) 对
Dialogue: 0,0:03:29.43,0:03:34.00,Default,,0,0,0,,我们检查第一个元素是否比第二个元素小
Dialogue: 0,0:03:34.00,0:03:43.81,Default,,0,0,0,,如果每一个相邻对中 第一个都比第二个小 列表就是有序的
Dialogue: 0,0:03:43.81,0:03:49.35,Default,,0,0,0,,这种检查有序的方法十分简洁 看一些例子
Dialogue: 0,0:03:49.35,0:03:53.12,Default,,0,0,0,,列表 [1, 2, 3, 4] 是有序的吗 的确如此
Dialogue: 0,0:03:53.12,0:03:58.00,Default,,0,0,0,,因为 (1, 2) 中 1 小于 2 下一个元素对是 (2, 3)
Dialogue: 0,0:03:58.00,0:04:02.66,Default,,0,0,0,,2 同样小于 3 最后一个元素对是 (3, 4)
Dialogue: 0,0:04:02.66,0:04:05.90,Default,,0,0,0,,3 小于 4 因此整个列表有序
Dialogue: 0,0:04:05.90,0:04:10.18,Default,,0,0,0,,列表 [1, 3, 2, 4] 是有序的吗
Dialogue: 0,0:04:10.18,0:04:16.43,Default,,0,0,0,,不 因为元素对列表中的第二对
Dialogue: 0,0:04:16.43,0:04:22.90,Default,,0,0,0,,(3, 2) 中 3 比 2 大 因此会返回假
Dialogue: 0,0:04:22.90,0:04:33.45,Default,,0,0,0,,使用 zip 还可以定义列表中元素的位置
Dialogue: 0,0:04:33.45,0:04:41.14,Default,,0,0,0,,之前提到 列表中没有位置
Dialogue: 0,0:04:41.14,0:04:51.24,Default,,0,0,0,,在数组中可以用下标索引 但列表中不行 只能从左向右访问元素
Dialogue: 0,0:04:51.24,0:04:58.01,Default,,0,0,0,,比如取 head 接着是 tail 的 head 再接下来是 tail 的 tail 的 head 等等
Dialogue: 0,0:04:58.01,0:05:05.65,Default,,0,0,0,,但有时给列表中的元素指定位置会方便些
Dialogue: 0,0:05:05.65,0:05:09.68,Default,,0,0,0,,这种操作很常见 实现的方法就是 zip
Dialogue: 0,0:05:09.68,0:05:13.29,Default,,0,0,0,,要做的是 取一个列表 xs
Dialogue: 0,0:05:13.29,0:05:17.50,Default,,0,0,0,,再取一个 0 到 n 的列表
Dialogue: 0,0:05:17.50,0:05:20.57,Default,,0,0,0,,其中 n 是列表的长度
Dialogue: 0,0:05:20.57,0:05:24.67,Default,,0,0,0,,但实现上可以用从 0 开始的无限长的列表
Dialogue: 0,0:05:24.67,0:05:37.95,Default,,0,0,0,,接下来只需要把列表和位置 zip 起来就可以了
Dialogue: 0,0:05:37.95,0:05:47.93,Default,,0,0,0,,这个 positions 的例子中 要获得所有 0 的位置
Dialogue: 0,0:05:47.93,0:05:53.27,Default,,0,0,0,,比如这里 这里还有这里 所做的是
Dialogue: 0,0:05:53.27,0:05:59.08,Default,,0,0,0,,首先将所有元素和位置 zip 起来 接下来只过滤留下那些
Dialogue: 0,0:05:59.08,0:06:02.33,Default,,0,0,0,,要寻找的元素
Dialogue: 0,0:06:02.33,0:06:05.57,Default,,0,0,0,,这里我们感兴趣的是 0 的位置
Dialogue: 0,0:06:05.57,0:06:15.31,Default,,0,0,0,,整个过程分为两步 第一步将所有元素和位置组成对
Dialogue: 0,0:06:15.31,0:06:19.84,Default,,0,0,0,,第二步 过滤 只保留我们需要的元素
Dialogue: 0,0:06:19.84,0:06:29.31,Default,,0,0,0,,Haskell 中字符串 String 不过是字符（Character/Char）列表的语法糖而已
Dialogue: 0,0:06:29.31,0:06:33.68,Default,,0,0,0,,这也意味着字符串上也可以使用列表解析
Dialogue: 0,0:06:33.68,0:06:47.02,Default,,0,0,0,,比如字符串 abc 不过是字符 a b 和 c 组成的列表 因此所有列表操作
Dialogue: 0,0:06:47.02,0:06:58.56,Default,,0,0,0,,包括解析 map 和 filter foldr 等所有列表操作都可以用在字符串上
Dialogue: 0,0:06:58.56,0:07:02.18,Default,,0,0,0,,比如字符串 abcde 的长度是 5
Dialogue: 0,0:07:02.18,0:07:09.36,Default,,0,0,0,,为何如此 因为这个字符串只不过是 5 个字符的列表
Dialogue: 0,0:07:09.36,0:07:13.29,Default,,0,0,0,,因此可以使用列表的长度函数 length 要取字符串的前三个字符
Dialogue: 0,0:07:13.29,0:07:18.78,Default,,0,0,0,,可以使用 take 3 结果是 abc
Dialogue: 0,0:07:18.78,0:07:27.05,Default,,0,0,0,,用同样的方式可以将一个字符串和列表 zip 到一起
Dialogue: 0,0:07:27.05,0:07:30.89,Default,,0,0,0,,比如将字符串 abc 和列表 [1, 2, 3, 4] zip 到一起 就得到了一个列表
Dialogue: 0,0:07:30.89,0:07:39.16,Default,,0,0,0,,元素是 (a, 1) (b, 2) 和 (c, 3) 这样的对子
Dialogue: 0,0:07:39.16,0:07:49.18,Default,,0,0,0,,很多语言中 是通过让 String 实现可遍历（Iterable）或可枚举（ Enumerator）来做到这一点的 但在 Haskell 中
Dialogue: 0,0:07:49.18,0:07:52.26,Default,,0,0,0,,字符串 String 和列表相比 没有那么多特殊之处
Dialogue: 0,0:07:52.26,0:07:56.65,Default,,0,0,0,,仅仅被定义为字符的列表
Dialogue: 0,0:07:56.65,0:08:00.24,Default,,0,0,0,,差异仅仅是多了一种字面值（literal）的写法
Dialogue: 0,0:08:00.24,0:08:04.52,Default,,0,0,0,,就好比列表的写法一样 正如之前所说的
Dialogue: 0,0:08:04.52,0:08:08.61,Default,,0,0,0,,只是 (1:(2:(3:(4:[])))) 的简略写法而已
Dialogue: 0,0:08:08.61,0:08:24.39,Default,,0,0,0,,下面是一个统计字符串中小写字母数的例子
Dialogue: 0,0:08:24.39,0:08:28.32,Default,,0,0,0,,首先给我字符串 xs 中的所有字符 x
Dialogue: 0,0:08:28.32,0:08:31.43,Default,,0,0,0,,将小写的字符过滤出来
Dialogue: 0,0:08:31.43,0:08:34.68,Default,,0,0,0,,再计算长度
Dialogue: 0,0:08:34.68,0:08:42.50,Default,,0,0,0,,比如要计算字符串 “Haskell” 中的小写字母数 可以得到 6
Dialogue: 0,0:08:42.50,0:08:49.68,Default,,0,0,0,,2 4 6 然后第一个字母是大写的
Dialogue: 0,0:08:49.68,0:08:59.16,Default,,0,0,0,,好了 希望你稍微理解一点列表解析 zip
Dialogue: 0,0:08:59.16,0:09:02.23,Default,,0,0,0,,以及字符串仅仅是字符列表
Dialogue: 0,0:09:02.23,0:09:09.65,Default,,0,0,0,,练习中用到它们的机会很多 那么下周见
Dialogue: 0,0:09:09.65,0:09:10.96,Default,,0,0,0,,再见 Hacking 愉快
