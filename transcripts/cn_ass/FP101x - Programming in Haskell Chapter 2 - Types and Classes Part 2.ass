[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: None

[Aegisub Project Garbage]
Scroll Position: 99
Active Line: 113

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,Arial,20,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,2,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:01.43,0:00:10.55,Default,,0,0,0,,欢迎回来听类型（type）与类（class）的第二讲
Dialogue: 0,0:00:10.55,0:00:18.75,Default,,0,0,0,,既然学的是函数式编程 这次讲的是函数的类型
Dialogue: 0,0:00:18.75,0:00:29.73,Default,,0,0,0,,函数 值 和类型十分重要 因为对初学者有些困难
Dialogue: 0,0:00:29.73,0:00:37.76,Default,,0,0,0,,这节课请特别注意 因为一旦错过 之后会遇到很多困难
Dialogue: 0,0:00:37.76,0:00:46.55,Default,,0,0,0,,我会慢慢讲 重复几次 因为理解这一部分十分重要
Dialogue: 0,0:00:46.55,0:00:50.96,Default,,0,0,0,,什么是函数
Dialogue: 0,0:00:50.96,0:00:58.21,Default,,0,0,0,,函数将一个类型的值映射成另一个类型的值
Dialogue: 0,0:00:58.21,0:01:01.87,Default,,0,0,0,,这是两个函数类型的简单例子
Dialogue: 0,0:01:01.87,0:01:06.86,Default,,0,0,0,,第一个是函数 not （逻辑非）接收一个布尔值
Dialogue: 0,0:01:06.86,0:01:10.03,Default,,0,0,0,,返回另一个布尔值
Dialogue: 0,0:01:10.03,0:01:13.53,Default,,0,0,0,,没什么复杂的
Dialogue: 0,0:01:13.53,0:01:16.79,Default,,0,0,0,,看第二个函数 isDigit （是否为数字）
Dialogue: 0,0:01:16.79,0:01:25.42,Default,,0,0,0,,isDigit 接收一个字符 检查是否是数字 从 0 1 2 到 9
Dialogue: 0,0:01:25.42,0:01:30.09,Default,,0,0,0,,类型是 Char （字符）到 Bool （布尔值）
Dialogue: 0,0:01:30.09,0:01:38.22,Default,,0,0,0,,含义是它从所有字符的集合中接受一个值 返回所有布尔值集合中的一个值
Dialogue: 0,0:01:38.22,0:01:48.50,Default,,0,0,0,,一般而言 从 t1 到 t2 的函数类型是 t1 -> t2
Dialogue: 0,0:01:48.50,0:01:58.36,Default,,0,0,0,,意味着它将 t1 类型的值映射到 t2 类型的值
Dialogue: 0,0:01:58.36,0:02:07.46,Default,,0,0,0,,t1 有时被叫做函数的定义域（domain）t2 叫做值域（range）
Dialogue: 0,0:02:07.46,0:02:15.15,Default,,0,0,0,,注意函数类型中的箭头 用了美观的箭头
Dialogue: 0,0:02:15.15,0:02:20.50,Default,,0,0,0,,但用键盘敲代码时
Dialogue: 0,0:02:20.50,0:02:24.48,Default,,0,0,0,,应该输入短横线（dash, -）接着一个大于号（>）
Dialogue: 0,0:02:24.48,0:02:32.90,Default,,0,0,0,,这里用漂亮的记号 但输入时不是打出一个真的箭头
Dialogue: 0,0:02:32.90,0:02:45.03,Default,,0,0,0,,定义函数时 和元组与列表一样 定义域和值域的类型不受限制
Dialogue: 0,0:02:45.03,0:02:56.04,Default,,0,0,0,,比如函数 add （求和）接收两个整数（Int）的元组作为参数 返回一个整数
Dialogue: 0,0:02:56.04,0:03:01.21,Default,,0,0,0,,add (x, y) 等于 x 加 y
Dialogue: 0,0:03:01.21,0:03:10.15,Default,,0,0,0,,注意 add 的类型 接收两个整数的元组 返回一个整数
Dialogue: 0,0:03:10.15,0:03:15.60,Default,,0,0,0,,另一个函数接收一个整数 返回一个整数的列表
Dialogue: 0,0:03:15.60,0:03:18.94,Default,,0,0,0,,完全可以这样
Dialogue: 0,0:03:18.94,0:03:27.50,Default,,0,0,0,,定义是 zeroto n （0 到 n）返回列表 [0..n] 第一节课已经见过
Dialogue: 0,0:03:27.50,0:03:35.23,Default,,0,0,0,,方括号和两个点表示从 0 到 n 的列表
Dialogue: 0,0:03:35.23,0:03:52.98,Default,,0,0,0,,注意 如果允许函数的参数与返回值的类型任意取 其类型也可能是函数
Dialogue: 0,0:03:52.98,0:03:57.11,Default,,0,0,0,,因此出现了柯里化函数（curried functions）
Dialogue: 0,0:03:57.11,0:04:00.79,Default,,0,0,0,,不将 add 定义成接受一对整数返回一个整数
Dialogue: 0,0:04:00.79,0:04:04.85,Default,,0,0,0,,Haskell 中更常见的定义是
Dialogue: 0,0:04:04.85,0:04:17.16,Default,,0,0,0,,将 add 定义成接受一个整数 返回另一个函数 它接收一个整数并最终返回一个整数
Dialogue: 0,0:04:17.16,0:04:20.97,Default,,0,0,0,,请看类型 add 是一个函数
Dialogue: 0,0:04:20.97,0:04:28.00,Default,,0,0,0,,箭头告诉我们它接收一个整数 返回一个函数
Dialogue: 0,0:04:28.00,0:04:31.88,Default,,0,0,0,,这一函数接受另一个整数 最终返回一个整数
Dialogue: 0,0:04:31.88,0:04:36.43,Default,,0,0,0,,这就是柯里化
Dialogue: 0,0:04:36.43,0:04:48.15,Default,,0,0,0,,柯里化本身并不复杂 函数和列表 整数一样 只是值 没什么特殊的
Dialogue: 0,0:04:48.15,0:04:55.72,Default,,0,0,0,,让人困惑的是 在 Haskell 中不需要在这里写括号（原文误作箭头）
Dialogue: 0,0:04:55.72,0:05:02.99,Default,,0,0,0,,因为太过常用 箭头自动向右结合
Dialogue: 0,0:05:02.99,0:05:06.08,Default,,0,0,0,,也就意味着可以把类型写成
Dialogue: 0,0:05:06.08,0:05:11.37,Default,,0,0,0,,Int -> Int -> Int 常常令初学者感到困惑
Dialogue: 0,0:05:11.37,0:05:16.52,Default,,0,0,0,,你需要学会阅读这些类型时 知道在哪里加括号
Dialogue: 0,0:05:16.52,0:05:20.59,Default,,0,0,0,,没什么特殊的地方
Dialogue: 0,0:05:20.59,0:05:25.46,Default,,0,0,0,,add 是一个函数 接收一个整数 返回一个函数
Dialogue: 0,0:05:25.46,0:05:29.52,Default,,0,0,0,,该函数接收一个整数 返回一个整数
Dialogue: 0,0:05:29.52,0:05:36.88,Default,,0,0,0,,注意 add 和 add' 返回相同的结果
Dialogue: 0,0:05:36.88,0:05:44.18,Default,,0,0,0,,但通常的 add 接收一个元组 因此同时接收两个参数
Dialogue: 0,0:05:44.18,0:05:51.19,Default,,0,0,0,,而 add' 依次接收参数
Dialogue: 0,0:05:51.19,0:05:58.30,Default,,0,0,0,,依次接收参数的函数称为 柯里化函数
Dialogue: 0,0:05:58.30,0:06:11.44,Default,,0,0,0,,发明这种依次接收参数的函数处理方式的人是哈斯凯尔·B·柯里（Haskell B. Curry）
Dialogue: 0,0:06:11.44,0:06:20.99,Default,,0,0,0,,Haskell 就是以他命名的 正如 Pascal 语言是以布莱兹·帕斯卡（Blaise Pascal）命名的
Dialogue: 0,0:06:20.99,0:06:24.50,Default,,0,0,0,,Haskell 是为了纪念哈斯凯尔·B·柯里命名的
Dialogue: 0,0:06:24.50,0:06:30.42,Default,,0,0,0,,也就是发明了函数柯里化的人
Dialogue: 0,0:06:30.42,0:06:38.36,Default,,0,0,0,,任何一个接收两个参数的函数都可以转换成依次接收参数的函数
Dialogue: 0,0:06:38.36,0:06:46.53,Default,,0,0,0,,比如这个函数 mult 接收三个参数 x y z 并将其相乘
Dialogue: 0,0:06:46.53,0:06:49.62,Default,,0,0,0,,mult x y z 等于 x 乘 y 乘 z
Dialogue: 0,0:06:49.62,0:06:57.30,Default,,0,0,0,,一种定义方式是接收三个值的元组并将其相乘
Dialogue: 0,0:06:57.30,0:07:02.19,Default,,0,0,0,,更 Haskell 的方式是依次接收三个参数
Dialogue: 0,0:07:02.19,0:07:06.19,Default,,0,0,0,,mult x 返回一个函数
Dialogue: 0,0:07:06.19,0:07:10.00,Default,,0,0,0,,该函数接收另一个参数 y
Dialogue: 0,0:07:10.00,0:07:13.07,Default,,0,0,0,,再返回一个函数 接收另一个参数 z
Dialogue: 0,0:07:13.07,0:07:17.18,Default,,0,0,0,,但三个参数都有时 就可以将其相乘
Dialogue: 0,0:07:17.18,0:07:20.38,Default,,0,0,0,,返回最终的整数
Dialogue: 0,0:07:20.38,0:07:24.05,Default,,0,0,0,,mult 接收一个整数
Dialogue: 0,0:07:24.05,0:07:28.24,Default,,0,0,0,,返回函数 mult x 接收另一个整数 y
Dialogue: 0,0:07:28.24,0:07:33.44,Default,,0,0,0,,再返回一个函数 mult x y 接收一个整数 z
Dialogue: 0,0:07:33.44,0:07:36.57,Default,,0,0,0,,返回结果 x 乘 y 乘 z
Dialogue: 0,0:07:36.57,0:07:48.93,Default,,0,0,0,,可以看到函数的类型中仍然写了括号 从左向右
Dialogue: 0,0:07:48.93,0:07:52.15,Default,,0,0,0,,而函数的箭头向右结合
Dialogue: 0,0:07:52.15,0:08:01.41,Default,,0,0,0,,当我们写 mult x y 时 不用加括号
Dialogue: 0,0:08:01.41,0:08:05.32,Default,,0,0,0,,假如添加回括号的话 将是
Dialogue: 0,0:08:05.32,0:08:10.13,Default,,0,0,0,,(mult x) 外面再加括号
Dialogue: 0,0:08:10.13,0:08:24.10,Default,,0,0,0,,这类括号向左结合 也就是应用函数向左结合 函数箭头向右结合 二者是完美的结合
Dialogue: 0,0:08:24.10,0:08:27.26,Default,,0,0,0,,因此实践中不需要写括号
Dialogue: 0,0:08:27.26,0:08:33.72,Default,,0,0,0,,现在可能要问 柯里化有什么用呢
Dialogue: 0,0:08:33.72,0:08:43.30,Default,,0,0,0,,为什么不像其他语言中 让函数接收整个参数列表
Dialogue: 0,0:08:43.30,0:08:46.98,Default,,0,0,0,,或者用元组精确指定参数呢
Dialogue: 0,0:08:46.98,0:08:54.24,Default,,0,0,0,,为什么要做如此复杂的事情 接收一个参数返回另一个函数等等
Dialogue: 0,0:08:54.24,0:09:01.29,Default,,0,0,0,,原因是 这样可以部分应用一个函数（partially apply 又译局部调用）
Dialogue: 0,0:09:01.29,0:09:05.57,Default,,0,0,0,,例如这个函数 add'
Dialogue: 0,0:09:05.57,0:09:19.39,Default,,0,0,0,,使用柯里化的方式定义 就可以定义一个函数 将值增加 1 方法是将 add' 部分应用到 1 上
Dialogue: 0,0:09:19.39,0:09:23.72,Default,,0,0,0,,add' 1 的类型是一个函数 接收一个整数 返回另一个整数
Dialogue: 0,0:09:23.72,0:09:37.94,Default,,0,0,0,,将来讲列表时 可以看到很多将一个列表转化为其他列表的函数
Dialogue: 0,0:09:37.94,0:09:42.26,Default,,0,0,0,,大多数都是用柯里化的方法定义的
Dialogue: 0,0:09:42.26,0:09:45.83,Default,,0,0,0,,例如这里的 take 函数 部分应用成 take 5
Dialogue: 0,0:09:45.83,0:09:54.97,Default,,0,0,0,,take 被定义为一个柯里化函数 接收一个整数 返回一个从列表到列表的函数
Dialogue: 0,0:09:54.97,0:10:04.96,Default,,0,0,0,,意味着可以将 take 部分应用到 5 上 得到一个函数 可以将一个整数列表转换为另一个
Dialogue: 0,0:10:04.96,0:10:08.54,Default,,0,0,0,,由输入列表前五个元素组成的列表
Dialogue: 0,0:10:08.54,0:10:12.79,Default,,0,0,0,,类似的 drop 函数
Dialogue: 0,0:10:12.79,0:10:16.96,Default,,0,0,0,,接收一个整数 返回一个从列表到列表的函数
Dialogue: 0,0:10:16.96,0:10:20.72,Default,,0,0,0,,现在可以定义 drop 5
Dialogue: 0,0:10:20.72,0:10:25.57,Default,,0,0,0,,也就是部分应用 drop 到 5 上 返回一个函数
Dialogue: 0,0:10:25.57,0:10:35.65,Default,,0,0,0,,接收一个列表作为输入 丢弃前五个元素 返回剩下的列表 太方便了
Dialogue: 0,0:10:35.65,0:10:42.61,Default,,0,0,0,,这种用法在 Haskell 中十分轻量 Haskell 的语法针对柯里化进行了优化
Dialogue: 0,0:10:42.61,0:10:51.95,Default,,0,0,0,,在这方面 Haskell 与大多数优化接收元组作为参数的函数的语言不同
Dialogue: 0,0:10:51.95,0:11:05.79,Default,,0,0,0,,我已经讲过了几次 书写函数参数括号的方式
Dialogue: 0,0:11:05.79,0:11:15.88,Default,,0,0,0,,箭头向右结合 比如下面的类型 Int -> (Int -> (Int -> Int))
Dialogue: 0,0:11:15.88,0:11:24.22,Default,,0,0,0,,括号向右结合 由于我们不想写括号
Dialogue: 0,0:11:24.22,0:11:28.36,Default,,0,0,0,,因此可以写成 Int -> Int -> Int -> Int.
Dialogue: 0,0:11:28.36,0:11:36.76,Default,,0,0,0,,如果把省略的括号加回去 就是底下的表达式 但实际写的是上面这种
Dialogue: 0,0:11:36.76,0:11:45.95,Default,,0,0,0,,因为不想写不必要的括号
Dialogue: 0,0:11:45.95,0:11:53.27,Default,,0,0,0,,另外 当函数应用时 括号向左结合
Dialogue: 0,0:11:53.27,0:11:58.43,Default,,0,0,0,,部分应用一个函数时 可以写括号
Dialogue: 0,0:11:58.43,0:12:02.25,Default,,0,0,0,,但没必要 写出 mult x y z
Dialogue: 0,0:12:02.25,0:12:14.45,Default,,0,0,0,,意思是 (((mult x) y) z)
Dialogue: 0,0:12:14.45,0:12:26.25,Default,,0,0,0,,除非你显式使用元组 Haskell 中通常所有函数都是用柯里化的方式定义的
Dialogue: 0,0:12:26.25,0:12:33.50,Default,,0,0,0,,而多数编程语言中 所有的函数都是非柯里化的方式定义的
Dialogue: 0,0:12:33.50,0:12:48.27,Default,,0,0,0,,这就是关于函数的第二部分 会有很多练习考虑函数类型中 哪里应该加括号
Dialogue: 0,0:12:48.27,0:12:51.58,Default,,0,0,0,,表达式中 哪里应该加括号
Dialogue: 0,0:12:51.58,0:13:00.58,Default,,0,0,0,,它很快就会成为第二天性 一直做下去就会连想都不用想
Dialogue: 0,0:13:00.58,0:13:11.51,Default,,0,0,0,,好的 请完成练习 第二章的最后一个部分再见
