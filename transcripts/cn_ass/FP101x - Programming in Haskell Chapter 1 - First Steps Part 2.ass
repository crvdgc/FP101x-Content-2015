[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: None

[Aegisub Project Garbage]
Scroll Position: 123
Active Line: 136

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,Arial,20,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,2,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:00.91,0:00:05.14,Default,,0,0,0,,欢迎回来 希望你已经安装了 GHC
Dialogue: 0,0:00:05.14,0:00:08.59,Default,,0,0,0,,也尝试了一下输入表达式
Dialogue: 0,0:00:08.59,0:00:13.33,Default,,0,0,0,,现在要从简单表达式更进一步
Dialogue: 0,0:00:13.33,0:00:18.35,Default,,0,0,0,,看看如何将整个Haskell 程序载入 GHC 中
Dialogue: 0,0:00:18.35,0:00:23.31,Default,,0,0,0,,在 Haskell 中 程序并不叫程序
Dialogue: 0,0:00:23.31,0:00:27.26,Default,,0,0,0,,通常人们称代码为
Dialogue: 0,0:00:27.26,0:00:30.68,Default,,0,0,0,,脚本
Dialogue: 0,0:00:30.68,0:00:34.19,Default,,0,0,0,,因为 Haskell 的程序比通常的代码短
Dialogue: 0,0:00:34.19,0:00:37.73,Default,,0,0,0,,我通常就叫程序
Dialogue: 0,0:00:37.73,0:00:44.89,Default,,0,0,0,,但 Haskell 的说法是脚本 
Dialogue: 0,0:00:44.89,0:00:50.61,Default,,0,0,0,,如果你想定义一个完整的程序
Dialogue: 0,0:00:50.61,0:00:53.87,Default,,0,0,0,,可以将他们定义在
Dialogue: 0,0:00:53.87,0:00:57.17,Default,,0,0,0,,一个含有函数列表的文本文件中
Dialogue: 0,0:00:57.17,0:01:00.84,Default,,0,0,0,,这一文本文件
Dialogue: 0,0:01:00.84,0:01:06.04,Default,,0,0,0,,后缀是 .hs 表示
Dialogue: 0,0:01:06.04,0:01:10.17,Default,,0,0,0,,它是一个 Haskell 文件 好比 HTML 文件
Dialogue: 0,0:01:10.17,0:01:14.34,Default,,0,0,0,,后缀名是 .html CSS 文件后缀名是 .css
Dialogue: 0,0:01:14.34,0:01:17.89,Default,,0,0,0,,或者 Java 文件
Dialogue: 0,0:01:17.89,0:01:21.35,Default,,0,0,0,,后缀名是 .java
Dialogue: 0,0:01:21.35,0:01:25.00,Default,,0,0,0,,Haskell 文件是以 .hs 结尾的
Dialogue: 0,0:01:25.00,0:01:29.04,Default,,0,0,0,,虽然不是必须这样
Dialogue: 0,0:01:29.04,0:01:32.32,Default,,0,0,0,,但很有用 当你查看文件夹时
Dialogue: 0,0:01:32.32,0:01:35.68,Default,,0,0,0,,就可以看到这是一个 Haskell 脚本文件
Dialogue: 0,0:01:35.68,0:01:44.43,Default,,0,0,0,,使用 GHC 时
Dialogue: 0,0:01:44.43,0:01:52.04,Default,,0,0,0,,要做的是在一个窗口用一个文本编辑器编辑脚本
Dialogue: 0,0:01:52.04,0:01:59.46,Default,,0,0,0,,做出改变后  将脚本重新载入 GHC
Dialogue: 0,0:01:59.46,0:02:03.59,Default,,0,0,0,,再开始执行表达式 你在课程中主要用到的
Dialogue: 0,0:02:03.59,0:02:07.36,Default,,0,0,0,,工作流就是这样 对于简单的应用
Dialogue: 0,0:02:07.36,0:02:12.08,Default,,0,0,0,,这样就够了 当然如果要写商业性的程序
Dialogue: 0,0:02:12.08,0:02:13.42,Default,,0,0,0,,就不会这样了
Dialogue: 0,0:02:13.42,0:02:16.45,Default,,0,0,0,,你会将脚本编译成为可独立执行的文件
Dialogue: 0,0:02:16.45,0:02:21.55,Default,,0,0,0,,但这们课程中 我们只需要前面的方式
Dialogue: 0,0:02:21.55,0:02:25.95,Default,,0,0,0,,一边开着编辑器的窗口 另一边开着 GHCi 解释器的窗口
Dialogue: 0,0:02:25.95,0:02:30.15,Default,,0,0,0,,接下来载入脚本
Dialogue: 0,0:02:30.15,0:02:33.88,Default,,0,0,0,,这个例子中
Dialogue: 0,0:02:33.88,0:02:37.14,Default,,0,0,0,,我们新建一个名为 test.hs 的文本文件
Dialogue: 0,0:02:37.14,0:02:40.84,Default,,0,0,0,,编写两个函数 第一个是求二倍函数
Dialogue: 0,0:02:40.84,0:02:45.38,Default,,0,0,0,,double 也就是 x + x 顾名思义
Dialogue: 0,0:02:45.38,0:02:49.89,Default,,0,0,0,,下一个是求四倍函数 quadruple 在 double x 上调用 double 实现
Dialogue: 0,0:02:49.89,0:02:55.45,Default,,0,0,0,,保存文件
Dialogue: 0,0:02:55.45,0:02:59.69,Default,,0,0,0,,用 test.hs 做参数运行 GHCi
Dialogue: 0,0:02:59.69,0:03:08.22,Default,,0,0,0,,现在 Haskell 标准库和 test.hs 中定义的 quadruple 与 double
Dialogue: 0,0:03:08.22,0:03:12.03,Default,,0,0,0,,都可以用了 比如我们调用
Dialogue: 0,0:03:12.03,0:03:13.50,Default,,0,0,0,,10 的四倍
Dialogue: 0,0:03:13.50,0:03:16.81,Default,,0,0,0,,返回值是 40
Dialogue: 0,0:03:16.81,0:03:21.04,Default,,0,0,0,,同时仍然可以使用标准库函数 比如
Dialogue: 0,0:03:21.04,0:03:30.07,Default,,0,0,0,,可以从列表取 2 的二倍个元素 2 的二倍是 4 相当于取 4 个元素
Dialogue: 0,0:03:30.65,0:03:33.82,Default,,0,0,0,,因此从列表中取到了 4 个元素
Dialogue: 0,0:03:33.82,0:03:47.57,Default,,0,0,0,,现在保持 GHCi 开启 回到编辑器窗口 添加
Dialogue: 0,0:03:47.57,0:03:56.75,Default,,0,0,0,,两个新定义 一个是阶乘 另一个是均值 因为我们刚刚开始
Dialogue: 0,0:03:56.75,0:04:01.18,Default,,0,0,0,,这里用到了一些还没学过的语法
Dialogue: 0,0:04:01.18,0:04:08.10,Default,,0,0,0,,所以请忍一下 阶乘是从 1 到 n 的乘积 这里的
Dialogue: 0,0:04:08.10,0:04:11.84,Default,,0,0,0,,是 1 到 n 的列表
Dialogue: 0,0:04:11.84,0:04:16.07,Default,,0,0,0,,product 是一个标准库函数
Dialogue: 0,0:04:16.07,0:04:19.16,Default,,0,0,0,,作用是取得列表中元素乘积
Dialogue: 0,0:04:19.16,0:04:29.35,Default,,0,0,0,,这个定义实现了阶乘 接下来定义一个列表的均值
Dialogue: 0,0:04:29.35,0:04:38.02,Default,,0,0,0,,首先求元素的和 接下来除以列表的长度 当然这并非一个求均值的好实现
Dialogue: 0,0:04:38.02,0:04:41.78,Default,,0,0,0,,但现在并不重要
Dialogue: 0,0:04:41.78,0:04:45.75,Default,,0,0,0,,我们并非要定义均值 而是要学 GHCi 的使用
Dialogue: 0,0:04:45.75,0:04:51.22,Default,,0,0,0,,这里用到的技巧是 当你在 Haskell 中
Dialogue: 0,0:04:51.22,0:04:59.39,Default,,0,0,0,,将一个函数的名字放在两个单反引号中间时
Dialogue: 0,0:04:59.39,0:05:02.58,Default,,0,0,0,,就将它作为一个中缀操作符
Dialogue: 0,0:05:02.58,0:05:12.90,Default,,0,0,0,,写 x `f` y 实际上就是语法糖
Dialogue: 0,0:05:12.90,0:05:18.41,Default,,0,0,0,,f x y 一些人喜欢用中缀操作符
Dialogue: 0,0:05:18.41,0:05:21.64,Default,,0,0,0,,另一些喜欢普通的方法
Dialogue: 0,0:05:21.64,0:05:26.96,Default,,0,0,0,,你可以自己选择 因此这里是一个语法规则 而非字符串或是别的
Dialogue: 0,0:05:26.96,0:05:31.44,Default,,0,0,0,,它将一个函数转换为中缀操作符
Dialogue: 0,0:05:31.44,0:05:35.29,Default,,0,0,0,,在 GHCi 中我们用 :reload 重新加载
Dialogue: 0,0:05:35.29,0:05:42.92,Default,,0,0,0,,它将读入 test.hs 文件 添加新定义的名字绑定
Dialogue: 0,0:05:42.92,0:05:46.41,Default,,0,0,0,,也就是 factorial 因此可以在这里调用 factorial
Dialogue: 0,0:05:46.41,0:05:49.61,Default,,0,0,0,,也可以调用 average
Dialogue: 0,0:05:49.61,0:05:54.52,Default,,0,0,0,,请看这里的工作流程 保持 GHCi 窗口开启 进入编辑器
Dialogue: 0,0:05:54.52,0:06:03.43,Default,,0,0,0,,进行编辑 重新加载 接下来可以试试你写的代码了 一些 Haskell 中的
Dialogue: 0,0:06:03.43,0:06:15.73,Default,,0,0,0,,特殊的语法规定 函数名和参数名必须以小写字母开头
Dialogue: 0,0:06:15.73,0:06:26.72,Default,,0,0,0,,可以用这样的形式定义函数 但开头必须小写
Dialogue: 0,0:06:26.72,0:06:30.58,Default,,0,0,0,,可以在名字中用普通英文引号
Dialogue: 0,0:06:30.58,0:06:34.31,Default,,0,0,0,,如果你懒得取新名字的话
Dialogue: 0,0:06:34.31,0:06:42.52,Default,,0,0,0,,这也是我在其他语言中想念的特性 我想写 x 撇 x 两撇等等
Dialogue: 0,0:06:42.52,0:06:51.71,Default,,0,0,0,,如果定义一个类型 首字母需要大写 因此才会这样
Dialogue: 0,0:06:51.71,0:06:58.18,Default,,0,0,0,,Haskell 中类型和标识符在不同的名字空间中 这是用
Dialogue: 0,0:06:58.18,0:07:01.62,Default,,0,0,0,,首字母大小写来区分的
Dialogue: 0,0:07:01.62,0:07:06.83,Default,,0,0,0,,来自其他编程语言背景的人可能很困惑
Dialogue: 0,0:07:06.83,0:07:10.99,Default,,0,0,0,,比如 Java C# 和 JavaScript.
Dialogue: 0,0:07:10.99,0:07:19.80,Default,,0,0,0,,另一件事是 Haskell 中常用一种较弱的匈牙利命名法
Dialogue: 0,0:07:19.80,0:07:31.42,Default,,0,0,0,,如果参数以 s 结尾 比如 xs ns 或 nss
Dialogue: 0,0:07:31.42,0:07:44.46,Default,,0,0,0,,表示它们是 x 类型值的列表 n 类型的值的列表 有时 n 并不对应于
Dialogue: 0,0:07:44.46,0:07:49.36,Default,,0,0,0,,类型名 但通常看到名字中的 s 就知道它是个列表了
Dialogue: 0,0:07:49.36,0:07:52.46,Default,,0,0,0,,如果结尾有两个 s 
Dialogue: 0,0:07:52.46,0:07:55.91,Default,,0,0,0,,就代表一个列表的列表
Dialogue: 0,0:07:55.91,0:07:59.63,Default,,0,0,0,,这是一个惯例 如果想要看起来像真正的 Haskell 程序员一样
Dialogue: 0,0:07:59.63,0:08:03.37,Default,,0,0,0,,你应该采用这一惯例 如果参数是一个列表
Dialogue: 0,0:08:03.37,0:08:10.41,Default,,0,0,0,,就应该用 s 结尾 通常 Haskell 标识符很短 
Dialogue: 0,0:08:10.41,0:08:13.90,Default,,0,0,0,,因此不叫它 elements 而叫 xs
Dialogue: 0,0:08:13.90,0:08:21.37,Default,,0,0,0,,另一个和 Python 相同的有趣之处是
Dialogue: 0,0:08:21.37,0:08:25.05,Default,,0,0,0,,空白是有意义的
Dialogue: 0,0:08:25.05,0:08:28.10,Default,,0,0,0,,准确的规则很繁琐
Dialogue: 0,0:08:28.10,0:08:35.63,Default,,0,0,0,,因为我们只用 Haskell 中很简单的部分
Dialogue: 0,0:08:35.63,0:08:40.88,Default,,0,0,0,,知道这些就够了 如果有一系列的定义
Dialogue: 0,0:08:40.88,0:08:44.60,Default,,0,0,0,,应在同一列起始
Dialogue: 0,0:08:44.60,0:08:55.30,Default,,0,0,0,,a, b 和 c 都在同一列起始 这边 b 左侧有空格
Dialogue: 0,0:08:55.30,0:08:58.78,Default,,0,0,0,,因此定义没有从相同列起始
Dialogue: 0,0:08:58.78,0:09:08.13,Default,,0,0,0,,就出错了 这边的 c 和 a 没有和 b 在同一行起始也错了
Dialogue: 0,0:09:08.13,0:09:11.46,Default,,0,0,0,,Haskell 中的空白是有意义的
Dialogue: 0,0:09:11.46,0:09:15.60,Default,,0,0,0,,确保定义对其 这叫 布局规则
Dialogue: 0,0:09:15.60,0:09:26.08,Default,,0,0,0,,布局规则是为了避免不必要的语法
Dialogue: 0,0:09:26.08,0:09:30.05,Default,,0,0,0,,Haskell 程序员喜欢这样写 a = b + c where
Dialogue: 0,0:09:30.05,0:09:33.51,Default,,0,0,0,,在 where 子句中 我们有一系列的定义
Dialogue: 0,0:09:33.51,0:09:40.44,Default,,0,0,0,,它们以同一行起始 d 和 a 在同一行起始
Dialogue: 0,0:09:40.44,0:09:44.06,Default,,0,0,0,,因此和 a 属于同一组
Dialogue: 0,0:09:44.06,0:09:47.95,Default,,0,0,0,,你可以这样显式地写出来
Dialogue: 0,0:09:47.95,0:09:51.92,Default,,0,0,0,,用花括号和分号
Dialogue: 0,0:09:51.92,0:09:59.85,Default,,0,0,0,,但看起来太过啰唆 Haskell 程序员喜欢简洁
Dialogue: 0,0:09:59.85,0:10:03.11,Default,,0,0,0,,因此经常使用有意义的空白
Dialogue: 0,0:10:03.11,0:10:06.64,Default,,0,0,0,,这种写法略显笨拙
Dialogue: 0,0:10:06.64,0:10:10.52,Default,,0,0,0,,如果你在 Haskell 中这样写代码 人们就会说
Dialogue: 0,0:10:10.52,0:10:14.09,Default,,0,0,0,,你没做足那些训练
Dialogue: 0,0:10:14.09,0:10:21.09,Default,,0,0,0,,这是一些有用的 GHC 命令
Dialogue: 0,0:10:21.22,0:10:29.62,Default,,0,0,0,,强烈建议你试验一下 当你做
Dialogue: 0,0:10:29.62,0:10:33.22,Default,,0,0,0,,接下来几课的练习时 确保利用好
Dialogue: 0,0:10:33.22,0:10:36.80,Default,,0,0,0,,GHC 或其他的编译器的帮助
Dialogue: 0,0:10:36.80,0:10:41.93,Default,,0,0,0,,我们看过了 reload 也可以用 load
Dialogue: 0,0:10:41.93,0:10:45.82,Default,,0,0,0,,载入一个新脚本
Dialogue: 0,0:10:45.82,0:10:52.43,Default,,0,0,0,,可以从解释器里打开编辑器
Dialogue: 0,0:10:52.43,0:10:56.27,Default,,0,0,0,,编辑特定文件 或者当前文件
Dialogue: 0,0:10:56.27,0:10:59.88,Default,,0,0,0,,这个命令很有用
Dialogue: 0,0:10:59.88,0:11:03.55,Default,,0,0,0,,它给出表达式的类型 我经常使用
Dialogue: 0,0:11:03.55,0:11:11.58,Default,,0,0,0,,我从不自己写类型 因此把表达式从编辑器粘贴到这里问一下类型
Dialogue: 0,0:11:11.58,0:11:19.64,Default,,0,0,0,,用 :? 命令得到所有可用命令的列表
Dialogue: 0,0:11:19.64,0:11:23.97,Default,,0,0,0,,和简短的解释 当然
Dialogue: 0,0:11:23.97,0:11:31.07,Default,,0,0,0,,我希望你 不要 用最后这个命令退出 GHC
Dialogue: 0,0:11:31.07,0:11:39.70,Default,,0,0,0,,但最后你还是要用的 接下来的八周将经常用 GHC
Dialogue: 0,0:11:39.70,0:11:46.66,Default,,0,0,0,,网站上将有很多练习
Dialogue: 0,0:11:46.66,0:11:55.60,Default,,0,0,0,,你可以用任何语言完成这些练习 不一定非要用 GHC
Dialogue: 0,0:11:55.60,0:12:06.61,Default,,0,0,0,,但既然本讲讲的是 GHC 对应的练习也是针对 GHC 的
Dialogue: 0,0:12:06.61,0:12:10.68,Default,,0,0,0,,一般而言 正如我在第一节课中所说的
Dialogue: 0,0:12:10.68,0:12:17.32,Default,,0,0,0,,这是一门函数式程序设计课 而非 Haskell 课 更不是 GHC 课
Dialogue: 0,0:12:17.32,0:12:25.25,Default,,0,0,0,,但本章的练习是关于 GHC 的 因为课程内容是 GHCi
Dialogue: 0,0:12:25.25,0:12:29.45,Default,,0,0,0,,祝你 Hacking 愉快 下周再见！
