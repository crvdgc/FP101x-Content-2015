[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: None

[Aegisub Project Garbage]
Scroll Position: 99
Active Line: 118

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,Arial,20,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,2,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:01.02,0:00:07.35,Default,,0,0,0,,欢迎来到新一课 FP101x
Dialogue: 0,0:00:07.35,0:00:11.48,Default,,0,0,0,,今天要谈的是列表解析
Dialogue: 0,0:00:11.48,0:00:19.27,Default,,0,0,0,,列表解析是一种操作合集的方法
Dialogue: 0,0:00:19.27,0:00:23.07,Default,,0,0,0,,大多数的编程语言中
Dialogue: 0,0:00:23.07,0:00:31.51,Default,,0,0,0,,很多特性都和操作数据合集有关
Dialogue: 0,0:00:31.51,0:00:37.02,Default,,0,0,0,,比如传统的过程式编程语言 Java 和 C#
Dialogue: 0,0:00:37.02,0:00:41.75,Default,,0,0,0,,有许多处理合集的机制
Dialogue: 0,0:00:41.75,0:00:45.16,Default,,0,0,0,,for 循环 while 循环 do while 循环
Dialogue: 0,0:00:45.16,0:00:48.64,Default,,0,0,0,,foreach 循环和 continue break 语句
Dialogue: 0,0:00:48.64,0:00:56.28,Default,,0,0,0,,这些结构都是用来遍历合集的
Dialogue: 0,0:00:56.28,0:01:04.54,Default,,0,0,0,,当然在数学中 处理合集的历史已经好几个世纪了
Dialogue: 0,0:01:04.54,0:01:11.50,Default,,0,0,0,,数学家最喜欢的合集是集合
Dialogue: 0,0:01:11.50,0:01:15.97,Default,,0,0,0,,集合在计算上不是很好表示
Dialogue: 0,0:01:15.97,0:01:19.24,Default,,0,0,0,,因为集合没有重复元素
Dialogue: 0,0:01:19.24,0:01:24.50,Default,,0,0,0,,因此元素必须要有相等性才能构成集合
Dialogue: 0,0:01:24.50,0:01:27.52,Default,,0,0,0,,特别是像 Haskell 这样的函数式语言
Dialogue: 0,0:01:27.52,0:01:32.00,Default,,0,0,0,,十分困难 实际上是不可能的 因为需要解决停机问题
Dialogue: 0,0:01:32.00,0:01:35.43,Default,,0,0,0,,才能确定函数之间是否相等
Dialogue: 0,0:01:35.43,0:01:47.28,Default,,0,0,0,,因此 Haskell 的做法是 吸纳一些数学家长时间依赖处理集合的方法
Dialogue: 0,0:01:47.28,0:01:52.82,Default,,0,0,0,,将它们简化 用到列表上
Dialogue: 0,0:01:52.82,0:01:57.81,Default,,0,0,0,,列表是我最喜欢的合集类型
Dialogue: 0,0:01:57.81,0:02:01.61,Default,,0,0,0,,因为它给出了一种处理合集的最简单的方式
Dialogue: 0,0:02:01.61,0:02:07.45,Default,,0,0,0,,如果有一个列表 那么它是由头（head）和尾（tail）所组成的
Dialogue: 0,0:02:07.45,0:02:13.56,Default,,0,0,0,,就可以递归地分解列表 依次取出首元素
Dialogue: 0,0:02:13.56,0:02:20.13,Default,,0,0,0,,十分方便 对类型的限制也很少
Dialogue: 0,0:02:20.13,0:02:30.20,Default,,0,0,0,,不同于假设相等性的集合 以及常数时间访问的数组
Dialogue: 0,0:02:30.20,0:02:37.84,Default,,0,0,0,,在某种程度上 列表是最纯粹的合集形式
Dialogue: 0,0:02:37.84,0:02:41.90,Default,,0,0,0,,在 Java 8 中被称为 lists streams
Dialogue: 0,0:02:41.90,0:02:51.07,Default,,0,0,0,,来强调它是只能一个一个访问的数据合集
Dialogue: 0,0:02:51.07,0:02:56.48,Default,,0,0,0,,这样说来 Haskell 中的列表正是 Java 8 这种思想的一个实例
Dialogue: 0,0:02:56.48,0:03:07.15,Default,,0,0,0,,下面来看看 数学家是如何使用集合解析式（推导式 又称描述法）来定义集合的
Dialogue: 0,0:03:07.15,0:03:10.94,Default,,0,0,0,,这是一个集合的例子
Dialogue: 0,0:03:10.94,0:03:21.59,Default,,0,0,0,,这是一个 1 到 5 数字平方的集合
Dialogue: 0,0:03:21.59,0:03:25.29,Default,,0,0,0,,也就是 x 的平方 其中 x 来自集合 1 到 5
Dialogue: 0,0:03:25.29,0:03:30.68,Default,,0,0,0,,结果就是集合 1,4,9,16,25
Dialogue: 0,0:03:30.68,0:03:39.40,Default,,0,0,0,,但正如之前所说的 如果 x 取自某个函数集合 就很难实现
Dialogue: 0,0:03:39.40,0:03:46.94,Default,,0,0,0,,因此函数式语言使用者决定 使用相同的记号和想法
Dialogue: 0,0:03:46.94,0:03:55.28,Default,,0,0,0,,但不用在集合上 而用在列表上 集合解析就成了 Haskell 中的列表解析
Dialogue: 0,0:03:55.28,0:04:01.29,Default,,0,0,0,,下面是一些列表解析的例子
Dialogue: 0,0:04:01.29,0:04:08.00,Default,,0,0,0,,也就是 x 平方的列表 其中 x 取自 1 到 5 的列表
Dialogue: 0,0:04:08.00,0:04:15.10,Default,,0,0,0,,这一记号读作 x 取自列表 1 到 5
Dialogue: 0,0:04:15.10,0:04:22.46,Default,,0,0,0,,求值后返回的是列表 [1,4,9,16,25]
Dialogue: 0,0:04:22.46,0:04:27.60,Default,,0,0,0,,但是是列表的形式 而不是集合的形式
Dialogue: 0,0:04:27.60,0:04:32.30,Default,,0,0,0,,x 取自 1 到 5 这一表达式被称为 生成式（generator）
Dialogue: 0,0:04:32.30,0:04:36.12,Default,,0,0,0,,之所以被称为生成式
Dialogue: 0,0:04:36.12,0:04:39.91,Default,,0,0,0,,是因为它定义了如何产生 x 的值
Dialogue: 0,0:04:39.91,0:04:43.69,Default,,0,0,0,,因此 x 是从那个列表中产生的
Dialogue: 0,0:04:43.69,0:04:54.28,Default,,0,0,0,,当然 Haskell 有个优点 就是所有东西都可以相互组合
Dialogue: 0,0:04:54.28,0:04:59.16,Default,,0,0,0,,应该能递归地一遍又一遍使用相同的结构
Dialogue: 0,0:04:59.16,0:05:03.38,Default,,0,0,0,,解析式也可以包含多个生成式
Dialogue: 0,0:05:03.38,0:05:10.09,Default,,0,0,0,,下面是一个例子 构造一个 (x, y) 对的列表
Dialogue: 0,0:05:10.09,0:05:16.99,Default,,0,0,0,,其中 x 取自 [1,2,3] y 取自 [4,5]
Dialogue: 0,0:05:16.99,0:05:24.22,Default,,0,0,0,,可以看到 y 比 x 变化得更频繁
Dialogue: 0,0:05:24.22,0:05:31.11,Default,,0,0,0,,结果是列表 [(1,4),(1,5),(2,4),(2,5),(3,4),(3,5)]
Dialogue: 0,0:05:31.11,0:05:38.13,Default,,0,0,0,,另一种理解嵌套生成式 或者说多生成式的方法是
Dialogue: 0,0:05:38.13,0:05:41.45,Default,,0,0,0,,看作嵌套循环 其中 y 是内循环
Dialogue: 0,0:05:41.45,0:05:49.34,Default,,0,0,0,,x 是外循环 如果交换生成式的顺序
Dialogue: 0,0:05:49.34,0:05:57.06,Default,,0,0,0,,x 就会变化得更快 因为它成了内循环
Dialogue: 0,0:05:57.06,0:06:07.19,Default,,0,0,0,,注意这里写得仍然是 (x,y) 仅仅改变了生成式的顺序 而不是变量的顺序
Dialogue: 0,0:06:07.19,0:06:15.03,Default,,0,0,0,,不是这一变量变化更快
Dialogue: 0,0:06:15.03,0:06:18.88,Default,,0,0,0,,而是 x 变化更快
Dialogue: 0,0:06:18.88,0:06:22.44,Default,,0,0,0,,结果是 (1,4) (2,4) (3,4) 等等
Dialogue: 0,0:06:22.44,0:06:32.55,Default,,0,0,0,,可以在很多编程语言中找到生成式的概念 Haskell 中是列表解析
Dialogue: 0,0:06:32.55,0:06:34.59,Default,,0,0,0,,如果你用过 Python
Dialogue: 0,0:06:34.59,0:06:38.08,Default,,0,0,0,,其中也有列表解析
Dialogue: 0,0:06:38.08,0:06:42.75,Default,,0,0,0,,Scala 有 for 解析 F# 有解析
Dialogue: 0,0:06:42.75,0:06:49.55,Default,,0,0,0,,C# 和 Visual Basic 有 LINQ 解析
Dialogue: 0,0:06:49.55,0:06:57.50,Default,,0,0,0,,而像 SQL 这样的语言 完全是建立在解析的基础上的
Dialogue: 0,0:06:57.50,0:07:01.95,Default,,0,0,0,,区别只是写法不如这里简洁 要写 SELECT FROM WHERE
Dialogue: 0,0:07:01.95,0:07:06.27,Default,,0,0,0,,但基本想法类似
Dialogue: 0,0:07:06.27,0:07:15.02,Default,,0,0,0,,学了 Haskell 中的列表解析 无论在什么语言中遇到 也都可以理解了
Dialogue: 0,0:07:15.02,0:07:29.50,Default,,0,0,0,,现在我们已经看过了一些生成式只有常量的例子
Dialogue: 0,0:07:29.50,0:07:33.01,Default,,0,0,0,,但生成式也可以依赖彼此
Dialogue: 0,0:07:33.01,0:07:40.49,Default,,0,0,0,,正如在循环中 内循环可以使用外循环的变量
Dialogue: 0,0:07:40.49,0:07:44.36,Default,,0,0,0,,解析中也一样
Dialogue: 0,0:07:44.36,0:07:47.68,Default,,0,0,0,,这里 x 取自 1 到 3
Dialogue: 0,0:07:47.68,0:07:50.86,Default,,0,0,0,,y 取自 x 到 3
Dialogue: 0,0:07:50.86,0:07:59.71,Default,,0,0,0,,因此 x 的作用范围包括它后面的解析式 求值这一解析
Dialogue: 0,0:07:59.71,0:08:04.00,Default,,0,0,0,,得到 (1,1)
Dialogue: 0,0:08:04.00,0:08:07.21,Default,,0,0,0,,因为 y 目前取自 1 到 3
Dialogue: 0,0:08:07.21,0:08:12.30,Default,,0,0,0,,这是由于 x 最开始的取值是 1 因此结果是 (1,1) (1,2) (1,3)
Dialogue: 0,0:08:12.30,0:08:16.32,Default,,0,0,0,,这时 y 没有新的取值了
Dialogue: 0,0:08:16.32,0:08:20.41,Default,,0,0,0,,x 的下一个取值是 2
Dialogue: 0,0:08:20.41,0:08:28.31,Default,,0,0,0,,此时 y 的取自 2 到 3 最后一个循环中
Dialogue: 0,0:08:28.31,0:08:39.36,Default,,0,0,0,,x 是 3 y 取自列表 3 到 3 最后一个值就是 (3,3)
Dialogue: 0,0:08:39.36,0:08:44.72,Default,,0,0,0,,但你应该十分熟悉这种方式 因为它和任何语言中的嵌套循环相同
Dialogue: 0,0:08:44.72,0:08:51.95,Default,,0,0,0,,内循环可以使用外循环的变量
Dialogue: 0,0:08:51.95,0:09:02.95,Default,,0,0,0,,列表解析中使用有依赖的生成式 可以帮助写出简洁的代码
Dialogue: 0,0:09:02.95,0:09:10.97,Default,,0,0,0,,比如想把一个列表的列表 展开成一个列表
Dialogue: 0,0:09:10.97,0:09:14.45,Default,,0,0,0,,可以用以下解析式实现
Dialogue: 0,0:09:14.45,0:09:19.19,Default,,0,0,0,,从这个列表的列表中 给我每一个列表
Dialogue: 0,0:09:19.19,0:09:22.64,Default,,0,0,0,,再给我这个列表中的每一个元素
Dialogue: 0,0:09:22.64,0:09:27.56,Default,,0,0,0,,并将其返回 这是一个双重循环
Dialogue: 0,0:09:27.56,0:09:31.19,Default,,0,0,0,,遍历每一个列表的列表
Dialogue: 0,0:09:31.19,0:09:42.01,Default,,0,0,0,,产生单个列表 包含了所有值 类型和原列表中的元素类型相同 均为 a
Dialogue: 0,0:09:42.01,0:09:49.58,Default,,0,0,0,,当连接 [1,2,3] [4,5] and [6] 时 结果就是 [1,2,3,4,5,6]
Dialogue: 0,0:09:49.58,0:10:00.25,Default,,0,0,0,,使用列表解析写出了非常简洁的代码
Dialogue: 0,0:10:00.25,0:10:09.18,Default,,0,0,0,,列表解析中 除了用到生成式外 许多集合解析中还用到了 过滤器（filter）
Dialogue: 0,0:10:09.18,0:10:16.01,Default,,0,0,0,,想从某些集合中取出 x
Dialogue: 0,0:10:16.01,0:10:22.61,Default,,0,0,0,,但同时筛掉一些不满足特定条件的值
Dialogue: 0,0:10:22.61,0:10:26.05,Default,,0,0,0,,比如想获得 1 到 10 中的偶数
Dialogue: 0,0:10:26.05,0:10:30.33,Default,,0,0,0,,可以写 x 取自 1 到 10
Dialogue: 0,0:10:30.33,0:10:34.39,Default,,0,0,0,,但仅仅保留偶数
Dialogue: 0,0:10:34.39,0:10:38.44,Default,,0,0,0,,结果就是列表 [2,4,6,8,10]
Dialogue: 0,0:10:38.44,0:10:41.87,Default,,0,0,0,,也就是 1 到 10 中的偶数
Dialogue: 0,0:10:41.87,0:10:46.17,Default,,0,0,0,,SQL 中对应的是 SELECT WHERE
Dialogue: 0,0:10:46.17,0:10:50.22,Default,,0,0,0,,WHERE 语句在 Haskell 里称为 守卫（guard）
Dialogue: 0,0:10:50.22,0:11:02.38,Default,,0,0,0,,如果使用的是 LINQ 列表解析 用的同样是 WHERE
Dialogue: 0,0:11:02.38,0:11:11.75,Default,,0,0,0,,下面是一个用守卫实现因数分解的例子
Dialogue: 0,0:11:11.75,0:11:18.98,Default,,0,0,0,,如何获得因数呢 对于一个数 取所有 1 到 n 的数
Dialogue: 0,0:11:18.98,0:11:26.36,Default,,0,0,0,,只保留那些 n 模（modulo）等于 0 的数
Dialogue: 0,0:11:26.36,0:11:30.36,Default,,0,0,0,,比如因数分解 15 从所有 1 到 15 的数字开始
Dialogue: 0,0:11:30.36,0:11:38.24,Default,,0,0,0,,去掉 n 模 x 不为零的数字
Dialogue: 0,0:11:38.24,0:11:42.42,Default,,0,0,0,,这个例子的结果是 [1,3,5,15]
Dialogue: 0,0:11:42.42,0:11:56.39,Default,,0,0,0,,接下来可以用因数分解函数来定义一个判断给定数字是否是质数的程序
Dialogue: 0,0:11:56.39,0:12:02.23,Default,,0,0,0,,当因数恰好为 [1,n] 时 这个数就是质数
Dialogue: 0,0:12:02.23,0:12:05.58,Default,,0,0,0,,比如 15 不是质数
Dialogue: 0,0:12:05.58,0:12:09.51,Default,,0,0,0,,因为因数不只有 1 和 15
Dialogue: 0,0:12:09.51,0:12:21.55,Default,,0,0,0,,而是 [1,3,5,15] 但 7 是一个质数 可以用 GHCi 或者你最喜欢的编程语言验证 其因数只有 1 和 7
Dialogue: 0,0:12:21.55,0:12:28.17,Default,,0,0,0,,因此 7 是质数
Dialogue: 0,0:12:28.17,0:12:35.81,Default,,0,0,0,,如果想要获得到一定数范围内的所有质数
Dialogue: 0,0:12:35.81,0:12:39.49,Default,,0,0,0,,可以写一个简单的列表解析
Dialogue: 0,0:12:39.49,0:12:44.07,Default,,0,0,0,,给我所有从 2 到 n 的数字 其中 n 是函数的参数
Dialogue: 0,0:12:44.07,0:12:49.08,Default,,0,0,0,,我只想保留质数
Dialogue: 0,0:12:49.08,0:12:51.57,Default,,0,0,0,,因此要过滤掉所有不是质数的数
Dialogue: 0,0:12:51.57,0:12:55.52,Default,,0,0,0,,比如要获得到 40 的所有质数
Dialogue: 0,0:12:55.52,0:13:05.20,Default,,0,0,0,,只需要运行列表解析就得到了 当然这样计算质数效率并不高
Dialogue: 0,0:13:05.20,0:13:13.45,Default,,0,0,0,,但我认为它是演示列表解析的很好的例子
Dialogue: 0,0:13:13.45,0:13:14.30,Default,,0,0,0,,下节课再见
