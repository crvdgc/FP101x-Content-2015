[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: None

[Aegisub Project Garbage]
Scroll Position: 51
Active Line: 65

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,Arial,20,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,2,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:01.75,0:00:06.89,Default,,0,0,0,,大家好 欢迎观看新的一集 FP101x
Dialogue: 0,0:00:06.89,0:00:18.26,Default,,0,0,0,,今天要学习的是在 Haskell 中定义函数
Dialogue: 0,0:00:18.26,0:00:28.42,Default,,0,0,0,,我觉得你们当中不在家乡上大学的人
Dialogue: 0,0:00:28.42,0:00:31.80,Default,,0,0,0,,或多或少都有这样的经历
Dialogue: 0,0:00:31.80,0:00:40.42,Default,,0,0,0,,你离开自己长大 上小学和中学的家乡 前往大学
Dialogue: 0,0:00:40.42,0:00:43.57,Default,,0,0,0,,十年后回到故乡
Dialogue: 0,0:00:43.57,0:00:46.98,Default,,0,0,0,,事物发生了些许的变化
Dialogue: 0,0:00:46.98,0:00:50.02,Default,,0,0,0,,但同时又似曾相识
Dialogue: 0,0:00:50.02,0:00:53.46,Default,,0,0,0,,但这可能让你有点晕头转向
Dialogue: 0,0:00:53.46,0:01:04.07,Default,,0,0,0,,因为记忆中的事物没有改变 而在现实中已经不同了
Dialogue: 0,0:01:04.07,0:01:07.72,Default,,0,0,0,,学 Haskell 时会有类似的感受
Dialogue: 0,0:01:07.72,0:01:16.22,Default,,0,0,0,,Haskell 和其他编程语言看起来很像 但又有细微的不同
Dialogue: 0,0:01:16.22,0:01:26.11,Default,,0,0,0,,本讲要介绍的是 Haskell 的函数定义与表达式书写的语法
Dialogue: 0,0:01:26.11,0:01:33.97,Default,,0,0,0,,并与其他编程语言中的实现方式相比较
Dialogue: 0,0:01:33.97,0:01:40.65,Default,,0,0,0,,当注意到区别时 它们就很容易使用了
Dialogue: 0,0:01:40.65,0:01:49.60,Default,,0,0,0,,但在 Haskell 中的确有一些不同之处
Dialogue: 0,0:01:49.60,0:01:58.15,Default,,0,0,0,,尤其是和 Java PHP 或者你喜欢的语言中的习惯相比
Dialogue: 0,0:01:58.15,0:02:06.37,Default,,0,0,0,,第一件要讲的是条件表达式
Dialogue: 0,0:02:06.37,0:02:18.08,Default,,0,0,0,,每门语言都有条件表达式 通常也会区分使用 if then else 写的条件语句
Dialogue: 0,0:02:18.08,0:02:21.16,Default,,0,0,0,,和用 ? 和 : 三元表达式写的条件表达式
Dialogue: 0,0:02:21.16,0:02:27.52,Default,,0,0,0,,其他语言也有用 if then else 写表达式的 比如 Scala
Dialogue: 0,0:02:27.52,0:02:38.57,Default,,0,0,0,,但在 C# 和 Java 中 条件语句和条件表达式的语法不同
Dialogue: 0,0:02:38.57,0:02:49.93,Default,,0,0,0,,Haskell 中没有语句 因此使用 if then else 表达条件
Dialogue: 0,0:02:49.93,0:02:57.25,Default,,0,0,0,,本例中定义一个函数 接受一个整数 返回另一个整数
Dialogue: 0,0:02:57.25,0:03:00.47,Default,,0,0,0,,这是取绝对值的函数
Dialogue: 0,0:03:00.47,0:03:07.98,Default,,0,0,0,,它接受一个值 当值大于等于 0 时 返回 n 否则返回 -n
Dialogue: 0,0:03:07.98,0:03:20.37,Default,,0,0,0,,对值取反 这里使用的是熟悉的 if then else 表达式形式
Dialogue: 0,0:03:20.37,0:03:27.00,Default,,0,0,0,,当然 因为它只是一个表达式 因此也可以嵌套
Dialogue: 0,0:03:27.00,0:03:34.16,Default,,0,0,0,,同样因为条件表达式是表达式 因此总是需要有 then 和 else 部分
Dialogue: 0,0:03:34.16,0:03:42.70,Default,,0,0,0,,这个例子定义了符号数 signum
Dialogue: 0,0:03:42.70,0:03:52.13,Default,,0,0,0,,n 小于 0 时是 -1 n 等于 0 时是 0 n 大于 0 时是 1
Dialogue: 0,0:03:52.13,0:04:04.34,Default,,0,0,0,,如同三元表达式一样 then 和 else 分支是必要的
Dialogue: 0,0:04:04.34,0:04:14.06,Default,,0,0,0,,因为 Haskell 程序员喜欢简洁 通常不用条件表达式 而是用所谓的守卫（guarded）等式
Dialogue: 0,0:04:14.06,0:04:21.59,Default,,0,0,0,,守卫等式捕获了一种常见的模式 即以条件开始的函数
Dialogue: 0,0:04:21.59,0:04:32.03,Default,,0,0,0,,如果函数定义的等式右边立刻接着一个条件 最好使用守卫等式
Dialogue: 0,0:04:32.03,0:04:37.37,Default,,0,0,0,,因此在左侧写函数的定义 接下来写条件
Dialogue: 0,0:04:37.37,0:04:40.76,Default,,0,0,0,,因此 n 的绝对值是
Dialogue: 0,0:04:40.76,0:04:44.75,Default,,0,0,0,,当 n 大于等于 0 时为 n
Dialogue: 0,0:04:44.75,0:04:53.30,Default,,0,0,0,,否则是 -n 其中的 否则 相当于 True
Dialogue: 0,0:04:53.30,0:05:03.61,Default,,0,0,0,,回到这里的定义 使用条件表达式计算绝对值
Dialogue: 0,0:05:03.61,0:05:13.68,Default,,0,0,0,,可以看到函数定义中立刻接了一个条件表达式
Dialogue: 0,0:05:13.68,0:05:22.33,Default,,0,0,0,,Haskell 程序员更喜欢这样写 可以看到右侧更简单 条件也更清楚了
Dialogue: 0,0:05:22.33,0:05:26.02,Default,,0,0,0,,可以很轻松地进行思考
Dialogue: 0,0:05:26.02,0:05:36.15,Default,,0,0,0,,当 n 大于等于 0 时 当 n 小于 0 时 对于其他的函数
Dialogue: 0,0:05:36.44,0:05:40.78,Default,,0,0,0,,尤其是嵌套的条件时 就更值得这样做了
Dialogue: 0,0:05:40.78,0:05:52.16,Default,,0,0,0,,为了定义符号数 signum 如果小于 0 是 -1 如果等于 0 则是 0 否则是 1
Dialogue: 0,0:05:52.16,0:05:58.97,Default,,0,0,0,,从中可以看到 Haskell 中的数学传统 写法很简洁
Dialogue: 0,0:05:58.97,0:06:09.72,Default,,0,0,0,,守卫等式是地道的 Haskell 写法
Dialogue: 0,0:06:09.72,0:06:18.28,Default,,0,0,0,,因此通常不写 if then else 而是写守卫等式
Dialogue: 0,0:06:18.28,0:06:30.97,Default,,0,0,0,,另一件 Haskell 中大量使用 而其他现代语言较少使用的就是模式匹配（pattern matching）
Dialogue: 0,0:06:30.97,0:06:38.52,Default,,0,0,0,,比如 Scala 中有模式匹配 但需要使用 case 语句才能做到
Dialogue: 0,0:06:38.52,0:06:42.65,Default,,0,0,0,,C# 使用选择（switch）语句
Dialogue: 0,0:06:42.65,0:06:46.42,Default,,0,0,0,,但在 Haskell 中 定义函数时可以直接使用模式匹配
Dialogue: 0,0:06:46.42,0:06:57.16,Default,,0,0,0,,比如定义逻辑取反 是一个从布尔值到布尔值的函数 可以直接模式匹配
Dialogue: 0,0:06:57.16,0:07:01.88,Default,,0,0,0,,not False 等于 True not True 等于 False
Dialogue: 0,0:07:01.88,0:07:10.53,Default,,0,0,0,,这样定义的逻辑取反十分简洁
Dialogue: 0,0:07:10.53,0:07:18.10,Default,,0,0,0,,再比如定义逻辑与 && 类型是从布尔到布尔再到布尔
Dialogue: 0,0:07:18.10,0:07:25.64,Default,,0,0,0,,可以直接写下 && 的真值表
Dialogue: 0,0:07:25.64,0:07:35.02,Default,,0,0,0,,如果查 && 在数字逻辑中的定义的话 就会找到相同的真值表
Dialogue: 0,0:07:35.02,0:07:45.09,Default,,0,0,0,,我们可以写下来 但仔细看看 其实可以写得更简洁
Dialogue: 0,0:07:45.09,0:07:52.15,Default,,0,0,0,,因为只有当两个参数都为真时 结果才为真
Dialogue: 0,0:07:52.15,0:07:56.67,Default,,0,0,0,,其他情况下都是假
Dialogue: 0,0:07:56.67,0:07:59.91,Default,,0,0,0,,因此将四种情况缩减为两种
Dialogue: 0,0:07:59.91,0:08:07.26,Default,,0,0,0,,True && True 等于 True 否则无论什么 && 什么都为 False
Dialogue: 0,0:08:07.26,0:08:24.23,Default,,0,0,0,,下划线在 Haskell 中很普遍 意思是无关的变量 仅仅作为模式匹配中的占位符
Dialogue: 0,0:08:24.23,0:08:42.58,Default,,0,0,0,,观察这个定义可以看出 为了进行匹配会对两个参数均进行求值 因为在 && 的两侧都有模式
Dialogue: 0,0:08:42.58,0:08:52.04,Default,,0,0,0,,Haskell 程序员对此很敏感 因为 Haskell 是一门惰性（lazy）语言 希望求值越少越好
Dialogue: 0,0:08:52.04,0:09:02.43,Default,,0,0,0,,为了得到函数调用的答案 一个更好的定义
Dialogue: 0,0:09:02.43,0:09:16.57,Default,,0,0,0,,在地道的 Haskell 中是这样的 如果是 True 那么 True && b 的结果为 b 如果是 False 那就是 False
Dialogue: 0,0:09:16.57,0:09:32.76,Default,,0,0,0,,让我们验证一下 Ture && True 是 True True && False 是 False 因此结果与后面的值相同
Dialogue: 0,0:09:32.76,0:09:37.25,Default,,0,0,0,,如果左侧是 False 那么右侧无论是什么都无所谓
Dialogue: 0,0:09:37.25,0:09:41.36,Default,,0,0,0,,结果总是 False
Dialogue: 0,0:09:41.36,0:09:58.43,Default,,0,0,0,,这是 && 的最优定义 因为它仅对第一个参数进行必要的求值
Dialogue: 0,0:09:58.43,0:10:10.75,Default,,0,0,0,,Haskell 中的模式是按顺序匹配的 准确来讲是 从左到右 从上到下
Dialogue: 0,0:10:10.75,0:10:20.67,Default,,0,0,0,,编译器不会对模式进行重排来优化 因为顺序很重要
Dialogue: 0,0:10:20.67,0:10:29.70,Default,,0,0,0,,也可以把模式匹配和守卫等式混合使用
Dialogue: 0,0:10:29.70,0:10:37.40,Default,,0,0,0,,可以简单记住 模式是从左到右 从上到下进行匹配的
Dialogue: 0,0:10:37.40,0:10:40.65,Default,,0,0,0,,变量不能重复
Dialogue: 0,0:10:40.65,0:10:51.10,Default,,0,0,0,,比如不能写 b && b 等于 b 假设其中的 b 是相等的
Dialogue: 0,0:10:51.10,0:10:55.98,Default,,0,0,0,,模式中的变量都应该是唯一的
Dialogue: 0,0:10:55.98,0:11:13.16,Default,,0,0,0,,我们讲过用方括号表示列表 这实际上只是使用 cons 和空表的语法糖
Dialogue: 0,0:11:13.16,0:11:24.34,Default,,0,0,0,,当一个列表出现在某处时 意思是下面这样的 但在模式匹配中
Dialogue: 0,0:11:24.34,0:11:34.70,Default,,0,0,0,,常常需要将列表写成下面的形式 比如定义列表的头元素 head 可以用如下的模式匹配
Dialogue: 0,0:11:34.70,0:11:42.54,Default,,0,0,0,,我们将列表写为 头（head） cons 尾（tail）形式
Dialogue: 0,0:11:42.54,0:11:51.21,Default,,0,0,0,,一个列表分成头元素 x 和一个不关心的尾 其头元素就是 x
Dialogue: 0,0:11:51.21,0:11:58.34,Default,,0,0,0,,一个列表分成一个我不关心的头元素和一个尾 xs 其尾就是 xs
Dialogue: 0,0:11:58.34,0:12:01.58,Default,,0,0,0,,这是一个很简洁的定义
Dialogue: 0,0:12:01.58,0:12:10.62,Default,,0,0,0,,让我们看看类型 tail 接收一个列表 由于列表的尾仍然是一个列表 因此类型是 列表到列表
Dialogue: 0,0:12:10.62,0:12:24.41,Default,,0,0,0,,head 接收列表 但其头元素的值是列表的元素类型 因此其类型是 [a] 到 a
Dialogue: 0,0:12:24.41,0:12:35.77,Default,,0,0,0,,当然 它们不是全函数（total function）因为没有在空表上定义 当将 head 应用到空表上时 没有模式匹配上
Dialogue: 0,0:12:35.77,0:12:39.50,Default,,0,0,0,,因此会出错 tail 也一样
Dialogue: 0,0:12:39.50,0:13:05.36,Default,,0,0,0,,另一种说法是 x:xs 这样的模式只匹配非空列表 如果用空列表调用 head 不会匹配 因为它不是 x cons 什么的形式
Dialogue: 0,0:13:05.36,0:13:13.37,Default,,0,0,0,,当 head 应用到空表上时 没有模式匹配 因此会出错
Dialogue: 0,0:13:13.37,0:13:22.29,Default,,0,0,0,,另一件事是要在列表模式上加括号 因为函数应用具有最强的结合性
Dialogue: 0,0:13:22.29,0:13:34.54,Default,,0,0,0,,因此这里的意思变成了 x 的头元素再 cons 上任何东西 只有加上括号才能正常工作
Dialogue: 0,0:13:34.54,0:13:39.32,Default,,0,0,0,,这是在 Haskell 中定义函数的第一部分
Dialogue: 0,0:13:39.32,0:13:40.55,Default,,0,0,0,,休息之后再见
