[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: None

[Aegisub Project Garbage]
Active Line: 3

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,Arial,20,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,2,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:01.81,0:00:03.39,Default,,0,0,0,,欢迎回到
Dialogue: 0,0:00:03.39,0:00:06.62,Default,,0,0,0,,FP 101 函数式程序设计
Dialogue: 0,0:00:06.62,0:00:10.42,Default,,0,0,0,,今天讨论的是类型（type）与类（class）
Dialogue: 0,0:00:10.42,0:00:24.18,Default,,0,0,0,,作为开发者 我们经常熬夜 常常过于专注以致于忘了时间
Dialogue: 0,0:00:24.18,0:00:27.99,Default,,0,0,0,,因此应当特别注意饮食
Dialogue: 0,0:00:27.99,0:00:31.58,Default,,0,0,0,,确保吃好喝好
Dialogue: 0,0:00:31.58,0:00:38.23,Default,,0,0,0,,在这个营养金字塔中
Dialogue: 0,0:00:38.23,0:00:44.29,Default,,0,0,0,,食物被分成了不同类别 比如面包 米饭 意大利面
Dialogue: 0,0:00:44.29,0:00:48.19,Default,,0,0,0,,属于碳水化合物类
Dialogue: 0,0:00:48.19,0:00:53.32,Default,,0,0,0,,其他的还有蛋白质 水果和蔬菜等
Dialogue: 0,0:00:53.32,0:01:04.72,Default,,0,0,0,,所有的食物根据某种共同的属性被分成了不同的组
Dialogue: 0,0:01:04.72,0:01:11.76,Default,,0,0,0,,可以根据这些分组说 食物是有类型的
Dialogue: 0,0:01:11.76,0:01:23.39,Default,,0,0,0,,这就是本节课要讲的 如何将代码中 具有相似属性的值（而非食物）分成不同类别
Dialogue: 0,0:01:23.39,0:01:27.86,Default,,0,0,0,,什么是类型
Dialogue: 0,0:01:27.86,0:01:35.86,Default,,0,0,0,,类型仅仅是一组有关联的值的名字
Dialogue: 0,0:01:35.86,0:01:46.00,Default,,0,0,0,,类似于食物的类型 就是一组有关联的食物集合的名字而已
Dialogue: 0,0:01:46.00,0:01:55.64,Default,,0,0,0,,编程中 类型就是一组相互关联的且有共同属性的值的集合名字
Dialogue: 0,0:01:55.64,0:02:04.09,Default,,0,0,0,,比如 Haskell 中 Bool 类型就由两个值组成 False 和 True
Dialogue: 0,0:02:04.09,0:02:15.73,Default,,0,0,0,,严格来讲 Haskell 中还有第三个值 Bottom 代表 Bool 类型的非中止计算
Dialogue: 0,0:02:15.73,0:02:19.70,Default,,0,0,0,,但本课程中仅讲基础内容
Dialogue: 0,0:02:19.70,0:02:27.70,Default,,0,0,0,,因此会忽略 Bottom 这样的复杂的特性
Dialogue: 0,0:02:27.70,0:02:40.34,Default,,0,0,0,,目前将 Bool 当作 True 和 False 两个布尔值的集合的名字
Dialogue: 0,0:02:40.34,0:02:54.09,Default,,0,0,0,,类型错误指 调用函数时 使用了意料之外的类型 看下面的例子
Dialogue: 0,0:02:54.09,0:03:05.62,Default,,0,0,0,,如果将 1 加到 False 上 当然不会成功 因为左侧是数字 右侧是布尔值
Dialogue: 0,0:03:05.62,0:03:12.90,Default,,0,0,0,,没办法将一个数字加到一个布尔值上
Dialogue: 0,0:03:12.90,0:03:17.00,Default,,0,0,0,,回到饮食的例子上
Dialogue: 0,0:03:17.00,0:03:26.47,Default,,0,0,0,,某种饮食方式可能不允许将肉和奶制品混合到一起 这就是食物中的类型错误
Dialogue: 0,0:03:26.47,0:03:33.26,Default,,0,0,0,,编程中也有类似的类型错误
Dialogue: 0,0:03:33.26,0:03:41.95,Default,,0,0,0,,静态类型的目标是让编译器提前发现类型错误 也就是在运行之前
Dialogue: 0,0:03:41.95,0:03:56.85,Default,,0,0,0,,动态类型语言中 类型错误在运行时中发现 也就是布尔值与数字实际相加时
Dialogue: 0,0:03:56.85,0:04:10.41,Default,,0,0,0,,无类型语言中 仅仅取出两个值的表示形式并试图相加
Dialogue: 0,0:04:10.41,0:04:18.07,Default,,0,0,0,,Haskell 中表达类型的语法是两个英文冒号加类型
Dialogue: 0,0:04:18.07,0:04:29.69,Default,,0,0,0,,比如对表达式 e 的求值 返回值是 t 类型的话 就写 e :: t
Dialogue: 0,0:04:29.69,0:04:40.31,Default,,0,0,0,,不同语言中语法不同 比如 Visual Basic 中写 e as t 而在 Java 中写 t e
Dialogue: 0,0:04:40.31,0:04:51.09,Default,,0,0,0,,但那仅仅是语法不同 重要的是语义 也就是表达式 e 具有类型 t
Dialogue: 0,0:04:51.09,0:04:59.29,Default,,0,0,0,,每一个语法良构的表达式都有一个类型
Dialogue: 0,0:04:59.29,0:05:09.58,Default,,0,0,0,,在编译时 这个类型被编译器用一种称为 类型推断 的过程计算出来
Dialogue: 0,0:05:09.58,0:05:23.61,Default,,0,0,0,,记得第一讲中提到了 ML 它是第一个支持类型推断的语言
Dialogue: 0,0:05:23.61,0:05:34.39,Default,,0,0,0,,Haskell 中的类型错误在编译时发现 大多数编程语言也在编译时
Dialogue: 0,0:05:34.39,0:05:42.33,Default,,0,0,0,,目前关于是用静态类型还是动态类型 还是可选类型 有不同的观点
Dialogue: 0,0:05:42.33,0:05:46.17,Default,,0,0,0,,就我个人而言 更喜欢静态
Dialogue: 0,0:05:46.17,0:05:55.25,Default,,0,0,0,,我很懒 因此希望编译器提前帮我发现类型错误
Dialogue: 0,0:05:55.25,0:06:00.43,Default,,0,0,0,,之前的课程中讲了 GHC 的使用方法 其中有一个特殊的指令 :type
Dialogue: 0,0:06:00.43,0:06:09.53,Default,,0,0,0,,可以让 GHC 帮你推断表达式的类型 并告诉你
Dialogue: 0,0:06:09.53,0:06:17.31,Default,,0,0,0,,比如输入 not False GHC 会计算 not False 的结果是 True
Dialogue: 0,0:06:17.31,0:06:20.97,Default,,0,0,0,,也可以问 not False 的类型是什么
Dialogue: 0,0:06:20.97,0:06:31.09,Default,,0,0,0,,此时不会对表达式求值 仅仅会计算类型 not False 的类型是 Bool
Dialogue: 0,0:06:31.09,0:06:37.69,Default,,0,0,0,,可以看到 not False 的值是 True 类型是 Bool 因此是一致的
Dialogue: 0,0:06:37.69,0:06:50.38,Default,,0,0,0,,GHC 做的不错 如果 not False 的类型是整数 但值是 True 就太奇怪了 这被称为类型可靠（或类型健全）
Dialogue: 0,0:06:50.38,0:07:03.85,Default,,0,0,0,,意思是编译器计算出来的类型与运行时求出来的值相一致
Dialogue: 0,0:07:03.85,0:07:07.96,Default,,0,0,0,,Haskell 和大多数编程语言中都有一些基本类型
Dialogue: 0,0:07:07.96,0:07:11.01,Default,,0,0,0,,也就是内置于编程语言中的类型
Dialogue: 0,0:07:11.01,0:07:14.21,Default,,0,0,0,,Haskell 有以下这些
Dialogue: 0,0:07:14.21,0:07:23.33,Default,,0,0,0,,我们已经看到了 Bool 类型 包含布尔值 True 和 False 还有字符类型
Dialogue: 0,0:07:23.33,0:07:28.48,Default,,0,0,0,,Char 是表示字符的值的集合的名字
Dialogue: 0,0:07:28.48,0:07:38.04,Default,,0,0,0,,Char 中包含 a b c 等等字母 还有所有的 Unicode 字符 此外还有表示字符串的 String 类型
Dialogue: 0,0:07:38.04,0:07:42.19,Default,,0,0,0,,也就是一串字符 之后我们会看到 在 Haskell 中
Dialogue: 0,0:07:42.19,0:07:45.81,Default,,0,0,0,,字符串仅仅是字符的列表
Dialogue: 0,0:07:45.81,0:07:55.69,Default,,0,0,0,,你可以认为 String 并非 Haskell 基本类型 因为它是用另外两个基本类型定义的 也就是列表和字符
Dialogue: 0,0:07:55.69,0:08:03.65,Default,,0,0,0,,Haskell 有个特别的地方 Python 中也有类似
Dialogue: 0,0:08:03.65,0:08:07.13,Default,,0,0,0,,即语言中既有 Int 类型 也有 Integer 类型
Dialogue: 0,0:08:07.13,0:08:12.99,Default,,0,0,0,,Ints 是定点整数 32 位或 64 位整数
Dialogue: 0,0:08:12.99,0:08:16.53,Default,,0,0,0,,而 Integer 是任意精度的整数
Dialogue: 0,0:08:16.53,0:08:25.79,Default,,0,0,0,,用 Integer 类型可以计算 500 的阶乘 虽然会用很长时间
Dialogue: 0,0:08:25.79,0:08:36.39,Default,,0,0,0,,但不会像用 Int 一样发生溢出 当然还有 Float 类型表示浮点数
Dialogue: 0,0:08:36.39,0:08:52.99,Default,,0,0,0,,当讲到字符时 我提到了字符串类型 String 仅仅是字符的列表  列表类型是我们在 Haskell 中遇到的第一个泛型类型 或称为多态类型
Dialogue: 0,0:08:52.99,0:08:58.18,Default,,0,0,0,,列表就是相同类型元素的序列
Dialogue: 0,0:08:58.18,0:09:05.49,Default,,0,0,0,,第一个例子是三个布尔值的列表 False True False
Dialogue: 0,0:09:05.49,0:09:16.26,Default,,0,0,0,,可以看到类型记号 冒号冒号 后面的类型是 Bool 的列表 Haskell 的一个很好的特性是
Dialogue: 0,0:09:16.26,0:09:27.89,Default,,0,0,0,,这里左侧值的语法 看起来和右面的类型的语法十分相似
Dialogue: 0,0:09:27.89,0:09:42.36,Default,,0,0,0,,我们用方括号表示值的列表 也用同样的方括号表示类型 因此 [False, True, False] 类型是 [Bool]
Dialogue: 0,0:09:42.36,0:09:50.98,Default,,0,0,0,,第二个例子是 a b c d 的列表 其类型是字符类型的列表
Dialogue: 0,0:09:50.98,0:09:55.76,Default,,0,0,0,,和字符串的类型一样
Dialogue: 0,0:09:55.76,0:10:07.36,Default,,0,0,0,,一般而言 [t] 表示 t 类型元素组成的列表类型
Dialogue: 0,0:10:07.36,0:10:12.04,Default,,0,0,0,,注意列表的类型中没有其长度信息
Dialogue: 0,0:10:12.04,0:10:16.62,Default,,0,0,0,,列表 False True 的类型是 [Bool]
Dialogue: 0,0:10:16.62,0:10:23.98,Default,,0,0,0,,如果值是 False True False 类型也是 [Bool]
Dialogue: 0,0:10:23.98,0:10:31.74,Default,,0,0,0,,元素可以是任意类型 只要所有元素类型都相同即可
Dialogue: 0,0:10:31.74,0:10:38.60,Default,,0,0,0,,最后一个例子类型有些复杂
Dialogue: 0,0:10:38.60,0:10:42.24,Default,,0,0,0,,是一个字符列表的列表 也就是这里写的
Dialogue: 0,0:10:42.24,0:10:48.22,Default,,0,0,0,,字符列表的列表 它的值是两个字符列表
Dialogue: 0,0:10:48.22,0:10:54.94,Default,,0,0,0,,列表只要求元素类型相同 但长度不受限制
Dialogue: 0,0:10:54.94,0:10:58.57,Default,,0,0,0,,这和元组（tuple）不同
Dialogue: 0,0:10:58.57,0:11:08.30,Default,,0,0,0,,元组中类型包括了长度信息 但值的类型可以不同
Dialogue: 0,0:11:08.30,0:11:15.45,Default,,0,0,0,,第一个例子是两个布尔值的元组 True 和 False
Dialogue: 0,0:11:15.45,0:11:18.50,Default,,0,0,0,,类型是 (Bool, Bool)
Dialogue: 0,0:11:18.50,0:11:22.69,Default,,0,0,0,,这不是列表 假如是列表 类型就应该是 [Bool]
Dialogue: 0,0:11:22.69,0:11:29.22,Default,,0,0,0,,但这里是两个布尔值的元组 True 和 False 类型是 (Bool, Bool)
Dialogue: 0,0:11:29.22,0:11:33.88,Default,,0,0,0,,第二个例子的类型是 (Bool, Char, Bool)
Dialogue: 0,0:11:33.88,0:11:38.54,Default,,0,0,0,,可以看到包含了三个值
Dialogue: 0,0:11:38.54,0:11:45.00,Default,,0,0,0,,第一个是布尔值 第二个是单个字符 第三个又是布尔值
Dialogue: 0,0:11:45.00,0:11:48.63,Default,,0,0,0,,这也在类型中反映出来了
Dialogue: 0,0:11:48.63,0:12:00.60,Default,,0,0,0,,一般地 如果元组类型是 (t1, ... , tn) 其值是一个值的元组且对应位置上的类型是 t1 到 tn
Dialogue: 0,0:12:00.60,0:12:17.19,Default,,0,0,0,,元组的类型包含了大小 (True, False) 和 (False, True) 的类型是 (Bool, Bool) 可以看到类型反映了长度
Dialogue: 0,0:12:17.19,0:12:25.97,Default,,0,0,0,,第二个例子中有三个布尔值 因此类型也是三个布尔类型
Dialogue: 0,0:12:25.97,0:12:30.11,Default,,0,0,0,,值的类型不受限制 因此可以混合搭配
Dialogue: 0,0:12:30.11,0:12:39.66,Default,,0,0,0,,这个元组包含一个字符 第二个值是一个由布尔值和字符组成的元组
Dialogue: 0,0:12:39.66,0:12:43.01,Default,,0,0,0,,最后一个例子是一个元组
Dialogue: 0,0:12:43.01,0:12:46.39,Default,,0,0,0,,第一个值是布尔值 之后是字符列表
Dialogue: 0,0:12:46.39,0:12:51.32,Default,,0,0,0,,这里是布尔值 True
Dialogue: 0,0:12:51.32,0:12:59.85,Default,,0,0,0,,接下来是 a b 字符的列表 可以看到类型是 (Bool, [Char])
Dialogue: 0,0:12:59.85,0:13:03.16,Default,,0,0,0,,关于类型的第一部分到此结束
Dialogue: 0,0:13:03.16,0:13:10.77,Default,,0,0,0,,接下来要讲函数 我们学的是函数式程序设计 因此函数很重要
Dialogue: 0,0:13:10.77,0:13:14.27,Default,,0,0,0,,我们将仔细讨论函数 谢谢
Dialogue: 0,0:13:14.27,0:13:15.69,Default,,0,0,0,,休息之后再见
