1
00:00:01,520 --> 00:00:03,560
欢迎大家参加

2
00:00:03,560 --> 00:00:08,849
FP101x 函数式程序设计

3
00:00:08,849 --> 00:00:12,820
这门慕课

4
00:00:12,820 --> 00:00:17,820
让我们现在就开始吧

5
00:00:17,820 --> 00:00:23,480
在讨论其他事情之前 我想说的是

6
00:00:23,480 --> 00:00:28,160
正如标题所说 这门慕课是关于函数式程序设计的

7
00:00:28,160 --> 00:00:33,920
它不是一门 Haskell 课程 我们是将 Haskell

8
00:00:33,920 --> 00:00:39,379
作为一门函数式语言 但我们不是学习如何用 Haskell 编程的

9
00:00:39,379 --> 00:00:42,469
让我给你讲一个小故事吧

10
00:00:42,469 --> 00:00:46,000
我经常旅行 开会

11
00:00:46,000 --> 00:00:49,200
讲课 等等

12
00:00:49,200 --> 00:00:52,989
旅行途中 我有很多时间来看电视

13
00:00:52,989 --> 00:00:57,520
有一天晚上 当我随意调台时

14
00:00:57,520 --> 00:01:00,770
看到一档求生类节目

15
00:01:00,770 --> 00:01:03,960
里面一个人试着在晚上扎营

16
00:01:03,960 --> 00:01:07,340
并且想要点火

17
00:01:07,340 --> 00:01:10,939
但是火柴都湿了

18
00:01:10,939 --> 00:01:14,030
也许他会很慌乱并说

19
00:01:14,030 --> 00:01:17,250
我的火柴湿了 点不着火了

20
00:01:17,250 --> 00:01:20,680
但他做的却是拿出一部手机

21
00:01:20,680 --> 00:01:23,840
用他的刀

22
00:01:23,840 --> 00:01:27,869
把电池从上面拆了下来 并打开了电池

23
00:01:27,869 --> 00:01:30,869
之后电池开始燃烧

24
00:01:30,869 --> 00:01:35,220
他就用这个点着了火

25
00:01:35,220 --> 00:01:38,380
这也是我想在这门课中教给你的态度

26
00:01:38,380 --> 00:01:42,530
当我们用 Haskell 学习函数式程序设计时

27
00:01:42,530 --> 00:01:44,159
Haskell 是我们的火柴

28
00:01:44,159 --> 00:01:47,860
在实际工作中 你可能没有火柴能用

29
00:01:47,860 --> 00:01:52,950
但你仍然可以进行函数式编程 有时你需要拆开你的手机

30
00:01:52,950 --> 00:01:58,320
打开你的电池才能生火 别认为这只是关于

31
00:01:58,320 --> 00:02:02,030
Haskell 的 我们用是 Haskell 但教的是函数式程序设计

32
00:02:02,030 --> 00:02:09,869
好了 现在让我们开始吧

33
00:02:09,869 --> 00:02:13,090
我们要解决的是什么问题？

34
00:02:13,090 --> 00:02:17,000
要解决的问题就是所谓的 软件危机

35
00:02:17,000 --> 00:02:21,090
我们都知道开发者写代码十分困难

36
00:02:21,090 --> 00:02:24,180
我们需要写大型的程序

37
00:02:24,180 --> 00:02:28,500
同时又要缩减开发时间 降低开发成本

38
00:02:28,500 --> 00:02:32,830
我们希望快速发布软件

39
00:02:32,830 --> 00:02:37,200
又希望发布的软件正确无误

40
00:02:37,200 --> 00:02:40,440
问题是我们如何写程序

41
00:02:40,440 --> 00:02:44,260
来保证我们有信心认为软件正确工作呢？

42
00:02:44,260 --> 00:02:47,609
我们又如何写代码

43
00:02:47,609 --> 00:02:50,959
来实现快速发布

44
00:02:50,959 --> 00:02:54,370
不是几年后才发布

45
00:02:54,370 --> 00:03:00,970
而是几个月或者更短 一种现代编程语言中

46
00:03:00,970 --> 00:03:06,260
常见的实现方式是 为编程语言增加特性

47
00:03:06,260 --> 00:03:12,220
允许程序的表达方式简洁清晰 抽象层次也较高

48
00:03:12,220 --> 00:03:16,319
我们在现代编程语言中使用的这些技术

49
00:03:16,319 --> 00:03:19,880
都是基于函数式程序设计

50
00:03:19,880 --> 00:03:23,989
基于 lambda 演算的概念

51
00:03:23,989 --> 00:03:30,660
Haskell 是一种纯函数式编程语言

52
00:03:30,660 --> 00:03:34,669
因此适用于这些概念的教学

53
00:03:34,669 --> 00:03:42,799
函数式编程语言则提供一种十分优雅的框架

54
00:03:42,799 --> 00:03:46,120
让我们在一个较高的抽象层次写代码

55
00:03:46,120 --> 00:03:50,139
但正如我说过的 Haskell 只是一个工具

56
00:03:50,139 --> 00:03:55,329
我们在这门课中所学到的东西

57
00:03:55,329 --> 00:03:59,169
你可以用于任何编程语言 即使你用的是汇编语言

58
00:03:59,169 --> 00:04:06,489
Java 或 PHP 或者 JavaScript 你在这里学习到的想法

59
00:04:06,489 --> 00:04:09,720
可以立刻用在

60
00:04:09,720 --> 00:04:13,150
无论你用的哪种编程语言中

61
00:04:13,150 --> 00:04:16,930
那么什么是函数式编程语言呢？

62
00:04:16,930 --> 00:04:20,700
可能的回答有很多

63
00:04:20,700 --> 00:04:24,960
现在还没有明确的定义

64
00:04:24,960 --> 00:04:28,740
如果我们考虑最纯的函数式编程语言

65
00:04:28,740 --> 00:04:32,800
那么函数式编程语言就是使用数学函数编程的语言

66
00:04:32,800 --> 00:04:38,830
这一定义适用于 Haskell 它本身是一门 纯函数式语言

67
00:04:38,830 --> 00:04:42,320
在函数式语言中仅有很少几门是纯的

68
00:04:42,320 --> 00:04:47,670
当然 我在说我们可以将这些技术应用到其他编程语言中 的时候

69
00:04:47,670 --> 00:04:52,020
我们不能使用这个定义

70
00:04:52,020 --> 00:04:56,020
我们要用的时下面的定义

71
00:04:56,020 --> 00:04:56,930
函数式编程语言

72
00:04:56,930 --> 00:05:00,900
是一种编程的风格

73
00:05:00,900 --> 00:05:04,310
其中表达式比语句更为重要

74
00:05:04,310 --> 00:05:09,000
我们想做的事情时用表达式组成程序

75
00:05:09,000 --> 00:05:14,530
这些表达式都可以求值 因此我们可以把两个可以求值的表达式

76
00:05:14,530 --> 00:05:18,620
组合起来成为一个更大的表达式

77
00:05:18,620 --> 00:05:23,780
比较一下使用语句编程

78
00:05:23,780 --> 00:05:28,040
当你将语句组合起来的时候 每条语句都有隐藏的副作用

79
00:05:28,040 --> 00:05:32,410
这些副作用影响全局状态 它们通过全局状态实现通信

80
00:05:32,880 --> 00:05:36,000
而使用表达式编程时

81
00:05:36,000 --> 00:05:40,620
表达式返回一个值

82
00:05:40,620 --> 00:05:46,320
我们直接将值组合起来 一门函数式编程语言

83
00:05:46,320 --> 00:05:50,190
就是支持并且鼓励

84
00:05:50,190 --> 00:05:53,410
使用表达式编程的语言

85
00:05:53,410 --> 00:06:01,240
正如我说过的 大部分现代语言都支持这种风格

86
00:06:01,240 --> 00:06:04,850
特别时通过支持 lambda 表达式来实现这一点

87
00:06:04,850 --> 00:06:08,830
随着课程的进行 我们可以在很多语言中

88
00:06:08,830 --> 00:06:11,960
看到函数式编程的例子

89
00:06:11,960 --> 00:06:19,190
让我们从第一段代码开始吧

90
00:06:19,190 --> 00:06:22,440
这是一种传统 Java 编程风格

91
00:06:22,440 --> 00:06:27,070
我们要计算 1 到 10 的加和

92
00:06:27,070 --> 00:06:31,250
我们做的方式 使用传统的过程式编程风格

93
00:06:31,250 --> 00:06:33,820
它是基于语句的

94
00:06:33,820 --> 00:06:38,530
我们做的第一件事是声明了一个整数类型的

95
00:06:38,530 --> 00:06:41,920
变量 total 并将它初始化为 0

96
00:06:41,920 --> 00:06:46,380
接下来我们用一个循环变量写一个 for 循环

97
00:06:46,380 --> 00:06:49,660
你可以看到这边的变量 i

98
00:06:49,660 --> 00:06:53,530
然后我们给 total 变量赋值

99
00:06:53,530 --> 00:06:57,100
成为 total + i 你可以看到

100
00:06:57,100 --> 00:07:00,240
这个程序是用一种

101
00:07:00,240 --> 00:07:03,860
过程式的风格写的 我们有语句

102
00:07:03,860 --> 00:07:06,990
我们有可变状态

103
00:07:06,990 --> 00:07:10,660
我们过程式地执行一条语句接一条语句

104
00:07:10,660 --> 00:07:14,160
更新状态来计算最终结果

105
00:07:14,160 --> 00:07:18,710
这是你用 Haskell 编写相同程序的方法

106
00:07:18,710 --> 00:07:21,980
你首先能看到的是

107
00:07:21,980 --> 00:07:26,980
程序更加简洁 此外 没有语句了

108
00:07:26,980 --> 00:07:30,230
只有两个表达式

109
00:07:30,230 --> 00:07:36,740
右面这个 1 点点 10 （1..10）

110
00:07:36,740 --> 00:07:40,300
创建了一个从 1 到 10 的整数列表

111
00:07:40,300 --> 00:07:43,920
然后我们将这些整数相加

112
00:07:43,920 --> 00:07:47,380
你可以看到我们将表达式

113
00:07:47,380 --> 00:07:52,670
组合成为程序 一个表达式创建从 1 到 10 的列表

114
00:07:52,670 --> 00:07:56,600
我们将它的返回值传给

115
00:07:56,600 --> 00:07:59,680
sum 函数上 从而把内容求和

116
00:07:59,680 --> 00:08:03,080
在 Java 8 中

117
00:08:03,080 --> 00:08:06,670
你可以用 Java 8 的流（streams）

118
00:08:06,670 --> 00:08:10,040
写同样的程序

119
00:08:10,040 --> 00:08:14,070
我们将在未来的课程中深入探讨 Java 8

120
00:08:14,070 --> 00:08:17,590
但现在我们只看用 Haskell 实现的方式

121
00:08:17,590 --> 00:08:21,990
十分感谢

122
00:08:21,990 --> 00:08:24,590
第二部分再见

