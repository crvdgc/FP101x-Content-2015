1
00:00:00,919 --> 00:00:05,140
欢迎回来 希望你已经安装了 GHC

2
00:00:05,140 --> 00:00:08,599
也尝试了一下输入表达式

3
00:00:08,599 --> 00:00:13,330
现在要从简单表达式更进一步

4
00:00:13,330 --> 00:00:18,350
看看如何将整个Haskell 程序载入 GHC 中

5
00:00:18,350 --> 00:00:23,310
在 Haskell 中 程序并不叫程序

6
00:00:23,310 --> 00:00:27,260
通常人们称代码为

7
00:00:27,260 --> 00:00:30,689
脚本

8
00:00:30,689 --> 00:00:34,190
因为 Haskell 的程序比通常的代码短

9
00:00:34,190 --> 00:00:37,730
我通常就叫程序

10
00:00:37,730 --> 00:00:44,899
但 Haskell 的说法是脚本 

11
00:00:44,899 --> 00:00:50,610
如果你想定义一个完整的程序

12
00:00:50,610 --> 00:00:53,870
可以将他们定义在

13
00:00:53,870 --> 00:00:57,170
一个含有函数列表的文本文件中

14
00:00:57,170 --> 00:01:00,840
这一文本文件

15
00:01:00,840 --> 00:01:06,040
后缀是 .hs 表示

16
00:01:06,040 --> 00:01:10,170
它是一个 Haskell 文件 好比 HTML 文件

17
00:01:10,170 --> 00:01:14,340
后缀名是 .html CSS 文件后缀名是 .css

18
00:01:14,340 --> 00:01:17,890
或者 Java 文件

19
00:01:17,890 --> 00:01:21,350
后缀名是 .java

20
00:01:21,350 --> 00:01:25,000
Haskell 文件是以 .hs 结尾的

21
00:01:25,000 --> 00:01:29,049
虽然不是必须这样

22
00:01:29,049 --> 00:01:32,320
但很有用 当你查看文件夹时

23
00:01:32,320 --> 00:01:35,689
就可以看到这是一个 Haskell 脚本文件

24
00:01:35,689 --> 00:01:44,430
使用 GHC 时

25
00:01:44,430 --> 00:01:52,049
要做的是在一个窗口用一个文本编辑器编辑脚本

26
00:01:52,049 --> 00:01:59,460
做出改变后  将脚本重新载入 GHC

27
00:01:59,460 --> 00:02:03,590
再开始执行表达式 你在课程中主要用到的

28
00:02:03,590 --> 00:02:07,369
工作流就是这样 对于简单的应用

29
00:02:07,369 --> 00:02:12,080
这样就够了 当然如果要写商业性的程序

30
00:02:12,080 --> 00:02:13,420
就不会这样了

31
00:02:13,420 --> 00:02:16,450
你会将脚本编译成为可独立执行的文件

32
00:02:16,450 --> 00:02:21,550
但这们课程中 我们只需要前面的方式

33
00:02:21,550 --> 00:02:25,950
一边开着编辑器的窗口 另一边开着 GHCi 解释器的窗口

34
00:02:25,950 --> 00:02:30,150
接下来载入脚本

35
00:02:30,150 --> 00:02:33,880
这个例子中

36
00:02:33,880 --> 00:02:37,140
我们新建一个名为 test.hs 的文本文件

37
00:02:37,140 --> 00:02:40,840
编写两个函数 第一个是求二倍函数

38
00:02:40,840 --> 00:02:45,380
double 也就是 x + x 顾名思义

39
00:02:45,380 --> 00:02:49,890
下一个是求四倍函数 quadruple 在 double x 上调用 double 实现

40
00:02:49,890 --> 00:02:55,459
保存文件

41
00:02:55,459 --> 00:02:59,690
用 test.hs 做参数运行 GHCi

42
00:02:59,690 --> 00:03:08,220
现在 Haskell 标准库和 test.hs 中定义的 quadruple 与 double

43
00:03:08,220 --> 00:03:12,030
都可以用了 比如我们调用

44
00:03:12,030 --> 00:03:13,500
10 的四倍

45
00:03:13,500 --> 00:03:16,819
返回值是 40

46
00:03:16,819 --> 00:03:21,049
同时仍然可以使用标准库函数 比如

47
00:03:21,049 --> 00:03:30,070
可以从列表取 2 的二倍个元素 2 的二倍是 4 相当于取 4 个元素

48
00:03:30,650 --> 00:03:33,820
因此从列表中取到了 4 个元素

49
00:03:33,820 --> 00:03:47,579
现在保持 GHCi 开启 回到编辑器窗口 添加

50
00:03:47,579 --> 00:03:56,750
两个新定义 一个是阶乘 另一个是均值 因为我们刚刚开始

51
00:03:56,750 --> 00:04:01,180
这里用到了一些还没学过的语法

52
00:04:01,180 --> 00:04:08,100
所以请忍一下 阶乘是从 1 到 n 的乘积 这里的

53
00:04:08,100 --> 00:04:11,840
是 1 到 n 的列表

54
00:04:11,840 --> 00:04:16,070
product 是一个标准库函数

55
00:04:16,070 --> 00:04:19,169
作用是取得列表中元素乘积

56
00:04:19,169 --> 00:04:29,350
这个定义实现了阶乘 接下来定义一个列表的均值

57
00:04:29,350 --> 00:04:38,020
首先求元素的和 接下来除以列表的长度 当然这并非一个求均值的好实现

58
00:04:38,020 --> 00:04:41,780
但现在并不重要

59
00:04:41,780 --> 00:04:45,750
我们并非要定义均值 而是要学 GHCi 的使用

60
00:04:45,750 --> 00:04:51,220
这里用到的技巧是 当你在 Haskell 中

61
00:04:51,220 --> 00:04:59,390
将一个函数的名字放在两个单反引号中间时

62
00:04:59,390 --> 00:05:02,580
就将它作为一个中缀操作符

63
00:05:02,580 --> 00:05:12,900
写 x `f` y 实际上就是语法糖

64
00:05:12,900 --> 00:05:18,410
f x y 一些人喜欢用中缀操作符

65
00:05:18,410 --> 00:05:21,640
另一些喜欢普通的方法

66
00:05:21,640 --> 00:05:26,960
你可以自己选择 因此这里是一个语法规则 而非字符串或是别的

67
00:05:26,960 --> 00:05:31,440
它将一个函数转换为中缀操作符

68
00:05:31,440 --> 00:05:35,290
在 GHCi 中我们用 :reload 重新加载

69
00:05:35,290 --> 00:05:42,920
它将读入 test.hs 文件 添加新定义的名字绑定

70
00:05:42,920 --> 00:05:46,410
也就是 factorial 因此可以在这里调用 factorial

71
00:05:46,410 --> 00:05:49,610
也可以调用 average

72
00:05:49,610 --> 00:05:54,520
请看这里的工作流程 保持 GHCi 窗口开启 进入编辑器

73
00:05:54,520 --> 00:06:03,430
进行编辑 重新加载 接下来可以试试你写的代码了 一些 Haskell 中的

74
00:06:03,430 --> 00:06:15,730
特殊的语法规定 函数名和参数名必须以小写字母开头

75
00:06:15,730 --> 00:06:26,720
可以用这样的形式定义函数 但开头必须小写

76
00:06:26,720 --> 00:06:30,580
可以在名字中用普通英文引号

77
00:06:30,580 --> 00:06:34,310
如果你懒得取新名字的话

78
00:06:34,310 --> 00:06:42,520
这也是我在其他语言中想念的特性 我想写 x 撇 x 两撇等等

79
00:06:42,520 --> 00:06:51,710
如果定义一个类型 首字母需要大写 因此才会这样

80
00:06:51,710 --> 00:06:58,180
Haskell 中类型和标识符在不同的名字空间中 这是用

81
00:06:58,180 --> 00:07:01,620
首字母大小写来区分的

82
00:07:01,620 --> 00:07:06,830
来自其他编程语言背景的人可能很困惑

83
00:07:06,830 --> 00:07:10,990
比如 Java C# 和 JavaScript.

84
00:07:10,990 --> 00:07:19,800
另一件事是 Haskell 中常用一种较弱的匈牙利命名法

85
00:07:19,800 --> 00:07:31,420
如果参数以 s 结尾 比如 xs ns 或 nss

86
00:07:31,420 --> 00:07:44,460
表示它们是 x 类型值的列表 n 类型的值的列表 有时 n 并不对应于

87
00:07:44,460 --> 00:07:49,360
类型名 但通常看到名字中的 s 就知道它是个列表了

88
00:07:49,360 --> 00:07:52,460
如果结尾有两个 s 

89
00:07:52,460 --> 00:07:55,910
就代表一个列表的列表

90
00:07:55,910 --> 00:07:59,630
这是一个惯例 如果想要看起来像真正的 Haskell 程序员一样

91
00:07:59,630 --> 00:08:03,370
你应该采用这一惯例 如果参数是一个列表

92
00:08:03,370 --> 00:08:10,410
就应该用 s 结尾 通常 Haskell 标识符很短 

93
00:08:10,410 --> 00:08:13,900
因此不叫它 elements 而叫 xs

94
00:08:13,900 --> 00:08:21,370
另一个和 Python 相同的有趣之处是

95
00:08:21,370 --> 00:08:25,050
空白是有意义的

96
00:08:25,050 --> 00:08:28,100
准确的规则很繁琐

97
00:08:28,100 --> 00:08:35,630
因为我们只用 Haskell 中很简单的部分

98
00:08:35,630 --> 00:08:40,880
知道这些就够了 如果有一系列的定义

99
00:08:40,880 --> 00:08:44,600
应在同一列起始

100
00:08:44,600 --> 00:08:55,300
a, b 和 c 都在同一列起始 这边 b 左侧有空格

101
00:08:55,300 --> 00:08:58,780
因此定义没有从相同列起始

102
00:08:58,780 --> 00:09:08,130
就出错了 这边的 c 和 a 没有和 b 在同一行起始也错了

103
00:09:08,130 --> 00:09:11,460
Haskell 中的空白是有意义的

104
00:09:11,460 --> 00:09:15,600
确保定义对其 这叫 布局规则

105
00:09:15,600 --> 00:09:26,080
布局规则是为了避免不必要的语法

106
00:09:26,080 --> 00:09:30,050
Haskell 程序员喜欢这样写 a = b + c where

107
00:09:30,050 --> 00:09:33,510
在 where 子句中 我们有一系列的定义

108
00:09:33,510 --> 00:09:40,440
它们以同一行起始 d 和 a 在同一行起始

109
00:09:40,440 --> 00:09:44,060
因此和 a 属于同一组

110
00:09:44,060 --> 00:09:47,950
你可以这样显式地写出来

111
00:09:47,950 --> 00:09:51,920
用花括号和分号

112
00:09:51,920 --> 00:09:59,850
但看起来太过啰唆 Haskell 程序员喜欢简洁

113
00:09:59,850 --> 00:10:03,110
因此经常使用有意义的空白

114
00:10:03,110 --> 00:10:06,640
这种写法略显笨拙

115
00:10:06,640 --> 00:10:10,520
如果你在 Haskell 中这样写代码 人们就会说

116
00:10:10,520 --> 00:10:14,090
你没做足那些训练

117
00:10:14,090 --> 00:10:21,090
这是一些有用的 GHC 命令

118
00:10:21,220 --> 00:10:29,620
强烈建议你试验一下 当你做

119
00:10:29,620 --> 00:10:33,220
接下来几课的练习时 确保利用好

120
00:10:33,220 --> 00:10:36,800
GHC 或其他的编译器的帮助

121
00:10:36,800 --> 00:10:41,930
我们看过了 reload 也可以用 load

122
00:10:41,930 --> 00:10:45,820
载入一个新脚本

123
00:10:45,820 --> 00:10:52,430
可以从解释器里打开编辑器

124
00:10:52,430 --> 00:10:56,270
编辑特定文件 或者当前文件

125
00:10:56,270 --> 00:10:59,880
这个命令很有用

126
00:10:59,880 --> 00:11:03,550
它给出表达式的类型 我经常使用

127
00:11:03,550 --> 00:11:11,589
我从不自己写类型 因此把表达式从编辑器粘贴到这里问一下类型

128
00:11:11,589 --> 00:11:19,649
用 :? 命令得到所有可用命令的列表

129
00:11:19,649 --> 00:11:23,970
和简短的解释 当然

130
00:11:23,970 --> 00:11:31,079
我希望你 不要 用最后这个命令退出 GHC

131
00:11:31,079 --> 00:11:39,709
但最后你还是要用的 接下来的八周将经常用 GHC

132
00:11:39,709 --> 00:11:46,660
网站上将有很多练习

133
00:11:46,660 --> 00:11:55,600
你可以用任何语言完成这些练习 不一定非要用 GHC

134
00:11:55,600 --> 00:12:06,610
但既然本讲讲的是 GHC 对应的练习也是针对 GHC 的

135
00:12:06,610 --> 00:12:10,680
一般而言 正如我在第一节课中所说的

136
00:12:10,680 --> 00:12:17,320
这是一门函数式程序设计课 而非 Haskell 课 更不是 GHC 课

137
00:12:17,320 --> 00:12:25,250
但本章的练习是关于 GHC 的 因为课程内容是 GHCi

138
00:12:25,250 --> 00:12:29,459
祝你 Hacking 愉快 下周再见！

