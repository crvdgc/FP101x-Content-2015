1
00:00:01,810 --> 00:00:03,050
大家欢迎回来

2
00:00:03,050 --> 00:00:09,990
来上 FP101x

3
00:00:09,990 --> 00:00:13,070
让我们现在开始吧

4
00:00:13,070 --> 00:00:16,359
首先介绍一点函数式程序设计的历史

5
00:00:16,359 --> 00:00:19,689
当我们看 Java 或 JavaScript 这样的语言时

6
00:00:19,689 --> 00:00:25,359
很容易忘记函数式程序设计的概念

7
00:00:25,359 --> 00:00:28,779
实际上非常古老

8
00:00:28,779 --> 00:00:35,540
甚至是在我们大多数人出生之前就被发明了

9
00:00:35,540 --> 00:00:39,870
这位是阿隆佐·邱奇（Alonzo Church）

10
00:00:39,870 --> 00:00:44,040
他在20世纪30年代发明了 lambda 演算

11
00:00:44,040 --> 00:00:47,960
他是打算将 lambda 演算作为数学的基础的

12
00:00:47,960 --> 00:00:51,930
他想要找到一种方式

13
00:00:51,930 --> 00:00:55,100
来描述数学的基础

14
00:00:55,100 --> 00:00:58,140
结果令人惊奇的是

15
00:00:58,140 --> 00:01:02,399
他在20世纪30年代的工作

16
00:01:02,399 --> 00:01:06,619
成为了今天大多数编程语言的基础

17
00:01:06,619 --> 00:01:10,360
如果你去看 JavaScript 这门支撑起万维网的语言

18
00:01:10,360 --> 00:01:14,369
我们都知道在 JavaScript 中函数很重要

19
00:01:14,369 --> 00:01:17,670
所以人们可以说

20
00:01:17,670 --> 00:01:20,780
是 lambda 演算支持着万维网

21
00:01:20,780 --> 00:01:28,290
现在 Java 8 也有 lambda 表达式 C++

22
00:01:28,290 --> 00:01:32,619
也有 lambda 表达式 如今正在使用的编程语言没有一门

23
00:01:32,619 --> 00:01:35,970
不支持阿隆佐·丘奇

24
00:01:35,970 --> 00:01:41,720
在20世纪30年代发明的这个概念

25
00:01:41,720 --> 00:01:44,970
如果再靠近现代一点

26
00:01:44,970 --> 00:01:48,439
20世纪50年代，约翰·麦卡锡

27
00:01:48,439 --> 00:01:53,009
发明了 Lisp 语言 这是最早几门编程语言之一

28
00:01:53,009 --> 00:02:02,070
它同时也是第一个 函数式编程语言 约翰·麦卡锡（John McCarthy）

29
00:02:02,070 --> 00:02:06,659
受 lambda 演算影响 但他也同时

30
00:02:06,659 --> 00:02:12,290
也在 Lisp 中设计了过程式的赋值

31
00:02:12,290 --> 00:02:20,019
在某种程度上你可以说 Lisp 是最早的 几门现代语言之一

32
00:02:20,019 --> 00:02:33,040
它结合了纯 lambda 演算的思想 以及一些编程语言中的过程式特性

33
00:02:33,040 --> 00:02:36,700
在20世纪60年代 彼得·兰丁发明了 ISWIM

34
00:02:36,700 --> 00:02:40,150
意思是 如果你知道我的意思是什么（If You See What I Mean）

35
00:02:40,150 --> 00:02:44,200
它是第一个纯函数式语言

36
00:02:44,200 --> 00:02:48,049
基于 lambda 演算 这也意味着

37
00:02:48,049 --> 00:02:51,930
语言中没有赋值 只有纯函数

38
00:02:51,930 --> 00:03:01,340
20世纪70年代 约翰·巴科斯（John Backus） 设计了 FP 意思是

39
00:03:01,340 --> 00:03:04,349
函数式编程（Functional Programming） 约翰·巴科斯

40
00:03:04,349 --> 00:03:07,900
同时也是 Fortran 的设计者之一

41
00:03:07,900 --> 00:03:11,629
那门语言大约是和 Lisp 同时设计出来的

42
00:03:11,629 --> 00:03:14,970
是一门过程特性十分强的语言

43
00:03:14,970 --> 00:03:19,840
他在七十年代设计了这门新语言

44
00:03:19,840 --> 00:03:22,900
强调高阶函数

45
00:03:22,900 --> 00:03:26,829
并特别强调对程序进行推理

46
00:03:26,829 --> 00:03:33,989
希望能够推理得出 FP 代码的正确性

47
00:03:33,989 --> 00:03:38,510
FP 对这点十分强调 同样在七十年代

48
00:03:38,510 --> 00:03:41,959
这边的这位罗宾·米尔纳（Robin Milner）

49
00:03:41,959 --> 00:03:45,019
发明了 ML 编程语言

50
00:03:45,019 --> 00:03:49,440
ML 同样是一门混合式编程语言

51
00:03:49,440 --> 00:03:53,139
既包含纯函数编程语言的思想

52
00:03:53,139 --> 00:03:56,239
又允许过程式赋值

53
00:03:56,239 --> 00:03:59,729
关于 ML 的一个有趣的细节是

54
00:03:59,729 --> 00:04:02,989
ML 最初的设计目标是一门脚本语言

55
00:04:02,989 --> 00:04:07,620
它被设计成能让人们写出证明的脚本

56
00:04:07,620 --> 00:04:12,099
当你写下数学证明时 有很多地方只是套用模板

57
00:04:12,099 --> 00:04:15,939
需要很多步骤 为了让这一过程自动化

58
00:04:15,939 --> 00:04:20,359
米尔纳和他的同事发明了 ML

59
00:04:20,359 --> 00:04:28,850
来让你能够用脚本完成无聊的步骤

60
00:04:28,850 --> 00:04:33,940
ML 有一个优点 记住当时是七十年代

61
00:04:33,940 --> 00:04:37,530
它就支持类型推断了

62
00:04:37,530 --> 00:04:43,000
因此你可以写下一个函数 编译器就会帮你推断出类型

63
00:04:43,000 --> 00:04:50,430
ML 同时也有多态类型 或者我们现在所谓的

64
00:04:50,430 --> 00:04:55,490
泛型 比如你可以有一个 T 类型的列表

65
00:04:55,490 --> 00:05:00,630
之后将 T 实例化为整数类型或字符串类型

66
00:05:00,630 --> 00:05:07,100
甚至是另一个列表类型 这些类型推断的概念

67
00:05:07,100 --> 00:05:11,240
以及泛型的概念实际上都很古老

68
00:05:11,240 --> 00:05:22,660
过了几十年后这些概念才从学术界进入主流

69
00:05:22,660 --> 00:05:25,950
在七八十年代 大卫·特纳（David Turner）

70
00:05:25,950 --> 00:05:29,590
设计了多门编程语言 开始是 SASL

71
00:05:29,590 --> 00:05:33,500
接着是 KRC 最终的顶点是

72
00:05:33,500 --> 00:05:37,730
Miranda 这些都是惰性函数式语言

73
00:05:37,730 --> 00:05:41,210
我们将在后面看到惰性函数式语言

74
00:05:41,210 --> 00:05:44,390
和严格的函数式语言的区别

75
00:05:44,390 --> 00:05:49,660
大卫·特纳极具影响力

76
00:05:49,660 --> 00:05:54,290
因为 Haskell 这门我们的课中要用的编程语言

77
00:05:54,290 --> 00:05:57,560
同样是惰性语言 它是基于

78
00:05:57,560 --> 00:06:01,730
大卫·特纳在 Miranda SASL 和 KRC

79
00:06:01,730 --> 00:06:07,220
上所做的很多工作 当我开始学计算机科学时

80
00:06:07,220 --> 00:06:10,470
在八十年代 接触到的第一门函数式语言

81
00:06:10,470 --> 00:06:17,440
就是 SASL 所以 SASL 在我心中一直有特别的地位

82
00:06:17,440 --> 00:06:27,690
我们也会在之后的课程中了解一下 SASL

83
00:06:27,690 --> 00:06:34,910
因为在某种程度上 SASL 是 Haskell 之母

84
00:06:34,910 --> 00:06:41,000
现在说说 Haskell 大约 1987 年

85
00:06:41,000 --> 00:06:47,810
一些编程语言研究者和函数式语言研究者

86
00:06:47,810 --> 00:06:52,500
开始设计 Haskell 语言 想法就是

87
00:06:52,500 --> 00:06:56,520
设计一门人们可以在上面进行试验的标准语言

88
00:06:56,520 --> 00:07:01,380
因为如果你想试验一下 比方说 一种新的类型系统

89
00:07:01,380 --> 00:07:04,810
搭建整个编程语言的框架需要做很多工作

90
00:07:04,810 --> 00:07:09,140
比如语言本身 解析器 等等 尽管你想做的只是

91
00:07:09,140 --> 00:07:12,820
研究这个新的类型系统

92
00:07:12,820 --> 00:07:15,950
Haskell 有时被称为

93
00:07:15,950 --> 00:07:19,420
编程语言研究的培养皿

94
00:07:19,420 --> 00:07:24,100
它实现了这个目标 有很多研究论文

95
00:07:24,100 --> 00:07:27,360
中 Haskell 被用作

96
00:07:27,360 --> 00:07:32,540
实验的 基质 同时 Haskell 本身

97
00:07:32,540 --> 00:07:34,900
作为一门编程语言也是十分成功的

98
00:07:34,900 --> 00:07:44,430
Haskell 同时也是我们在这门课中使用的编程语言

99
00:07:44,430 --> 00:07:48,060
2003年 有趣的是

100
00:07:48,060 --> 00:07:55,850
发表的却是 Haskell 98 报告 也就是说设计完成已经过去了很多年

101
00:07:55,850 --> 00:08:02,080
Haskell 98 的目的是定义这门编程语言的一个稳定版本

102
00:08:02,080 --> 00:08:05,120
Haskell 作为一个研究工具

103
00:08:05,120 --> 00:08:13,420
有着许多的扩展 为了使这门语言能够在主流中使用

104
00:08:13,420 --> 00:08:17,670
需要的就是它的一个稳定版本

105
00:08:17,670 --> 00:08:21,020
只包含那些一致且完成的特性

106
00:08:21,020 --> 00:08:25,650
因此人们才能依靠它们

107
00:08:25,650 --> 00:08:28,990
与此同时 Haskell 也在不断进化

108
00:08:28,990 --> 00:08:36,860
但在这门课程中 我们只使用 Haskell 98 这一子集

109
00:08:36,860 --> 00:08:45,390
如果你用的是 GHC 下一节课中将讲到 GHC 有许多扩展

110
00:08:45,390 --> 00:08:49,650
但那是之后的话题了

111
00:08:49,650 --> 00:08:52,880
我们将仅仅使用 Haskell 98

112
00:08:52,880 --> 00:09:01,600
目前 Haskell 有 Haskell platform

113
00:09:01,600 --> 00:09:07,170
供你下载 课程网站上有很多的相关信息

114
00:09:12,010 --> 00:09:15,010
让你能用其他方式运行 Haskell 程序

115
00:09:15,010 --> 00:09:19,250
以及其他语言的链接 可以用于完成练习

116
00:09:19,250 --> 00:09:24,440
但是 Haskell platform 提供了一种 Haskell 语言的实现

117
00:09:24,440 --> 00:09:33,800
外加针对 Windows Mac 和 Linux 这些主要平台的标准库

118
00:09:33,800 --> 00:09:38,480
Haskell platform 在工业界广泛使用

119
00:09:38,480 --> 00:09:41,710
用来设计真正的软件

120
00:09:41,710 --> 00:09:44,960
同时我们也将看到

121
00:09:44,960 --> 00:09:48,750
Haskell 对其他语言的影响

122
00:09:48,750 --> 00:09:55,550
让我们用一小段 Haskell 程序作为这部分的结尾

123
00:09:55,550 --> 00:09:58,740
来展示 Haskell 的简洁程度

124
00:09:58,740 --> 00:10:09,050
这个程序 实现的是 使用快速排序算法对列表进行排序

125
00:10:09,050 --> 00:10:13,709
这是代码 当我们完成几节课之后

126
00:10:13,709 --> 00:10:17,750
你就能够自己写这样的代码了

127
00:10:17,750 --> 00:10:21,850
当我们要对一个列表进行排序时 首先要看的是

128
00:10:21,850 --> 00:10:26,010
如果列表是空表 也就是这里的第一种情况

129
00:10:26,010 --> 00:10:29,720
我们对空表进行排序

130
00:10:29,720 --> 00:10:33,310
结果仍然是空表 因为空表本身已经排好序了

131
00:10:33,310 --> 00:10:37,140
接下来的一步是 如果我们有一个列表 xs

132
00:10:37,140 --> 00:10:40,140
前面的值是 x

133
00:10:40,140 --> 00:10:43,150
我们要做的是

134
00:10:43,150 --> 00:10:47,410
首先把小于 x 的元素取出来

135
00:10:47,410 --> 00:10:51,730
把它们放在名为 ys 的列表中 接下来

136
00:10:51,730 --> 00:10:58,280
我们取出所有大于 x 的值 放在名为 zs 的列表中

137
00:10:58,280 --> 00:11:01,320
接下来要做的就是递归地

138
00:11:01,320 --> 00:11:05,310
用函数 f 来对 ys 进行排序

139
00:11:05,310 --> 00:11:08,330
因此所有小于 x 的值都会被排序

140
00:11:08,330 --> 00:11:13,140
接下来我们将大于 x 的值 也就是 zs 排序

141
00:11:13,140 --> 00:11:16,290
接下来我们连接

142
00:11:16,290 --> 00:11:19,880
这两个表 并把 x 放在中间

143
00:11:19,880 --> 00:11:23,060
可以很容易看到

144
00:11:23,060 --> 00:11:26,140
这个递归调用的结果

145
00:11:26,140 --> 00:11:30,430
是我们现在有一个排好序的表了

146
00:11:30,430 --> 00:11:33,620
提醒一下 这个程序

147
00:11:33,620 --> 00:11:37,260
仅仅是想你展现快速排序算法的结构

148
00:11:37,260 --> 00:11:41,160
它展现了递归分解的排序方式

149
00:11:41,160 --> 00:11:44,930
真正的快速排序 在一门过程式的语言中

150
00:11:44,930 --> 00:11:48,370
并不如此创建新的列表

151
00:11:48,370 --> 00:11:54,260
也就是这两个表 相反 它会只用一个列表 并在原位置改变值

152
00:11:54,260 --> 00:11:58,490
因此只使用一个列表的空间

153
00:11:58,490 --> 00:12:04,940
即使如此 如果你想学习快速排序的算法结构

154
00:12:04,940 --> 00:12:08,470
这个程序是十分优雅的

155
00:12:08,470 --> 00:12:12,290
当然 我们可能以这个程序作为出发点 接下来我们想

156
00:12:12,290 --> 00:12:16,860
实现一种更有效率的方式 通过改变状态

157
00:12:16,860 --> 00:12:24,600
十分感谢 这就是第一节课的结尾了

158
00:12:24,600 --> 00:12:27,630
祝你 Hacking 课程网站上的练习题愉快！

159
00:12:27,630 --> 00:12:30,480
下周我们第二节课再见

