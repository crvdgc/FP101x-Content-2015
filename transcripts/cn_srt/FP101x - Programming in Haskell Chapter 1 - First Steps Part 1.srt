1
00:00:01,189 --> 00:00:07,149
大家好 欢迎回到 FP101x 函数式程序设计

2
00:00:07,149 --> 00:00:18,160
今天要学的是 Haskell 的简单入门

3
00:00:18,160 --> 00:00:21,390
我最喜欢的电影之一是

4
00:00:21,390 --> 00:00:25,890
龙威小子 如果你没看过这部电影

5
00:00:25,890 --> 00:00:32,200
现在把视频停下来 先去看电影

6
00:00:32,200 --> 00:00:37,030
每当我需要学习新东西时 我都重看一遍 龙威小子

7
00:00:37,030 --> 00:00:47,820
我可以告诉你 我看过 20 到 30 遍 每一次我看的时候 我都会学到一些新的东西

8
00:00:47,820 --> 00:00:50,890
如果你看了这部电影 你就知道

9
00:00:50,890 --> 00:00:55,500
这边的男孩 丹尼尔 想要学习空手道

10
00:00:55,500 --> 00:01:03,320
而这位宫城先生却让他做了许多

11
00:01:03,320 --> 00:01:08,320
丹尼尔认为没有意义的练习 他十分不耐烦

12
00:01:08,320 --> 00:01:15,650
但为了学新东西 必须进行许多练习 因为这涉及到肌肉记忆

13
00:01:15,650 --> 00:01:20,049
或者对应到编程中 手指记忆

14
00:01:20,049 --> 00:01:22,950
那些是不需要特殊考虑的事情

15
00:01:22,950 --> 00:01:27,520
需要反复训练的 一次又一次地重复

16
00:01:27,520 --> 00:01:32,430
这就是我们今天的课程中要做的事情

17
00:01:32,430 --> 00:01:36,070
所以别像丹尼尔一样不耐烦

18
00:01:36,070 --> 00:01:40,280
像一个大人一样 把该做的练习做了

19
00:01:40,280 --> 00:01:44,420
一遍 又一遍 一遍 又一遍

20
00:01:44,420 --> 00:01:47,640
直到它完全成为下意识行为

21
00:01:47,640 --> 00:01:51,450
这样你的脑力才能用来解决真正的问题

22
00:01:51,450 --> 00:01:56,549
不用再考虑基础问题了 每次学习新东西时

23
00:01:56,549 --> 00:02:01,049
你都可以重新看这部优秀的电影

24
00:02:01,049 --> 00:02:05,560
让我们看一点 Haskell 吧 这门课程中使用的

25
00:02:05,560 --> 00:02:10,319
Haskell 实现是 Glasgow Haskell Compiler

26
00:02:10,319 --> 00:02:13,530
有时也被称为荣耀的（Glorious） Haskell 编译器

27
00:02:13,530 --> 00:02:18,190
GHC 是一个领先的 Haskell 实现

28
00:02:18,190 --> 00:02:23,540
它既有编译器 又有交互式的

29
00:02:23,540 --> 00:02:26,900
REPL 循环（Read Evaluate Print Loop）供你输入代码

30
00:02:26,900 --> 00:02:37,459
GHC解释器的这种交互式的特性 让用 Haskell 进行试验十分容易

31
00:02:37,459 --> 00:02:40,769
因此对这门课也很有用

32
00:02:40,769 --> 00:02:50,519
许多练习都可以使用 GHC 来完成

33
00:02:50,519 --> 00:02:54,800
我不认为这是作弊

34
00:02:54,800 --> 00:02:59,730
作为程序员 我们的确应该用编译器来帮助我们

35
00:02:59,730 --> 00:03:04,420
计算机是用来帮助我们编程的

36
00:03:04,420 --> 00:03:08,660
如果我们非要不用 那就太蠢了

37
00:03:08,660 --> 00:03:14,079
GHC 可以从这个网站中免费获得 这个链接

38
00:03:14,079 --> 00:03:17,880
也同样会放在课程网站上 你也可以

39
00:03:17,880 --> 00:03:21,220
谷歌或者必应搜索 Haskell platform

40
00:03:21,220 --> 00:03:29,910
这一实现在主流平台比如 Mac Windows 和 Linux 上 都可以使用 要启动 GHC

41
00:03:29,910 --> 00:03:33,840
只需要从命令行输入 ghci 命令

42
00:03:33,840 --> 00:03:41,230
之后你可以看到 一些文字提示和一个提示符

43
00:03:41,230 --> 00:03:44,970
Prelude> 你可以在这里打字输入表达式了

44
00:03:44,970 --> 00:03:53,150
比如我们可以输入表达式 2 + 3 * 4

45
00:03:53,150 --> 00:03:57,690
GHCi 就会打印对应的结果 此时我们其实是

46
00:03:57,690 --> 00:04:01,380
将 GHCi 当成计算器来用

47
00:04:01,380 --> 00:04:05,250
有点像命令行界面的计算器

48
00:04:05,250 --> 00:04:10,340
而不是用按钮输入的计算器 我们在这里可以看到

49
00:04:10,340 --> 00:04:13,680
2 + 3 * 4 的值显然是 14

50
00:04:13,680 --> 00:04:17,459
因此乘法的优先级比加法更高

51
00:04:17,459 --> 00:04:20,640
大部分语言中都是这样的

52
00:04:20,640 --> 00:04:24,450
也没什么好奇怪的

53
00:04:24,450 --> 00:04:28,450
如果我们想先进行加法 再进行乘法

54
00:04:28,450 --> 00:04:31,510
就需要加上括号 因此改写成 (2 + 3) * 4

55
00:04:31,510 --> 00:04:35,910
结果是 20 我们可以

56
00:04:35,910 --> 00:04:40,880
对更复杂表达式求值 比如 (3 ^ 2 + 4 ^ 2) 的平方根

57
00:04:41,630 --> 00:04:46,690
结果是 5

58
00:04:46,690 --> 00:04:53,490
你可以看到这里的 Prelude> 提示符

59
00:04:53,490 --> 00:04:59,390
Haskell 的 Prelude 好比 Java 的 JDK 包括了许多标准函数

60
00:04:59,390 --> 00:05:03,330
内置在 Haskell 中的 在网站上

61
00:05:03,330 --> 00:05:07,930
将展示获得其他 Haskell 库的方法

62
00:05:07,930 --> 00:05:13,620
但现在先不要引入过多细节

63
00:05:13,620 --> 00:05:16,740
你可以读一下那些 但现在

64
00:05:16,740 --> 00:05:21,390
我们专注于标准的库函数 也就是标准的 Prelude

65
00:05:21,390 --> 00:05:27,680
Prelude 中的很多函数

66
00:05:27,680 --> 00:05:30,710
都是关于列表（List）的函数

67
00:05:30,710 --> 00:05:34,750
我们将举几个例子 之后的课程中

68
00:05:34,750 --> 00:05:38,810
会用几种不同的方式实现这些函数

69
00:05:38,810 --> 00:05:42,500
第一个函数是 head 接收一个列表作为输入

70
00:05:42,500 --> 00:05:46,350
在 Haskell 中 列表的表示方式是用方括号

71
00:05:46,350 --> 00:05:48,280
元素用逗号分开

72
00:05:48,280 --> 00:05:52,030
因此 [1,2,3,4,5] 的 head 就是

73
00:05:52,030 --> 00:05:56,110
不出意外地是 1 而 tail

74
00:05:56,110 --> 00:06:00,130
和 head 相对 取列表中除了第一个元素（head）以外的所有元素

75
00:06:00,130 --> 00:06:03,340
因此 [1,2,3,4,5] 的 tail 就是

76
00:06:03,340 --> 00:06:07,710
列表 [2,3,4,5]

77
00:06:07,710 --> 00:06:11,360
我们也可以选中列表的第 n 个元素

78
00:06:11,360 --> 00:06:16,250
使用双叹号操作符 如果想选中第二个元素

79
00:06:16,250 --> 00:06:20,320
从列表 [1,2,3,4,5] 中 就可以得到

80
00:06:20,320 --> 00:06:24,030
3 这告诉我们什么呢

81
00:06:24,030 --> 00:06:29,610
列表的第一个元素下标是 0

82
00:06:29,610 --> 00:06:36,849
Haskell 从 0 开始算数组的下标

83
00:06:36,849 --> 00:06:44,159
这里使用两个叹号作为标志 这么做是有道理的 因为在 Haskell 中

84
00:06:44,159 --> 00:06:47,189
列表不是数组 所以用下标访问列表

85
00:06:47,189 --> 00:06:50,909
比如取列表中下标为 2 的元素

86
00:06:50,909 --> 00:06:54,729
会遍历整个列表 因此我们遍历列表 去掉 1

87
00:06:54,729 --> 00:06:59,509
再去掉 2 最终返回 3 完成操作所需要的时间并不是常数

88
00:06:59,509 --> 00:07:04,209
用下标访问列表 和用下标访问数组不同

89
00:07:04,209 --> 00:07:07,919
在 Haskell 中所需时间和下标数呈线性关系

90
00:07:07,919 --> 00:07:13,599
更一般地 和列表的长度呈线性关系

91
00:07:13,599 --> 00:07:24,629
幸运的是 很少在实际中用到这个操作符

92
00:07:24,629 --> 00:07:28,550
如果想用下标访问数组

93
00:07:28,550 --> 00:07:34,180
就说明自己没有做足够的练习

94
00:07:34,180 --> 00:07:37,569
仍然还在使用那套过程式程序设计的思维

95
00:07:37,569 --> 00:07:40,689
也就是使用数组的思维

96
00:07:40,689 --> 00:07:48,300
在 Haskell 中 我们通常使用高阶函数 比如 map filter fold 而非下标

97
00:07:48,300 --> 00:07:53,119
在列表上进行复杂操作 看下一个例子

98
00:07:53,119 --> 00:07:59,719
take 3 取出列表的前三个元素

99
00:07:59,719 --> 00:08:01,180
如果我们传入列表 [1,2,3,4,5]

100
00:08:01,180 --> 00:08:04,680
它就返回前三个元素

101
00:08:04,680 --> 00:08:11,619
[1,2,3] 而 drop 与之相反 它接受一个数字

102
00:08:11,619 --> 00:08:16,719
和一个列表 然后去掉列表的前三个元素

103
00:08:16,719 --> 00:08:20,819
某种程度上 drop 和 take 是

104
00:08:20,819 --> 00:08:24,300
head 和 tail 的推广 head 和 tail

105
00:08:24,300 --> 00:08:33,130
只取列表的第一个元素和其余的元素 而 take 和 drop 可以推广到任意个数

106
00:08:33,130 --> 00:08:44,930
计算列表的长度 可以调用 length 函数 [1,2,3,4,5] 的长度是 5

107
00:08:44,930 --> 00:08:49,180
这里需要再提一下 Haskell 中的列表和其他语言中的数组不同

108
00:08:49,180 --> 00:08:53,910
因此计算长度不是一个常数时间的操作

109
00:08:53,910 --> 00:08:58,070
花费的时间和列表的长度呈线性关系

110
00:08:58,070 --> 00:09:04,890
sum 计算所有元素的和 如果将 [1,2,3,4,5] 传入 sum

111
00:09:04,890 --> 00:09:09,040
结果就是 15 product

112
00:09:09,040 --> 00:09:17,080
和 sum 类似 但不是加起来 而是乘起来

113
00:09:17,080 --> 00:09:21,520
1, 2, 3, 4, 5 的乘积 和 5 的阶乘一样

114
00:09:21,520 --> 00:09:27,649
是 120 另一个常用的操作是连接两个列表

115
00:09:27,649 --> 00:09:30,290
拿两个列表 把它们合成一个新的列表

116
00:09:30,290 --> 00:09:33,570
比如在 [1,2,3] 后面接上 [4,5]

117
00:09:33,570 --> 00:09:43,220
就得到了列表 [1,2,3,4,5] 这里的最后一个函数是取列表的倒序

118
00:09:43,220 --> 00:09:46,260
reverse [1,2,3,4,5] 得到

119
00:09:46,260 --> 00:09:50,380
[5,4,3,2,1] 之后的课程中

120
00:09:50,380 --> 00:09:54,990
我们将用多种方式自己定义这些函数

121
00:09:54,990 --> 00:10:01,600
现在可以试试它们能干什么

122
00:10:01,600 --> 00:10:05,040
然后就可以准备好实现它们

123
00:10:05,040 --> 00:10:08,640
因为我们就会知道它们应该做什么了

124
00:10:08,640 --> 00:10:16,260
这是一张很重要的幻灯片

125
00:10:16,260 --> 00:10:20,839
是关于函数调用的

126
00:10:20,839 --> 00:10:24,450
Haskell 和数学十分不同

127
00:10:24,450 --> 00:10:27,700
同时也和其他的编程语言不同

128
00:10:27,700 --> 00:10:32,910
在数学中 当我们应用一个函数时

129
00:10:32,910 --> 00:10:34,860
也就是你在学校中学分析时所用的数学中

130
00:10:34,860 --> 00:10:38,100
当将一个函数应用到一个参数上时

131
00:10:38,100 --> 00:10:45,100
总使用括号 在这里 我们应用一个函数

132
00:10:45,100 --> 00:10:55,910
即 f 应用到参数 a 和 b 上 然后加上 c 空格 d 在数学中

133
00:10:55,910 --> 00:10:59,460
一般遵从物理的记号

134
00:10:59,460 --> 00:11:03,720
也就是空格的意思是乘法

135
00:11:03,720 --> 00:11:07,300
如果你在一本数学教材中

136
00:11:07,300 --> 00:11:11,430
看到 c d 这样的写法

137
00:11:11,430 --> 00:11:14,800
通常意味着 c 乘以 d

138
00:11:14,800 --> 00:11:18,480
因此应用一个函数时 需要使用

139
00:11:18,480 --> 00:11:24,330
括号来消除歧义 因为在 Haskell 中

140
00:11:24,330 --> 00:11:27,530
函数调用远比乘法更常用

141
00:11:27,530 --> 00:11:30,990
而在物理中

142
00:11:30,990 --> 00:11:34,630
乘法更常用 因此将空白记号分配给乘法

143
00:11:34,630 --> 00:11:40,080
也就是看不到的记号

144
00:11:40,080 --> 00:11:43,680
最 空 的记号 而在 Haskell 中

145
00:11:43,680 --> 00:11:46,680
函数调用用空白符号来表示

146
00:11:46,680 --> 00:11:50,050
因此符号才不至于太多

147
00:11:50,050 --> 00:11:54,050
所以在 Haskell 中 不写 f (a,b) + c d

148
00:11:54,050 --> 00:12:02,660
函数调用使用空格表示 因此写成 f a b + c * d

149
00:12:06,180 --> 00:12:18,540
在多数编程语言中要写 f (a, b) 某种程度上

150
00:12:18,540 --> 00:12:23,680
这是两种最差的写法的结合 需要把一切都显式地写出来

151
00:12:23,680 --> 00:12:35,500
Haskell 决定函数调用拿空格来表示 乘法用乘号来表示

152
00:12:35,500 --> 00:12:42,480
此外 函数调用优先级更高

153
00:12:42,480 --> 00:12:45,790
比任何其他操作符都高 如果看到

154
00:12:45,790 --> 00:12:49,820
f a + b 含义就是 f 应用到 a 上

155
00:12:49,820 --> 00:12:52,970
结果再加上 b 而不是将 f

156
00:12:52,970 --> 00:12:57,250
应用到 (a + b) 的结果上

157
00:12:57,250 --> 00:13:01,080
大家需要适应一下这种写法 它的意思不是

158
00:13:01,080 --> 00:13:04,210
f 乘以 a 再加上 b 而是

159
00:13:04,210 --> 00:13:12,370
f 应用到 a 上 再加上 b 好比乘法比加法的优先级高

160
00:13:12,370 --> 00:13:20,210
这张表格给出了 一些表达式

161
00:13:20,210 --> 00:13:23,410
这边是 Haskell 的写法

162
00:13:23,410 --> 00:13:27,750
另一边是数学的写法 这些写法是你应该忘记的

163
00:13:27,750 --> 00:13:31,240
让我把它挡起来 这你是你应该忘记的东西

164
00:13:31,240 --> 00:13:34,320
这边是你应该学习的东西

165
00:13:34,320 --> 00:13:42,670
所以忘了我身后这边的写法 学习另一边的写法

166
00:13:42,670 --> 00:13:45,890
不是写 f 括号 x 而是写

167
00:13:45,890 --> 00:13:50,420
f 空格 x 不写 f 传入两个参数

168
00:13:50,420 --> 00:13:55,230
而是写 f 应用到 x 上 再把结果应用到 y 上

169
00:13:55,230 --> 00:14:00,540
不是写 f 括号 g 括号 x 而是写

170
00:14:00,540 --> 00:14:04,110
f 应用到 g 在 x 上应用的结果 后面我们可以看到

171
00:14:04,110 --> 00:14:07,120
我们可以用复合函数的方法写成

172
00:14:07,120 --> 00:14:11,680
f 复合到 g 上

173
00:14:11,680 --> 00:14:18,720
其他的例子应该很显然

174
00:14:18,720 --> 00:14:22,680
如果你只看它们的形状 别去解释它们 你就能发现

175
00:14:22,680 --> 00:14:27,650
这边的 Haskell 代码比那边的更加简洁

176
00:14:27,650 --> 00:14:33,070
Haskell 程序员都很懒 不想打太多字

177
00:14:33,070 --> 00:14:36,470
因此这样看起来漂亮很多

178
00:14:36,470 --> 00:14:39,860
这也是 Haskell 语法这样设计的原因

179
00:14:39,860 --> 00:14:43,350
十分感谢 第 1 部分到此结束了

180
00:14:43,350 --> 00:14:47,320
让我们在第 1 章剩下的部分再见吧

