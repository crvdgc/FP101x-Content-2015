[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: None

[Aegisub Project Garbage]
Audio File: ../../../courses/FP101x-chapter5-part2-video.mp4
Scroll Position: 102
Active Line: 111

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,Arial,20,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,2,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:01.44,0:00:08.91,Default,,0,0,0,,Welcome back I hope that your mental stack has not overflown because of all the recursion
Dialogue: 0,0:00:08.91,0:00:13.07,Default,,0,0,0,,In this second part we'll keep it very light
Dialogue: 0,0:00:13.07,0:00:19.54,Default,,0,0,0,,and in particular I will help you with some of the exercises
Dialogue: 0,0:00:19.54,0:00:24.41,Default,,0,0,0,,that are on the website for this chapter
Dialogue: 0,0:00:24.41,0:00:28.73,Default,,0,0,0,,In the very first lecture we showed
Dialogue: 0,0:00:28.73,0:00:34.80,Default,,0,0,0,,very quickly an implementation of quicksort in Haskell
Dialogue: 0,0:00:34.80,0:00:42.70,Default,,0,0,0,,and what we will do now is we will look in a little bit more detail at quicksort in Haskell
Dialogue: 0,0:00:43.06,0:00:50.56,Default,,0,0,0,,The idea of quicksort is to sort a list recursively
Dialogue: 0,0:00:50.56,0:00:53.90,Default,,0,0,0,,by decomposing the list somehow
Dialogue: 0,0:00:53.90,0:00:57.12,Default,,0,0,0,,recursively sorting those lists
Dialogue: 0,0:00:57.12,0:00:59.99,Default,,0,0,0,,and then combining the results together
Dialogue: 0,0:01:00.93,0:01:04.34,Default,,0,0,0,,If we think about that for a little bit, we can say:
Dialogue: 0,0:01:04.90,0:01:09.00,Default,,0,0,0,,if I have the empty list it's already sorted
Dialogue: 0,0:01:10.02,0:01:13.27,Default,,0,0,0,,Now how do we recurse
Dialogue: 0,0:01:13.27,0:01:20.05,Default,,0,0,0,,how do we break up that list into two parts that we can recursively sort
Dialogue: 0,0:01:20.05,0:01:24.35,Default,,0,0,0,,and then easily combine the results to get a sorted list?
Dialogue: 0,0:01:24.35,0:01:28.93,Default,,0,0,0,,Well what we do is if we can take a look at the head of the list
Dialogue: 0,0:01:28.93,0:01:35.78,Default,,0,0,0,,and break this list in two, one with all the values that are less or equal than the head
Dialogue: 0,0:01:35.78,0:01:39.04,Default,,0,0,0,,One with all the values that are greater than the head
Dialogue: 0,0:01:39.04,0:01:43.52,Default,,0,0,0,,Then we can just recursively sort those two lists
Dialogue: 0,0:01:43.52,0:01:47.50,Default,,0,0,0,,and inject the head in the middle and we're done
Dialogue: 0,0:01:47.50,0:01:53.08,Default,,0,0,0,,That's the algorithmic essence of quicksort
Dialogue: 0,0:01:53.08,0:01:55.35,Default,,0,0,0,,but as I already warned you
Dialogue: 0,0:01:55.35,0:01:58.76,Default,,0,0,0,,in the real implementation you're not creating new lists
Dialogue: 0,0:01:58.76,0:02:04.70,Default,,0,0,0,,you're really mutating the data structure in place to swap the elements
Dialogue: 0,0:02:04.70,0:02:09.77,Default,,0,0,0,,and that's an aspect that this version of quicksort doesn't show
Dialogue: 0,0:02:09.77,0:02:13.46,Default,,0,0,0,,but it does show this recursive structure
Dialogue: 0,0:02:14.09,0:02:18.47,Default,,0,0,0,,Alright, here's the implementation of quicksort
Dialogue: 0,0:02:18.47,0:02:22.36,Default,,0,0,0,,similar to the very first lecture
Dialogue: 0,0:02:22.36,0:02:26.45,Default,,0,0,0,,and only now it's called quicksort instead of f
Dialogue: 0,0:02:26.45,0:02:32.39,Default,,0,0,0,,What we do when we have the empty list: it's already sorted
Dialogue: 0,0:02:32.39,0:02:37.91,Default,,0,0,0,,When we want to sort a list x cons xs
Dialogue: 0,0:02:37.91,0:02:45.43,Default,,0,0,0,,we create a list with all the elements that are smaller or equal than x
Dialogue: 0,0:02:47.28,0:02:50.21,Default,,0,0,0,,and for that we use a list comprehension
Dialogue: 0,0:02:50.21,0:02:54.39,Default,,0,0,0,,We create a list of all the elements that are larger than x
Dialogue: 0,0:02:54.39,0:03:00.32,Default,,0,0,0,,We sort both of those and we put x in the middle
Dialogue: 0,0:03:02.30,0:03:06.92,Default,,0,0,0,,This is a very simple implementation of quicksort
Dialogue: 0,0:03:06.92,0:03:12.49,Default,,0,0,0,,but again it's also a very simplistic implementation of quicksort
Dialogue: 0,0:03:12.49,0:03:14.88,Default,,0,0,0,,But if you want to understand the structure
Dialogue: 0,0:03:14.88,0:03:18.37,Default,,0,0,0,,this is probably a very good illustration
Dialogue: 0,0:03:19.07,0:03:23.54,Default,,0,0,0,,If we want to illustrate how this works
Dialogue: 0,0:03:23.54,0:03:26.65,Default,,0,0,0,,let's abbreviate quicksort as q
Dialogue: 0,0:03:26.65,0:03:29.98,Default,,0,0,0,,such that the slide doesn't overflow
Dialogue: 0,0:03:31.17,0:03:34.01,Default,,0,0,0,,We want to sort the list [3, 2, 4, 1, 5]
Dialogue: 0,0:03:34.01,0:03:37.18,Default,,0,0,0,,What we're going to do is we're taking the head three
Dialogue: 0,0:03:37.18,0:03:42.64,Default,,0,0,0,,and we're going to break up the rest of the list into the elements that are less than equal to 3
Dialogue: 0,0:03:42.64,0:03:45.63,Default,,0,0,0,,and the ones that are larger than three
Dialogue: 0,0:03:45.98,0:03:51.56,Default,,0,0,0,,The elements that are less in this list are two and one
Dialogue: 0,0:03:51.56,0:03:54.35,Default,,0,0,0,,And the ones that are larger are four and five
Dialogue: 0,0:03:54.35,0:03:58.52,Default,,0,0,0,,That's what you see, we recursively sort those
Dialogue: 0,0:03:58.52,0:04:02.84,Default,,0,0,0,,and we inject three in the middle
Dialogue: 0,0:04:03.16,0:04:06.98,Default,,0,0,0,,If we sort the list [2, 1]
Dialogue: 0,0:04:06.98,0:04:11.41,Default,,0,0,0,,we take the head, we split the remaining list, which is just one
Dialogue: 0,0:04:11.41,0:04:14.69,Default,,0,0,0,,into the values that are smaller and the values that are larger
Dialogue: 0,0:04:14.69,0:04:17.15,Default,,0,0,0,,The ones that are larger that's the empty list
Dialogue: 0,0:04:17.15,0:04:19.84,Default,,0,0,0,,The ones that are smaller that's one
Dialogue: 0,0:04:19.84,0:04:24.74,Default,,0,0,0,,and then we drop two in the middle
Dialogue: 0,0:04:25.16,0:04:27.53,Default,,0,0,0,,Same on the right hand side
Dialogue: 0,0:04:27.53,0:04:30.38,Default,,0,0,0,,we take the first element
Dialogue: 0,0:04:30.38,0:04:33.54,Default,,0,0,0,,and we split the remainder of the list which is just 5
Dialogue: 0,0:04:33.54,0:04:37.55,Default,,0,0,0,,in the elements that are larger than four so that's the list 5
Dialogue: 0,0:04:37.55,0:04:41.17,Default,,0,0,0,,and the elements that are smaller which is the empty list
Dialogue: 0,0:04:41.17,0:04:44.84,Default,,0,0,0,,and we inject four there in the middle
Dialogue: 0,0:04:45.54,0:04:51.03,Default,,0,0,0,,The empty lists here and here
Dialogue: 0,0:04:51.03,0:04:54.63,Default,,0,0,0,,are already sorted so nothing to do there
Dialogue: 0,0:04:54.63,0:04:58.80,Default,,0,0,0,,We just have to short the list of one element
Dialogue: 0,0:04:58.80,0:05:05.02,Default,,0,0,0,,and you can verify that when you sort the list of one element it returns that list itself
Dialogue: 0,0:05:06.71,0:05:14.26,Default,,0,0,0,,If we make those recursive calls there we get this list
Dialogue: 0,0:05:14.26,0:05:22.53,Default,,0,0,0,,and now you see that the result is one two three four five
Dialogue: 0,0:05:22.87,0:05:27.31,Default,,0,0,0,,You just walk that tree to get the results
Dialogue: 0,0:05:29.27,0:05:32.54,Default,,0,0,0,,That was quicksort
Dialogue: 0,0:05:33.45,0:05:40.46,Default,,0,0,0,,The exercises for this week there's a lot of exercises to define functions recursively
Dialogue: 0,0:05:40.46,0:05:47.61,Default,,0,0,0,,but I'm going to do just a couple of them here with you
Dialogue: 0,0:05:47.61,0:05:49.68,Default,,0,0,0,,Let's look at the first one here
Dialogue: 0,0:05:49.68,0:05:55.51,Default,,0,0,0,,It says produce a list with n identical elements so
Dialogue: 0,0:05:55.98,0:06:00.02,Default,,0,0,0,,that's a function that takes an integer which is the n
Dialogue: 0,0:06:00.44,0:06:03.84,Default,,0,0,0,,and then it takes a value a
Dialogue: 0,0:06:03.84,0:06:12.33,Default,,0,0,0,,and it should return a list of n copies of that value a
Dialogue: 0,0:06:12.82,0:06:14.71,Default,,0,0,0,,How do we do that?
Dialogue: 0,0:06:14.71,0:06:21.11,Default,,0,0,0,,Well we do that by not recursing, well we don't recurse over this a
Dialogue: 0,0:06:21.11,0:06:23.26,Default,,0,0,0,,and we have to build the list,
Dialogue: 0,0:06:23.26,0:06:30.45,Default,,0,0,0,,so what we have to do is we have to define this recursively over the structure of this integer
Dialogue: 0,0:06:30.45,0:06:32.85,Default,,0,0,0,,so again we have two cases
Dialogue: 0,0:06:32.85,0:06:38.16,Default,,0,0,0,,n equals 0, if I replicate an element 0 time,
Dialogue: 0,0:06:38.53,0:06:42.49,Default,,0,0,0,,I get the empty list so that case is easy
Dialogue: 0,0:06:42.85,0:06:47.81,Default,,0,0,0,,If I want to replicate a value n times, what do I do?
Dialogue: 0,0:06:47.81,0:06:52.40,Default,,0,0,0,,I first replicate it n minus one times
Dialogue: 0,0:06:52.40,0:06:56.14,Default,,0,0,0,,so I get the list of n minus one times as
Dialogue: 0,0:06:56.14,0:06:58.51,Default,,0,0,0,,and then I cons a on top
Dialogue: 0,0:06:59.24,0:07:01.27,Default,,0,0,0,,That one is easy
Dialogue: 0,0:07:01.27,0:07:04.55,Default,,0,0,0,,but again you have to look a little bit
Dialogue: 0,0:07:04.55,0:07:09.11,Default,,0,0,0,,and then you see: I'm doing recursion over that guy
Dialogue: 0,0:07:09.11,0:07:15.12,Default,,0,0,0,,there's two cases just write them down and everything drops out
Dialogue: 0,0:07:16.21,0:07:21.91,Default,,0,0,0,,Here is another friend of us that we've seen in previous lectures
Dialogue: 0,0:07:21.91,0:07:28.53,Default,,0,0,0,,and there I warned you that in Haskell lists don't have constant access
Dialogue: 0,0:07:28.53,0:07:32.70,Default,,0,0,0,,When we implement this function that will be very clear
Dialogue: 0,0:07:32.70,0:07:42.98,Default,,0,0,0,,What we have to do is we have to take a list and a number and then return the element in that list at that position
Dialogue: 0,0:07:44.40,0:07:53.73,Default,,0,0,0,,Of course we can do this using a take or drop or other functions but the goal here is to define it using recursion
Dialogue: 0,0:07:54.48,0:07:58.08,Default,,0,0,0,,Since we have here two recursive structures
Dialogue: 0,0:07:58.08,0:08:00.58,Default,,0,0,0,,the list and the integer
Dialogue: 0,0:08:01.08,0:08:06.71,Default,,0,0,0,,we're going to define this by recursing over both
Dialogue: 0,0:08:07.51,0:08:10.53,Default,,0,0,0,,How would that look
Dialogue: 0,0:08:10.53,0:08:16.43,Default,,0,0,0,,well first thing is if we want to have the zero'th element of the list
Dialogue: 0,0:08:16.43,0:08:18.68,Default,,0,0,0,,well that is the head of the list
Dialogue: 0,0:08:18.68,0:08:24.02,Default,,0,0,0,,If I have a list x cons xs and this one is zero
Dialogue: 0,0:08:24.02,0:08:31.18,Default,,0,0,0,,then that's the element For the first element of the list is the element at index 0
Dialogue: 0,0:08:31.18,0:08:33.76,Default,,0,0,0,,That's a simple one
Dialogue: 0,0:08:34.42,0:08:40.26,Default,,0,0,0,,If the list here is empty
Dialogue: 0,0:08:40.26,0:08:43.19,Default,,0,0,0,,well what do we do That's a good question
Dialogue: 0,0:08:43.50,0:08:48.50,Default,,0,0,0,,probably if I want to index the nth element of the empty list
Dialogue: 0,0:08:49.72,0:08:51.06,Default,,0,0,0,,that's going to give an error
Dialogue: 0,0:08:51.06,0:08:54.92,Default,,0,0,0,,Let's not worry about that, we're going to put that as the last clause
Dialogue: 0,0:08:55.28,0:09:02.08,Default,,0,0,0,,Now we can assume that this one is not zero and this one is not empty
Dialogue: 0,0:09:02.08,0:09:04.71,Default,,0,0,0,,If that one was zero we're done
Dialogue: 0,0:09:04.71,0:09:09.33,Default,,0,0,0,,if that one was empty and this one is not zero then we have an error
Dialogue: 0,0:09:09.33,0:09:12.20,Default,,0,0,0,,Now they're both non-zero so what we do
Dialogue: 0,0:09:12.20,0:09:18.04,Default,,0,0,0,,is we say: okay if this is x cons xs and this is n
Dialogue: 0,0:09:18.56,0:09:26.51,Default,,0,0,0,,what we do is we take the index of the tail of the list and the n-1 index
Dialogue: 0,0:09:27.87,0:09:33.97,Default,,0,0,0,,Simple recursion too, it's just that we have to be a little careful about the base cases
Dialogue: 0,0:09:35.76,0:09:39.91,Default,,0,0,0,,The last function we're going to define using recursion here
Dialogue: 0,0:09:39.91,0:09:46.79,Default,,0,0,0,,decides if a given value is a member of a list
Dialogue: 0,0:09:46.79,0:09:52.05,Default,,0,0,0,,Of course we could cheat here and not use recursion
Dialogue: 0,0:09:52.05,0:09:57.01,Default,,0,0,0,,We can easily use filter or list comprehension or something
Dialogue: 0,0:09:57.01,0:10:02.20,Default,,0,0,0,,but the goal here is to define this function using recursion
Dialogue: 0,0:10:02.59,0:10:09.26,Default,,0,0,0,,In this case there's an obvious candidate to do the recursion over, that's this list
Dialogue: 0,0:10:09.26,0:10:14.67,Default,,0,0,0,,If we're looking for an element a in the empty list, that's false
Dialogue: 0,0:10:14.67,0:10:16.78,Default,,0,0,0,,That element is not in the list
Dialogue: 0,0:10:18.26,0:10:24.01,Default,,0,0,0,,If we're looking for an element a in the list x cons xs
Dialogue: 0,0:10:24.01,0:10:30.52,Default,,0,0,0,,well we have to check whether the head of the list is equal to the value that we're looking for
Dialogue: 0,0:10:30.52,0:10:33.46,Default,,0,0,0,,If that's the case we return true
Dialogue: 0,0:10:33.92,0:10:39.78,Default,,0,0,0,,If that's not the case then we just search for that element in the tail of the list
Dialogue: 0,0:10:39.78,0:10:43.31,Default,,0,0,0,,Eventually the tail of the list will be empty
Dialogue: 0,0:10:43.31,0:10:45.90,Default,,0,0,0,,so we will hit the base case and we're done
Dialogue: 0,0:10:46.24,0:10:55.24,Default,,0,0,0,,Now you see here that since we're checking equality of this element each head of the list until we find it
Dialogue: 0,0:10:55.83,0:11:00.86,Default,,0,0,0,,the type a must support equality and that's what you see here in the type
Dialogue: 0,0:11:00.86,0:11:05.13,Default,,0,0,0,,So we can only search for a value in a list
Dialogue: 0,0:11:05.63,0:11:08.89,Default,,0,0,0,,if the types of the list support equality
Dialogue: 0,0:11:08.89,0:11:16.35,Default,,0,0,0,,and that's why we get this constraint here so a must be a member of the type class Eq of a
Dialogue: 0,0:11:17.37,0:11:23.33,Default,,0,0,0,,Great, I hope that this helped, these small exercises
Dialogue: 0,0:11:23.33,0:11:26.74,Default,,0,0,0,,and as I said: on the website
Dialogue: 0,0:11:26.74,0:11:31.60,Default,,0,0,0,,there's a lot of exercises where you will do recursion
Dialogue: 0,0:11:31.60,0:11:38.70,Default,,0,0,0,,and if you get stuck try eating a banana and maybe it helps
Dialogue: 0,0:11:38.70,0:11:42.26,Default,,0,0,0,,Or maybe you can two eat bananas
Dialogue: 0,0:11:42.26,0:11:45.85,Default,,0,0,0,,and that will work even better See you next week
