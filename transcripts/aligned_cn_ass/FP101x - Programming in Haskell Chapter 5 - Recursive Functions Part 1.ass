[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 1920
PlayResY: 1080

[Aegisub Project Garbage]
Audio File: ../../../courses/FP101x-chapter5-part1-video.mp4
Video Zoom Percent: 0.500000
Scroll Position: 50
Active Line: 145

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,Arial,20,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,2,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:00.95,0:00:06.67,Default,,0,0,0,,欢迎来到新的一期FP101x
Dialogue: 0,0:00:06.67,0:00:11.16,Default,,0,0,0,,今天讲的是递归函数（recursive function）
Dialogue: 0,0:00:11.16,0:00:13.07,Default,,0,0,0,,什么是递归
Dialogue: 0,0:00:13.07,0:00:20.13,Default,,0,0,0,,这有一堆托盘 还有我最喜欢的水果 现在你们知道我喜欢香蕉了
Dialogue: 0,0:00:20.13,0:00:29.07,Default,,0,0,0,,我要吃这些香蕉 如果用递归的方式来的话
Dialogue: 0,0:00:29.07,0:00:32.90,Default,,0,0,0,,首先要吃第一根香蕉 哦
Dialogue: 0,0:00:32.90,0:00:36.50,Default,,0,0,0,,在那之前 我必须先吃下一根香蕉
Dialogue: 0,0:00:36.50,0:00:39.95,Default,,0,0,0,,哦 我先把这根香蕉
Dialogue: 0,0:00:39.95,0:00:44.96,Default,,0,0,0,,放在这个托盘上 接下来我要吃
Dialogue: 0,0:00:44.96,0:00:47.99,Default,,0,0,0,,下一根香蕉 哎呀要吃这么多香蕉
Dialogue: 0,0:00:47.99,0:00:52.52,Default,,0,0,0,,这一堆栈（stack）越来越大 再下一根香蕉
Dialogue: 0,0:00:52.52,0:00:56.71,Default,,0,0,0,,到了最后一根香蕉了
Dialogue: 0,0:00:56.71,0:01:06.01,Default,,0,0,0,,把它放到堆里 看这一堆香蕉多漂亮
Dialogue: 0,0:01:06.01,0:01:07.97,Default,,0,0,0,,注意这种做法的问题在于
Dialogue: 0,0:01:09.57,0:01:14.33,Default,,0,0,0,,我们建立了一个大的香蕉堆栈
Dialogue: 0,0:01:14.33,0:01:19.72,Default,,0,0,0,,如果香蕉太多的话 就会栈溢出（overflow）
Dialogue: 0,0:01:19.72,0:01:30.09,Default,,0,0,0,,一种更好的方法是不要等下一根吃完了才开始吃第一根
Dialogue: 0,0:01:30.52,0:01:38.50,Default,,0,0,0,,这样只需要一个托盘就可以吃完所有的香蕉了
Dialogue: 0,0:01:38.50,0:01:42.82,Default,,0,0,0,,这叫做尾调用消除（tail call elimination）
Dialogue: 0,0:01:43.94,0:01:52.51,Default,,0,0,0,,尾调用消除是使用递归时的一个重要的定义控制结构的概念
Dialogue: 0,0:01:52.51,0:01:58.57,Default,,0,0,0,,过程式语言中通常没有尾调用消除
Dialogue: 0,0:01:58.57,0:02:01.88,Default,,0,0,0,,因此需要特殊的控制结构
Dialogue: 0,0:02:01.88,0:02:12.84,Default,,0,0,0,,但在 Haskell 中 我们可以安全地使用递归来定义控制结构
Dialogue: 0,0:02:12.84,0:02:19.02,Default,,0,0,0,,因为不会产生这么大一堆没吃的香蕉
Dialogue: 0,0:02:19.96,0:02:21.62,Default,,0,0,0,,很好 让我们看点代码吧
Dialogue: 0,0:02:21.62,0:02:26.55,Default,,0,0,0,,我觉得这些香蕉够吃一年了
Dialogue: 0,0:02:26.55,0:02:38.56,Default,,0,0,0,,Haskell 程序员喜欢递归 是因为它是一种很自然的定义函数的方式
Dialogue: 0,0:02:38.56,0:02:48.29,Default,,0,0,0,,例如要定义阶乘（factorial）函数 之前也见过
Dialogue: 0,0:02:48.29,0:02:51.85,Default,,0,0,0,,取 1 到 n 之间值的列表
Dialogue: 0,0:02:51.85,0:02:55.71,Default,,0,0,0,,再把它们乘到一起
Dialogue: 0,0:02:57.55,0:03:03.16,Default,,0,0,0,,比如求值 4 的阶乘 把定义展开
Dialogue: 0,0:03:03.16,0:03:10.67,Default,,0,0,0,,也就是 1 到 4 的乘积 这是 1 到 4 的列表 也就是 [1,2,3,4] 的乘积
Dialogue: 0,0:03:10.67,0:03:16.83,Default,,0,0,0,,最终的积就是把这些数都乘起来
Dialogue: 0,0:03:16.83,0:03:26.60,Default,,0,0,0,,[1, 2, 3, 4] 的乘积 就是 1*2*3*4 也就是 24
Dialogue: 0,0:03:27.68,0:03:32.63,Default,,0,0,0,,下面是用递归的方式定义阶乘
Dialogue: 0,0:03:32.63,0:03:37.49,Default,,0,0,0,,我们已经看过如何定义列表的递归函数
Dialogue: 0,0:03:37.49,0:03:41.48,Default,,0,0,0,,取列表 检查是否为空表
Dialogue: 0,0:03:41.48,0:03:45.42,Default,,0,0,0,,还是一个头元素（head）接一个尾列表（tail）
Dialogue: 0,0:03:45.42,0:03:52.16,Default,,0,0,0,,某种程度上 数字上的递归函数也是一样
Dialogue: 0,0:03:52.16,0:03:57.13,Default,,0,0,0,,要考虑两种情况 一是当数字为 0 时
Dialogue: 0,0:03:57.13,0:04:00.03,Default,,0,0,0,,另一种情况是数字为 n
Dialogue: 0,0:04:00.03,0:04:04.86,Default,,0,0,0,,在第二种情况下 就在 n-1 上进行递归
Dialogue: 0,0:04:07.49,0:04:12.00,Default,,0,0,0,,之前版本的 Haskell 中有一种叫做 n+k 的模式
Dialogue: 0,0:04:12.00,0:04:16.69,Default,,0,0,0,,你可以定义为 0 时的阶乘 还有 n+1 时的阶乘
Dialogue: 0,0:04:16.69,0:04:20.78,Default,,0,0,0,,但 n+k 模式已经弃置不用了
Dialogue: 0,0:04:20.78,0:04:24.62,Default,,0,0,0,,现在只能用这种形式写了
Dialogue: 0,0:04:24.62,0:04:37.20,Default,,0,0,0,,但除了这个小细节之外 可以看出和在列表上的递归很像
Dialogue: 0,0:04:38.01,0:04:42.99,Default,,0,0,0,,两种情况 0 和 n 等于 0 的时候结果是 1
Dialogue: 0,0:04:42.99,0:04:48.32,Default,,0,0,0,,否则先取 n-1 的阶乘 再乘上 n
Dialogue: 0,0:04:50.40,0:04:59.09,Default,,0,0,0,,如果对这种形式的阶乘求值 就会发现堆栈 变得像香蕉一样
Dialogue: 0,0:04:59.09,0:05:08.34,Default,,0,0,0,, 这是因为阶乘会首先不断进入右边的调用 等一切都执行完
Dialogue: 0,0:05:08.34,0:05:12.27,Default,,0,0,0,,再乘回来
Dialogue: 0,0:05:12.27,0:05:15.80,Default,,0,0,0,,从栈中弹出 得到结果 6
Dialogue: 0,0:05:18.12,0:05:19.11,Default,,0,0,0,,好了
Dialogue: 0,0:05:19.69,0:05:24.41,Default,,0,0,0,,我们给出的阶乘递归定义
Dialogue: 0,0:05:24.41,0:05:34.24,Default,,0,0,0,,可能会停不下来 用术语来说就是 对小于 0 的数字发散（diverge）
Dialogue: 0,0:05:34.24,0:05:41.22,Default,,0,0,0,,让我们回去看看
Dialogue: 0,0:05:41.22,0:05:44.02,Default,,0,0,0,,如果 n 小于 0
Dialogue: 0,0:05:44.50,0:05:52.09,Default,,0,0,0,,那么不符合这种情况 因此将 n 与 n-1 的阶乘相乘
Dialogue: 0,0:05:52.09,0:05:57.09,Default,,0,0,0,,参数比 0 更小了 依此类推 永远不会停下
Dialogue: 0,0:05:57.09,0:06:00.10,Default,,0,0,0,,最终会造成栈溢出
Dialogue: 0,0:06:04.59,0:06:15.12,Default,,0,0,0,,像阶乘这样的有些函数 可以递归定义 或用其他函数定义
Dialogue: 0,0:06:15.12,0:06:19.37,Default,,0,0,0,,无论是用递归方式定义
Dialogue: 0,0:06:19.37,0:06:22.00,Default,,0,0,0,,还是使用其他函数定义
Dialogue: 0,0:06:22.00,0:06:28.45,Default,,0,0,0,,又或者把递归的模式抽象成高阶函数（higher-order function）
Dialogue: 0,0:06:28.45,0:06:32.98,Default,,0,0,0,,再用它来定义 其实只是品味问题
Dialogue: 0,0:06:32.98,0:06:41.88,Default,,0,0,0,,最终 作为一个开发者要决定的是 怎样最方便其他开发者阅读 对吧
Dialogue: 0,0:06:41.88,0:06:48.35,Default,,0,0,0,,因此是否要用递归这个问题 没有一个明确的答案
Dialogue: 0,0:06:48.35,0:06:51.07,Default,,0,0,0,,代码越简洁越好
Dialogue: 0,0:06:51.07,0:06:54.16,Default,,0,0,0,,但使用递归的一个好处是
Dialogue: 0,0:06:54.16,0:07:00.80,Default,,0,0,0,,可以递推（induction）证明程序的性质
Dialogue: 0,0:07:02.26,0:07:07.09,Default,,0,0,0,,让我们再看一个递归定义函数的例子
Dialogue: 0,0:07:07.09,0:07:16.36,Default,,0,0,0,,之前定义阶乘时用到的乘积（product）函数
Dialogue: 0,0:07:16.36,0:07:23.37,Default,,0,0,0,,让我们用列表上的递归来定义 这样结构完全相同
Dialogue: 0,0:07:23.37,0:07:26.72,Default,,0,0,0,,有两种情况要考虑 要么是空列表
Dialogue: 0,0:07:26.72,0:07:30.47,Default,,0,0,0,,要么是 n 连接着（cons） ns
Dialogue: 0,0:07:30.47,0:07:34.36,Default,,0,0,0,,对照着列表的递归结构
Dialogue: 0,0:07:34.36,0:07:39.18,Default,,0,0,0,,再将函数定义在递归的结构上
Dialogue: 0,0:07:39.18,0:07:43.34,Default,,0,0,0,,这和数字是一样的 首先对照数字的递归结构
Dialogue: 0,0:07:43.34,0:07:47.30,Default,,0,0,0,,再根据那种结构定义函数
Dialogue: 0,0:07:47.30,0:07:50.69,Default,,0,0,0,,回到这里 如果要计算空表的乘积
Dialogue: 0,0:07:50.69,0:07:53.52,Default,,0,0,0,,结果就是 1
Dialogue: 0,0:07:53.52,0:07:59.84,Default,,0,0,0,,如果要对元素 n 和列表 ns 计算乘积
Dialogue: 0,0:07:59.84,0:08:06.67,Default,,0,0,0,,该怎么做 首先取余下列表的乘积 再乘上 n
Dialogue: 0,0:08:06.67,0:08:13.64,Default,,0,0,0,,因此这是个很简单的用递归定义函数的方式
Dialogue: 0,0:08:13.99,0:08:19.88,Default,,0,0,0,,当然 我们也可以取这个函数
Dialogue: 0,0:08:19.88,0:08:24.91,Default,,0,0,0,,将其模式抽象成一个高阶函数 只处理递归
Dialogue: 0,0:08:24.91,0:08:29.18,Default,,0,0,0,,然后可以放入乘法和 1 就行
Dialogue: 0,0:08:30.24,0:08:39.08,Default,,0,0,0,,如果执行乘积函数 展开列表定义 2 连接 3 和 4
Dialogue: 0,0:08:39.08,0:08:41.28,Default,,0,0,0,,再展开乘积的定义
Dialogue: 0,0:08:41.28,0:08:45.69,Default,,0,0,0,,得到 2 乘上 [3, 4] 的乘积 如此反复几次
Dialogue: 0,0:08:45.69,0:08:48.22,Default,,0,0,0,,直到这一步
Dialogue: 0,0:08:48.22,0:08:52.16,Default,,0,0,0,,最后从栈中弹出 得到结果 24
Dialogue: 0,0:08:52.48,0:09:00.85,Default,,0,0,0,,可以看到答案和阶乘的递归定义完全相同
Dialogue: 0,0:09:00.85,0:09:07.84,Default,,0,0,0,,唯一的区别就是 这里的递归隐藏在乘积函数里
Dialogue: 0,0:09:07.84,0:09:14.78,Default,,0,0,0,,如果计算 1 到 n 的乘积 事实上是在用递归定义函数
Dialogue: 0,0:09:14.78,0:09:16.17,Default,,0,0,0,,并且可以说明
Dialogue: 0,0:09:16.17,0:09:27.70,Default,,0,0,0,,把两个函数合并到一起时 一个创建从 1 到 n 的列表 另一个是乘积函数 得到的和阶乘的递归定义一样
Dialogue: 0,0:09:29.69,0:09:37.26,Default,,0,0,0,,再看一个可以递归定义在列表上的函数
Dialogue: 0,0:09:37.26,0:09:42.05,Default,,0,0,0,,可以再次看到递归结构
Dialogue: 0,0:09:42.05,0:09:48.10,Default,,0,0,0,,如果列表是空的 空列表的长度是 0
Dialogue: 0,0:09:49.36,0:09:50.76,Default,,0,0,0,,如果表不是空的
Dialogue: 0,0:09:50.76,0:09:57.37,Default,,0,0,0,,我们不关心第一个元素具体是什么 直接计算其余列表的长度
Dialogue: 0,0:09:57.37,0:10:01.74,Default,,0,0,0,,再加上 1 就好了 十分明显
Dialogue: 0,0:10:01.74,0:10:06.10,Default,,0,0,0,,同样可以看到 它遵循了列表递归的结构
Dialogue: 0,0:10:06.10,0:10:11.06,Default,,0,0,0,,因此基本上是按列表结构递推定义的
Dialogue: 0,0:10:12.48,0:10:14.07,Default,,0,0,0,,计算 [1, 2, 3] 的长度
Dialogue: 0,0:10:14.07,0:10:18.87,Default,,0,0,0,,也就是 1 + [2, 3] 的长度 展开 展开 再展开
Dialogue: 0,0:10:18.87,0:10:21.60,Default,,0,0,0,,直到这里 再把它们加到一起
Dialogue: 0,0:10:21.60,0:10:24.75,Default,,0,0,0,,就得到了预期的结果 3
Dialogue: 0,0:10:25.97,0:10:29.24,Default,,0,0,0,,再看另一个函数反转列表（reverse）
Dialogue: 0,0:10:29.80,0:10:33.87,Default,,0,0,0,,对空列表来说 反转得到的还是空列表
Dialogue: 0,0:10:33.87,0:10:38.92,Default,,0,0,0,,如果想要反转 (x:xs)
Dialogue: 0,0:10:38.92,0:10:42.62,Default,,0,0,0,,只需要把 x 放到另外一边就行
Dialogue: 0,0:10:42.62,0:10:45.89,Default,,0,0,0,,如果像这样执行
Dialogue: 0,0:10:45.89,0:10:53.38,Default,,0,0,0,,可以看到元素变成了从右向左连接的
Dialogue: 0,0:10:53.38,0:10:56.45,Default,,0,0,0,,因此列表反转了
Dialogue: 0,0:10:56.45,0:10:59.93,Default,,0,0,0,,[1, 2, 3] 变成了 [3, 2, 1]
Dialogue: 0,0:11:02.25,0:11:09.99,Default,,0,0,0,,当然也可以定义不只在一个参数上递归 而是在多个参数上递归的函数
Dialogue: 0,0:11:09.99,0:11:13.43,Default,,0,0,0,,上一章介绍过 zip （拉链）函数
Dialogue: 0,0:11:13.43,0:11:17.24,Default,,0,0,0,,如何定义 zip 呢 zip 接收两个列表
Dialogue: 0,0:11:17.24,0:11:21.77,Default,,0,0,0,,它取两个列表中的元素 将它们结合成一对
Dialogue: 0,0:11:22.38,0:11:31.01,Default,,0,0,0,,最简单的情况是最后一种 如果有两个非空列表
Dialogue: 0,0:11:31.01,0:11:34.76,Default,,0,0,0,,取两个的头元素（head） 结合成一对
Dialogue: 0,0:11:34.76,0:11:38.20,Default,,0,0,0,,再递归地 zip 剩下的列表 什么时候停下呢
Dialogue: 0,0:11:38.20,0:11:43.07,Default,,0,0,0,,两个列表中只要有一个空了 就停下了
Dialogue: 0,0:11:43.07,0:11:46.38,Default,,0,0,0,,此时返回空表
Dialogue: 0,0:11:47.44,0:11:54.34,Default,,0,0,0,,当然我们需要把这两种情况放在前面 因为有个通配符（wild card）模式
Dialogue: 0,0:11:54.34,0:11:57.66,Default,,0,0,0,,否则就不对了
Dialogue: 0,0:11:59.82,0:12:00.67,Default,,0,0,0,,很好
Dialogue: 0,0:12:01.81,0:12:04.46,Default,,0,0,0,,再看几个函数
Dialogue: 0,0:12:04.46,0:12:08.24,Default,,0,0,0,,drop（丢弃）接收一个整数和一个列表
Dialogue: 0,0:12:08.24,0:12:19.17,Default,,0,0,0,,最终返回一个列表 它既在数字上递归 又在列表上递归
Dialogue: 0,0:12:19.17,0:12:24.46,Default,,0,0,0,,如果想从列表中丢弃 0 个元素
Dialogue: 0,0:12:24.46,0:12:27.04,Default,,0,0,0,,结果和原列表一样
Dialogue: 0,0:12:27.96,0:12:29.32,Default,,0,0,0,,当列表为空时
Dialogue: 0,0:12:29.32,0:12:35.17,Default,,0,0,0,,那丢弃多少元素都可以 只不过没什么作用 因此直接返回空列表
Dialogue: 0,0:12:35.17,0:12:40.20,Default,,0,0,0,,最后同时在列表和数字上递归
Dialogue: 0,0:12:40.20,0:12:45.99,Default,,0,0,0,,同样 因为没有 n+k 模式 右手边要用 n-1
Dialogue: 0,0:12:45.99,0:12:53.47,Default,,0,0,0,,因此从无论什么元素连接 xs  的列表中丢弃 n 个元素 得到的就是从 xs 中丢弃 n-1 个元素
Dialogue: 0,0:12:53.47,0:12:59.94,Default,,0,0,0,,因此这里既在数字上递归 又在列表的结构上递归了
Dialogue: 0,0:13:00.86,0:13:06.15,Default,,0,0,0,,课件上的最后一个例子是接续（append）两个列表
Dialogue: 0,0:13:06.15,0:13:11.59,Default,,0,0,0,,如果把一个空表接到另一个表上 结果和原来那个列表一样
Dialogue: 0,0:13:11.59,0:13:20.35,Default,,0,0,0,,如果想将 (x:xs) 的列表接到 ys 这个列表上时 首先将 xs 和 ys 接续到一起
Dialogue: 0,0:13:20.35,0:13:24.19,Default,,0,0,0,,再在前面连接（cons） x 十分显而易见
Dialogue: 0,0:13:24.19,0:13:28.91,Default,,0,0,0,,非常感谢 第二部分再见
