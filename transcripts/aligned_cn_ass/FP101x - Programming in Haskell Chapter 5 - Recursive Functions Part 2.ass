[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: None

[Aegisub Project Garbage]
Audio File: ../../../courses/FP101x-chapter5-part2-video.mp4
Scroll Position: 102
Active Line: 143

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,Arial,20,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,2,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:01.44,0:00:08.91,Default,,0,0,0,,欢迎回来 希望你的大脑没有因为递归而栈溢出
Dialogue: 0,0:00:08.91,0:00:13.07,Default,,0,0,0,,第二部分会讲一些轻松的内容
Dialogue: 0,0:00:13.07,0:00:19.54,Default,,0,0,0,,具体来说 就是讲解一些练习题
Dialogue: 0,0:00:19.54,0:00:24.41,Default,,0,0,0,,在这章的网站上可以看到
Dialogue: 0,0:00:24.41,0:00:28.73,Default,,0,0,0,,第一节课中
Dialogue: 0,0:00:28.73,0:00:34.80,Default,,0,0,0,,我们捎带提到过使用 Haskell 实现快速排序（quicksort）
Dialogue: 0,0:00:34.80,0:00:42.70,Default,,0,0,0,,现在就详细地讲解一下快速排序的 Haskell 实现
Dialogue: 0,0:00:43.06,0:00:50.56,Default,,0,0,0,,快速排序的想法是递归地对列表排序
Dialogue: 0,0:00:50.56,0:00:53.90,Default,,0,0,0,,首先用某种方式将列表分解
Dialogue: 0,0:00:53.90,0:00:57.12,Default,,0,0,0,,再递归地排序这些列表
Dialogue: 0,0:00:57.12,0:00:59.99,Default,,0,0,0,,最后把结果结合到一起
Dialogue: 0,0:01:00.93,0:01:04.34,Default,,0,0,0,,如果仔细考虑一下可以发现
Dialogue: 0,0:01:04.90,0:01:09.00,Default,,0,0,0,,对于空表来说 已经排好序了
Dialogue: 0,0:01:10.02,0:01:13.27,Default,,0,0,0,,接下来进行递归
Dialogue: 0,0:01:13.27,0:01:20.05,Default,,0,0,0,,如何将列表分成两部分 来分别递归排序
Dialogue: 0,0:01:20.05,0:01:24.35,Default,,0,0,0,,并且可以很简单地把结果结合成一个排好序的列表呢
Dialogue: 0,0:01:24.35,0:01:28.93,Default,,0,0,0,,要做的是查看一下列表的头元素（head）
Dialogue: 0,0:01:28.93,0:01:35.78,Default,,0,0,0,,再把列表一分为二 一个是小于等于头元素的值组成的列表
Dialogue: 0,0:01:35.78,0:01:39.04,Default,,0,0,0,,另一个是大于头元素的值组成的列表
Dialogue: 0,0:01:39.04,0:01:43.52,Default,,0,0,0,,之后就可以递归地对两个列表进行排序了
Dialogue: 0,0:01:43.52,0:01:47.50,Default,,0,0,0,,最终将头元素插在中间 就结束了
Dialogue: 0,0:01:47.50,0:01:53.08,Default,,0,0,0,,这就是快速排序的算法精要
Dialogue: 0,0:01:53.08,0:01:55.35,Default,,0,0,0,,但我已经提醒过了
Dialogue: 0,0:01:55.35,0:01:58.76,Default,,0,0,0,,真正的实现中 不是创建新的列表
Dialogue: 0,0:01:58.76,0:02:04.70,Default,,0,0,0,,而是在原位改变（mutate）数据结构来交换元素
Dialogue: 0,0:02:04.70,0:02:09.77,Default,,0,0,0,,这在当前的实现中是没有体现出来的
Dialogue: 0,0:02:09.77,0:02:13.46,Default,,0,0,0,,但它的确展示了递归结构
Dialogue: 0,0:02:14.09,0:02:18.47,Default,,0,0,0,,好了 这就是快速排序的实现
Dialogue: 0,0:02:18.47,0:02:22.36,Default,,0,0,0,,它和第一节课的很像
Dialogue: 0,0:02:22.36,0:02:26.45,Default,,0,0,0,,唯一的区别只是名字叫 quicksort 而不是 f
Dialogue: 0,0:02:26.45,0:02:32.39,Default,,0,0,0,,遇到空列表时 它已经被排好序了
Dialogue: 0,0:02:32.39,0:02:37.91,Default,,0,0,0,,当遇到 x 连接（cons） xs 时 要排序的话
Dialogue: 0,0:02:37.91,0:02:45.43,Default,,0,0,0,,首先创建一个列表 使其元素都小于或等于 x
Dialogue: 0,0:02:47.28,0:02:50.21,Default,,0,0,0,,我们使用列表解析（list comprehension）来实现
Dialogue: 0,0:02:50.21,0:02:54.39,Default,,0,0,0,,接下来创建一个所有元素都比 x 大的列表
Dialogue: 0,0:02:54.39,0:03:00.32,Default,,0,0,0,,把两个都排序 再把 x 放在中间
Dialogue: 0,0:03:02.30,0:03:06.92,Default,,0,0,0,,这是一个很简单的快速排序实现
Dialogue: 0,0:03:06.92,0:03:12.49,Default,,0,0,0,,但同时 它也是一个简化了的快速排序实现
Dialogue: 0,0:03:12.49,0:03:14.88,Default,,0,0,0,,但如果是为了理解结构
Dialogue: 0,0:03:14.88,0:03:18.37,Default,,0,0,0,,这是一个很好的示例
Dialogue: 0,0:03:19.07,0:03:23.54,Default,,0,0,0,,可以体现其工作原理
Dialogue: 0,0:03:23.54,0:03:26.65,Default,,0,0,0,,让我们把快速排序记为 q
Dialogue: 0,0:03:26.65,0:03:29.98,Default,,0,0,0,,好让课件不至于溢出
Dialogue: 0,0:03:31.17,0:03:34.01,Default,,0,0,0,,如果要排序列表 [3, 2, 4, 1, 5]
Dialogue: 0,0:03:34.01,0:03:37.18,Default,,0,0,0,,要做的就是取头元素 3
Dialogue: 0,0:03:37.18,0:03:42.64,Default,,0,0,0,,再把列表剩下的元素 分成一组小于等于 3 的
Dialogue: 0,0:03:42.64,0:03:45.63,Default,,0,0,0,,还有一组大于 3 的
Dialogue: 0,0:03:45.98,0:03:51.56,Default,,0,0,0,,小于等于的是 1 和 2
Dialogue: 0,0:03:51.56,0:03:54.35,Default,,0,0,0,,大于的是 4 和 5
Dialogue: 0,0:03:54.35,0:03:58.52,Default,,0,0,0,,可以看到 递归排序两个列表
Dialogue: 0,0:03:58.52,0:04:02.84,Default,,0,0,0,,再把 3 插入到中间
Dialogue: 0,0:04:03.16,0:04:06.98,Default,,0,0,0,,如果要排序列表 [2, 1]
Dialogue: 0,0:04:06.98,0:04:11.41,Default,,0,0,0,,首先取头元素 再拆分剩下的列表 也就是 1
Dialogue: 0,0:04:11.41,0:04:14.69,Default,,0,0,0,,把它分成小于等于的值 以及大于的值
Dialogue: 0,0:04:14.69,0:04:17.15,Default,,0,0,0,,大于的列表是空表
Dialogue: 0,0:04:17.15,0:04:19.84,Default,,0,0,0,,小于的列表只有 1
Dialogue: 0,0:04:19.84,0:04:24.74,Default,,0,0,0,,再把 2 插入到中间
Dialogue: 0,0:04:25.16,0:04:27.53,Default,,0,0,0,,右边的同理
Dialogue: 0,0:04:27.53,0:04:30.38,Default,,0,0,0,,首先取第一个元素
Dialogue: 0,0:04:30.38,0:04:33.54,Default,,0,0,0,,再拆分剩下的列表 也就是 5
Dialogue: 0,0:04:33.54,0:04:37.55,Default,,0,0,0,,分成大于 4 的列表 也就是 5
Dialogue: 0,0:04:37.55,0:04:41.17,Default,,0,0,0,,小于的列表是空表
Dialogue: 0,0:04:41.17,0:04:44.84,Default,,0,0,0,,再把 4 插入到中间
Dialogue: 0,0:04:45.54,0:04:51.03,Default,,0,0,0,,这两个地方都是空表
Dialogue: 0,0:04:51.03,0:04:54.63,Default,,0,0,0,,已经排好序了 所以不用做任何事情了
Dialogue: 0,0:04:54.63,0:04:58.80,Default,,0,0,0,,接下来要对一个元素的列表进行排序
Dialogue: 0,0:04:58.80,0:05:05.02,Default,,0,0,0,,可以验证 对只有一个元素的列表进行排序 返回的是原列表本身
Dialogue: 0,0:05:06.71,0:05:14.26,Default,,0,0,0,,如果进行递归调用的话 就得到了这个列表
Dialogue: 0,0:05:14.26,0:05:22.53,Default,,0,0,0,,可以看到结果就是 [1, 2, 3, 4, 5]
Dialogue: 0,0:05:22.87,0:05:27.31,Default,,0,0,0,,只需要遍历一次树就可以得到结果了
Dialogue: 0,0:05:29.27,0:05:32.54,Default,,0,0,0,,这就是快速排序
Dialogue: 0,0:05:33.45,0:05:40.46,Default,,0,0,0,,本周有很多练习题 要求使用递归的方式定义函数
Dialogue: 0,0:05:40.46,0:05:47.61,Default,,0,0,0,,但现在就一起来看几个吧
Dialogue: 0,0:05:47.61,0:05:49.68,Default,,0,0,0,,首先来看第一个
Dialogue: 0,0:05:49.68,0:05:55.51,Default,,0,0,0,,要求生成一个列表 有 n 个相同的元素
Dialogue: 0,0:05:55.98,0:06:00.02,Default,,0,0,0,,也就是说 函数接收一个整数 n
Dialogue: 0,0:06:00.44,0:06:03.84,Default,,0,0,0,,再接收一个值 a
Dialogue: 0,0:06:03.84,0:06:12.33,Default,,0,0,0,,应当返回一个列表 其中 a 的值复制了 n 份
Dialogue: 0,0:06:12.82,0:06:14.71,Default,,0,0,0,,如何做到呢
Dialogue: 0,0:06:14.71,0:06:21.11,Default,,0,0,0,,解决的方法不是在 a 的值上递归
Dialogue: 0,0:06:21.11,0:06:23.26,Default,,0,0,0,,我们要建成一个列表
Dialogue: 0,0:06:23.26,0:06:30.45,Default,,0,0,0,,因此应该做的是在整数的结构上递归
Dialogue: 0,0:06:30.45,0:06:32.85,Default,,0,0,0,,所以同样分成两种情况
Dialogue: 0,0:06:32.85,0:06:38.16,Default,,0,0,0,,n 等于 0 把一个元素复制 0 份
Dialogue: 0,0:06:38.53,0:06:42.49,Default,,0,0,0,,得到的就是空表 这是个简单的情况
Dialogue: 0,0:06:42.85,0:06:47.81,Default,,0,0,0,,如果要把一个值复制 n 次 该如何做到
Dialogue: 0,0:06:47.81,0:06:52.40,Default,,0,0,0,,首先复制 n-1 次
Dialogue: 0,0:06:52.40,0:06:56.14,Default,,0,0,0,,得到一个列表 进行了 n-1 次复制
Dialogue: 0,0:06:56.14,0:06:58.51,Default,,0,0,0,,接下来把 a 连接（cons）到上面
Dialogue: 0,0:06:59.24,0:07:01.27,Default,,0,0,0,,这道题很容易
Dialogue: 0,0:07:01.27,0:07:04.55,Default,,0,0,0,,但同样的 需要仔细观察
Dialogue: 0,0:07:04.55,0:07:09.11,Default,,0,0,0,,之后就能发现 应该在这里进行递归
Dialogue: 0,0:07:09.11,0:07:15.12,Default,,0,0,0,,要分两种情况 把它们都写下来 剩下的也就知道了
Dialogue: 0,0:07:16.21,0:07:21.91,Default,,0,0,0,,下面这个我们在之前的课里也见到过
Dialogue: 0,0:07:21.91,0:07:28.53,Default,,0,0,0,,当时我提醒说 Haskell 中的列表没有常数时间的访问方法
Dialogue: 0,0:07:28.53,0:07:32.70,Default,,0,0,0,,实现这个函数时 就能清楚地明白了
Dialogue: 0,0:07:32.70,0:07:42.98,Default,,0,0,0,,要做的是 接收一个列表和一个数字 返回列表中那个位置上的元素
Dialogue: 0,0:07:44.40,0:07:53.73,Default,,0,0,0,,当然可以用 take drop 或其他函数来实现 但现在是要用递归
Dialogue: 0,0:07:54.48,0:07:58.08,Default,,0,0,0,,既然有两个递归结构
Dialogue: 0,0:07:58.08,0:08:00.58,Default,,0,0,0,,列表和整数
Dialogue: 0,0:08:01.08,0:08:06.71,Default,,0,0,0,,可以在两个上面一起递归来定义
Dialogue: 0,0:08:07.51,0:08:10.53,Default,,0,0,0,,那是怎么做的呢
Dialogue: 0,0:08:10.53,0:08:16.43,Default,,0,0,0,,首先如果要取列表的第 0 个元素
Dialogue: 0,0:08:16.43,0:08:18.68,Default,,0,0,0,,也就是列表的头元素
Dialogue: 0,0:08:18.68,0:08:24.02,Default,,0,0,0,,如果列表的形式是 x 连接 xs 并且这个参数是 0 的话
Dialogue: 0,0:08:24.02,0:08:31.18,Default,,0,0,0,,那这个元素就是答案 因为列表中第一个元素的下标就是 0
Dialogue: 0,0:08:31.18,0:08:33.76,Default,,0,0,0,,这个情况很简单
Dialogue: 0,0:08:34.42,0:08:40.26,Default,,0,0,0,,如果列表是空表的话
Dialogue: 0,0:08:40.26,0:08:43.19,Default,,0,0,0,,那该怎么办呢 这是个好问题
Dialogue: 0,0:08:43.50,0:08:48.50,Default,,0,0,0,,可能当我想要取一个空表的第 n 个元素
Dialogue: 0,0:08:49.72,0:08:51.06,Default,,0,0,0,,会产生一个错误
Dialogue: 0,0:08:51.06,0:08:54.92,Default,,0,0,0,,所以现在先不用考虑 放到最后一种情况再说
Dialogue: 0,0:08:55.28,0:09:02.08,Default,,0,0,0,,现在可以假设这个不是 0 这个不是空表
Dialogue: 0,0:09:02.08,0:09:04.71,Default,,0,0,0,,如果这个是 0 那就结束了
Dialogue: 0,0:09:04.71,0:09:09.33,Default,,0,0,0,,如果这个是空表 且这个不是 0 那就出错了
Dialogue: 0,0:09:09.33,0:09:12.20,Default,,0,0,0,,现在它们都不是 0 该怎么做
Dialogue: 0,0:09:12.20,0:09:18.04,Default,,0,0,0,,也就是说 这个是 x 连接 xs 这个是 n
Dialogue: 0,0:09:18.56,0:09:26.51,Default,,0,0,0,,要做的是取尾列表（tail）的第 n-1 个元素
Dialogue: 0,0:09:27.87,0:09:33.97,Default,,0,0,0,,也是简单的递归 只需要小心一下这些基本情况（base case）
Dialogue: 0,0:09:35.76,0:09:39.91,Default,,0,0,0,,最后要用递归定义的函数是
Dialogue: 0,0:09:39.91,0:09:46.79,Default,,0,0,0,,判断一个值是否在给定的列表中
Dialogue: 0,0:09:46.79,0:09:52.05,Default,,0,0,0,,当然我们可以作弊 不用递归
Dialogue: 0,0:09:52.05,0:09:57.01,Default,,0,0,0,,可以很容易地使用 filter （过滤）或者列表解析 或其他的
Dialogue: 0,0:09:57.01,0:10:02.20,Default,,0,0,0,,但现在的目标是用递归定义这个函数
Dialogue: 0,0:10:02.59,0:10:09.26,Default,,0,0,0,,这时很容易想到一个递归的候选 也就是列表
Dialogue: 0,0:10:09.26,0:10:14.67,Default,,0,0,0,,如果在空表中查找一个元素 返回的就是假
Dialogue: 0,0:10:14.67,0:10:16.78,Default,,0,0,0,,元素不在列表中
Dialogue: 0,0:10:18.26,0:10:24.01,Default,,0,0,0,,如果在 x 连接 xs 中寻找一个元素
Dialogue: 0,0:10:24.01,0:10:30.52,Default,,0,0,0,,需要检查列表的头元素是否等于要找的元素
Dialogue: 0,0:10:30.52,0:10:33.46,Default,,0,0,0,,如果是的话 那就返回真
Dialogue: 0,0:10:33.92,0:10:39.78,Default,,0,0,0,,否则的话 就在尾列表中查找那个元素
Dialogue: 0,0:10:39.78,0:10:43.31,Default,,0,0,0,,最终列表的尾列表（tail）将变空
Dialogue: 0,0:10:43.31,0:10:45.90,Default,,0,0,0,,回到基本情况 也就完成了
Dialogue: 0,0:10:46.24,0:10:55.24,Default,,0,0,0,,可以看到 这里在检查列表每一个头元素是否与这个元素相等 直到找到一个
Dialogue: 0,0:10:55.83,0:11:00.86,Default,,0,0,0,,类型 a 必须支持相等性（equality） 因此可以在类型中看到
Dialogue: 0,0:11:00.86,0:11:05.13,Default,,0,0,0,,要从一个列表中搜索一个值
Dialogue: 0,0:11:05.63,0:11:08.89,Default,,0,0,0,,只有当列表的类型支持相等性（equality）才可以
Dialogue: 0,0:11:08.89,0:11:16.35,Default,,0,0,0,,这就是为何此处要有约束（constraint） 要求 a 在类型类（type class） Eq a 中
Dialogue: 0,0:11:17.37,0:11:23.33,Default,,0,0,0,,好 希望这些有所帮助 这些小的练习
Dialogue: 0,0:11:23.33,0:11:26.74,Default,,0,0,0,,我说过 在网站上
Dialogue: 0,0:11:26.74,0:11:31.60,Default,,0,0,0,,还有很多使用递归的练习
Dialogue: 0,0:11:31.60,0:11:38.70,Default,,0,0,0,,如果卡住的话 试着吃根香蕉 也许能帮上忙
Dialogue: 0,0:11:38.70,0:11:42.26,Default,,0,0,0,,也可以吃两根
Dialogue: 0,0:11:42.26,0:11:45.85,Default,,0,0,0,,那帮助就更大了 下周再见
